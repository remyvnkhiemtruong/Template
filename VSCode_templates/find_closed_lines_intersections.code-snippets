{
    "tranxuanbach": {
        "prefix": "find_closed_lines_intersections",
        "body": [
            "// act_while(i, j): line i and j intersects where i were below j before the intersection",
            "// Each intersections are visited in increasing order of x-coordinate",
            "// Assumes that after extending each segments by 1e-5, no endpoint of a line lies on another line.",
            "// Requires point, line, and line_intersection",
            "/*",
            "Warning: currently, the following case blows up this impl",
            "4",
            "1 3 4 1 ",
            "2 3 2 0 ",
            "2 3 4 2 ",
            "2 2 2 4",
            "And I have no idea how to deal with this case.",
            "*/",
            "// act_while(i, j): line i and j intersects where i were below j before the intersection",
            "// Each intersections are visited in increasing order of x-coordinate",
            "// Assumes that after extending each segments by 1e-5, no endpoint of a line lies on another line.",
            "// Requires point, line, and line_intersection",
            "template<class T>",
            "void find_closed_lines_intersections(vector<line<T>> L, auto act_while){",
            "\tint n = (int)L.size();",
            "\tusing pq_type = pair<pointld, array<int, 2>>;",
            "\tauto type = [&](int x)->int{",
            "\t\tif(x == -1) return 0;",
            "\t\tif(x < n) return 1;",
            "\t\treturn 2;",
            "\t};",
            "\tauto cmp = [&](const pq_type &x, const pq_type &y)->bool{",
            "\t\tif(distance(x.first, y.first) > 1e-9L) return x.first > y.first;",
            "\t\tint tx = type(x.second[0]), ty = type(y.second[0]);",
            "\t\tif(tx != ty) return tx > ty;",
            "\t\tif(tx == 0){",
            "\t\t\tauto prod = L[x.second[1]].d ^ L[y.second[1]].d;",
            "\t\t\tif(abs(prod) > 1e-9L) return prod > 0;",
            "\t\t\treturn x.second[1] < y.second[1];",
            "\t\t}",
            "\t\telse if(tx == 1){",
            "\t\t\tauto prod = L[x.second[0]].d ^ L[y.second[0]].d;",
            "\t\t\tif(abs(prod) > 1e-9L) return prod < 0;",
            "\t\t\tif(x.second[0] != y.second[0]) return x.second[0] > y.second[0];",
            "\t\t\tprod = L[x.second[1]].d ^ L[y.second[1]].d;",
            "\t\t\tif(abs(prod) > 1e-9L) return prod < 0;",
            "\t\t\treturn x.second[1] > y.second[1];",
            "\t\t}",
            "\t\telse return false;",
            "\t};",
            "\tpriority_queue<pq_type, vector<pq_type>, decltype(cmp)> event(cmp);",
            "\tfor(auto i = 0; i < n; ++ i){",
            "\t\tif(L[i].d < point<T>()) L[i].flip();",
            "\t\tevent.push({pointld(L[i].p), {-1, i}});",
            "\t\tevent.push({pointld(L[i].q()), {n, i}});",
            "\t}",
            "\tstatic pointld pos;",
            "\tstruct key_type{",
            "\t\tline<T> l;",
            "\t\tint id;",
            "\t\tbool operator<(const key_type &x) const{",
            "\t\t\tline<T> r = x.l;",
            "\t\t\tdouble yi, yj;",
            "\t\t\tyi = l.d.x == 0 ? pos.y : l.p.y + (pos.x - l.p.x) / l.d.x * l.d.y;",
            "\t\t\tyj = r.d.x == 0 ? pos.y : r.p.y + (pos.x - r.p.x) / r.d.x * r.d.y;",
            "\t\t\treturn abs(yi - yj) <= 1e-9L ? false : yi < yj;",
            "\t\t}",
            "\t\tbool operator<(const line<T> &r) const{",
            "\t\t\tdouble yi, yj;",
            "\t\t\tyi = l.d.x == 0 ? pos.y : l.p.y + (pos.x - l.p.x) / l.d.x * l.d.y;",
            "\t\t\tyj = r.d.x == 0 ? pos.y : r.p.y + (pos.x - r.p.x) / r.d.x * r.d.y;",
            "\t\t\treturn abs(yi - yj) <= 1e-9L ? (l.d ^ r.d) < 0 : yi < yj;",
            "\t\t}",
            "\t};",
            "\tmultiset<key_type, less<>> sweepline;",
            "\tauto print = [&]()->void{",
            "\t\tfor(auto k: sweepline){",
            "\t\t\tcerr << \"{\" << k.l << \" \" << k.id << \"} \";",
            "\t\t}",
            "\t\tcerr << \"\\n\";",
            "\t};",
            "\tvector<typename multiset<key_type>::iterator> where(n);",
            "\tset<array<int, 2>> matched;",
            "\tauto check = [&](int i, int j)->bool{",
            "\t\treturn !matched.count({min(i, j), max(i, j)});",
            "\t};",
            "\tauto insert = [&](int i, int j)->void{",
            "\t\tmatched.insert({min(i, j), max(i, j)});",
            "\t};",
            "\twhile(!event.empty()){",
            "\t\tauto [p, _info] = event.top();",
            "\t\tevent.pop();",
            "\t\tpos = p;",
            "\t\tauto [i, j] = _info;",
            "\t\tif(i == -1){",
            "\t\t\ti = j;",
            "\t\t\tauto it = where[i] = sweepline.insert(sweepline.lower_bound(L[i]), {L[i], i});",
            "\t\t\tif(it != sweepline.begin() && check(prev(it)->id, i)) if(auto ptr = intersect_closed_segments(L[prev(it)->id], L[i])){",
            "\t\t\t\tinsert(prev(it)->id, i);",
            "\t\t\t\tevent.push({ptr->first, {prev(it)->id, i}});",
            "\t\t\t}",
            "\t\t\tif(next(it) != sweepline.end() && check(i, next(it)->id)) if(auto ptr = intersect_closed_segments(L[i], L[next(it)->id])){",
            "\t\t\t\tinsert(i, next(it)->id);",
            "\t\t\t\tevent.push({ptr->first, {i, next(it)->id}});",
            "\t\t\t}",
            "\t\t}",
            "\t\telse if(i == n){",
            "\t\t\ti = j;",
            "\t\t\tauto it = where[i];",
            "\t\t\tif(it != sweepline.begin() && next(it) != sweepline.end() && check(prev(it)->id, next(it)->id)) if(auto ptr = intersect_closed_segments(L[prev(it)->id], L[next(it)->id])){",
            "\t\t\t\tinsert(prev(it)->id, next(it)->id);",
            "\t\t\t\tevent.push({ptr->first, {prev(it)->id, next(it)->id}});",
            "\t\t\t}",
            "\t\t\tsweepline.erase(where[i]);",
            "\t\t}",
            "\t\telse{",
            "\t\t\tif(!act_while(i, j)) return;",
            "\t\t\tauto iti = where[i];",
            "\t\t\tsweepline.erase(where[j]);",
            "\t\t\tauto itj = where[j] = sweepline.insert(iti, {L[j], j});",
            "\t\t\tif(itj != sweepline.begin() && check(prev(itj)->id, j)) if(auto ptr = intersect_closed_segments(L[prev(itj)->id], L[j])){",
            "\t\t\t\tinsert(prev(itj)->id, j);",
            "\t\t\t\tevent.push({ptr->first, {prev(itj)->id, j}});",
            "\t\t\t}",
            "\t\t\tif(next(iti) != sweepline.end() && check(i, next(iti)->id)) if(auto ptr = intersect_closed_segments(L[i], L[next(iti)->id])){",
            "\t\t\t\tinsert(i, next(iti)->id);",
            "\t\t\t\tevent.push({ptr->first, {i, next(iti)->id}});",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "}"
        ],
        "description": "tranxuanbach"
    }
}