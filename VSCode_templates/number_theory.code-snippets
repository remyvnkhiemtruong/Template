{
    "tranxuanbach": {
        "prefix": "number_theory",
        "body": [
            "struct number_theory{",
            "\tint SZ;",
            "\tvector<int> lpf, prime;",
            "\tnumber_theory(int SZ): SZ(SZ), lpf(SZ + 1){ // O(SZ)",
            "\t\tlpf[0] = lpf[1] = numeric_limits<int>::max() / 2;",
            "\t\tfor(auto i = 2; i <= SZ; ++ i){",
            "\t\t\tif(!lpf[i]) lpf[i] = i, prime.push_back(i);",
            "\t\t\tfor(auto j = 0; j < (int)prime.size() && prime[j] <= lpf[i] && prime[j] * i <= SZ; ++ j) lpf[prime[j] * i] = prime[j];",
            "\t\t}",
            "\t}",
            "\tvector<int> precalc_mobius() const{",
            "\t\tvector<int> mobius(SZ + 1, 1);",
            "\t\tfor(auto i = 2; i <= SZ; ++ i){",
            "\t\t\tif(i / lpf[i] % lpf[i]) mobius[i] = -mobius[i / lpf[i]];",
            "\t\t\telse mobius[i] = 0;",
            "\t\t}",
            "\t\treturn mobius;",
            "\t}",
            "\tvector<int> precalc_phi() const{",
            "\t\tvector<int> phi(SZ + 1, 1);",
            "\t\tfor(auto i = 2; i <= SZ; ++ i){",
            "\t\t\tif(i / lpf[i] % lpf[i]) phi[i] = phi[i / lpf[i]] * (lpf[i] - 1);",
            "\t\t\telse phi[i] = phi[i / lpf[i]] * lpf[i];",
            "\t\t}",
            "\t\treturn phi;",
            "\t}",
            "\t// Returns {gcd(0, n), ..., gcd(SZ, n)}",
            "\tvector<int> precalc_gcd(int n) const{",
            "\t\tvector<int> res(SZ + 1, 1);",
            "\t\tres[0] = n;",
            "\t\tfor(auto x = 2; x <= SZ; ++ x) res[x] = n % (lpf[x] * res[x / lpf[x]]) ? res[x / lpf[x]] : lpf[x] * res[x / lpf[x]];",
            "\t\treturn res;",
            "\t}",
            "\tbool is_prime(int x) const{",
            "\t\tassert(0 <= x && x <= SZ);",
            "\t\treturn lpf[x] == x;",
            "\t}",
            "\tint mu_large(long long x) const{ // O(sqrt(x))",
            "\t\tint res = 1;",
            "\t\tfor(auto i = 2LL; i * i <= x; ++ i) if(x % i == 0){",
            "\t\t\tif(x / i % i) return 0;",
            "\t\t\tx /= i, res = -res;",
            "\t\t}",
            "\t\tif(x > 1) res = -res;",
            "\t\treturn res;",
            "\t}",
            "\tlong long phi_large(long long x) const{ // O(sqrt(x))",
            "\t\tlong long res = x;",
            "\t\tfor(auto i = 2LL; i * i <= x; ++ i) if(x % i == 0){",
            "\t\t\twhile(x % i == 0) x /= i;",
            "\t\t\tres -= res / i;",
            "\t\t}",
            "\t\tif(x > 1) res -= res / x;",
            "\t\treturn res;",
            "\t}",
            "\t// returns an array is_prime of length high-low where is_prime[i] = [low+i is a prime]",
            "\tvector<int> sieve(long long low, long long high) const{",
            "\t\tassert(high - 1 <= 1LL * SZ * SZ);",
            "\t\tvector<int> is_prime(high - low, true);",
            "\t\tfor(auto p: prime) for(auto x = max(1LL * p, (low + p - 1) / p) * p; x < high; x += p) is_prime[x - low] = false;",
            "\t\tfor(auto x = 1; x >= low; -- x) is_prime[x - low] = false;",
            "\t\treturn is_prime;",
            "\t}",
            "};"
        ],
        "description": "tranxuanbach"
    }
}