{
    "tranxuanbach": {
        "prefix": "bfs_forest",
        "body": [
            "// Requires graph",
            "template<class T>",
            "struct bfs_forest{",
            "\tint n;",
            "\tT base_dist;",
            "\tvector<T> dist;",
            "\tvector<int> pv;",
            "\tvector<int> pe;",
            "\tvector<int> order;",
            "\tvector<int> pos;",
            "\tvector<int> size;",
            "\tvector<int> root_of;",
            "\tvector<int> root;",
            "\tvector<int> depth;",
            "\tvector<int> was;",
            "\tbfs_forest(T base_dist = 0): base_dist(base_dist){ }",
            "\tvoid init(int n){",
            "\t\tthis->n = n;",
            "\t\tpv.assign(n, -1);",
            "\t\tpe.assign(n, -1);",
            "\t\torder.clear();",
            "\t\tpos.assign(n, -1);",
            "\t\tsize.assign(n, -1);",
            "\t\troot_of.assign(n, -1);",
            "\t\troot.clear();",
            "\t\tdepth.assign(n, -1);",
            "\t\tdist.assign(n, base_dist);",
            "\t\twas.assign(n, -2);",
            "\t\tattempt = -1;",
            "\t}",
            "\tint attempt;",
            "\tvector<int> q;",
            "\t// O(# of nodes reachable from src)",
            "\ttemplate<class F = plus<>>",
            "\tvoid _bfs(const graph<T> &g, const vector<int> &src, F UT = plus<>()){",
            "\t\tq = src;",
            "\t\tfor(auto u: src){",
            "\t\t\tassert(was[u] != attempt);",
            "\t\t\twas[u] = attempt;",
            "\t\t\tdepth[u] = 0;",
            "\t\t\tdist[u] = base_dist;",
            "\t\t\troot_of[u] = u;",
            "\t\t\troot.push_back(u);",
            "\t\t\tpv[u] = -1;",
            "\t\t\tpe[u] = -1;",
            "\t\t}",
            "\t\tint init_size = (int)order.size();",
            "\t\tfor(auto it = 0; it < (int)q.size(); ++ it){",
            "\t\t\tint u = q[it];",
            "\t\t\tpos[u] = (int)order.size();",
            "\t\t\torder.push_back(u);",
            "\t\t\tsize[u] = 1;",
            "\t\t\tfor(auto id: g.adj[u]){",
            "\t\t\t\tif(g.ignore && g.ignore(id)) continue;",
            "\t\t\t\tint v = g(u, id);",
            "\t\t\t\tif(was[v] == attempt) continue;",
            "\t\t\t\twas[v] = attempt;",
            "\t\t\t\tdepth[v] = depth[u] + 1;",
            "\t\t\t\tdist[v] = UT(g.edge[id].cost, dist[u]);",
            "\t\t\t\tpv[v] = u;",
            "\t\t\t\tpe[v] = id;",
            "\t\t\t\troot_of[v] = root_of[u];",
            "\t\t\t\tq.push_back(v);",
            "\t\t\t}",
            "\t\t}",
            "\t\tfor(auto i = (int)order.size() - 1; i >= init_size; -- i){",
            "\t\t\tint u = order[i];",
            "\t\t\tif(~pv[u]) size[pv[u]] += size[u];",
            "\t\t}",
            "\t\tq.clear();",
            "\t}",
            "\t// O(# of nodes reachable from src)",
            "\ttemplate<class F = plus<>>",
            "\tvoid bfs(const graph<T> &g, const vector<int> &src, F UT = plus<>()){",
            "\t\tassert(g.n <= n);",
            "\t\troot.clear(), order.clear();",
            "\t\tfor(auto u: src) assert(0 <= u && u < g.n);",
            "\t\t++ attempt;",
            "\t\t_bfs(g, src, UT);",
            "\t}",
            "\t// O(n + m)",
            "\ttemplate<class U, class F = plus<>>",
            "\tvoid bfs_all(const graph<U> &g, F UT = plus<>()){",
            "\t\tassert(g.n <= n);",
            "\t\troot.clear(), order.clear();",
            "\t\t++ attempt;",
            "\t\tfor(auto u = 0; u < g.n; ++ u) if(was[u] != attempt) _bfs(g, {u}, UT);",
            "\t}",
            "\t// Check if u is visited during the last bfs-like call.",
            "\tbool visited(int u) const{",
            "\t\tassert(0 <= u && u < n);",
            "\t\treturn was[u] == attempt;",
            "\t}",
            "\tvector<int> get_path(int u, int v) const{",
            "\t\tassert(visited(u) && visited(v) && root_of[u] == root_of[v]);",
            "\t\tvector<int> left, right;",
            "\t\twhile(u != v){",
            "\t\t\tif(depth[u] >= depth[v]){",
            "\t\t\t\tleft.push_back(u);",
            "\t\t\t\tu = pv[u];",
            "\t\t\t}",
            "\t\t\telse{",
            "\t\t\t\tright.push_back(v);",
            "\t\t\t\tv = pv[v];",
            "\t\t\t}",
            "\t\t}",
            "\t\tleft.push_back(u);",
            "\t\tleft.insert(left.end(), right.rbegin(), right.rend());",
            "\t\treturn left;",
            "\t}",
            "};"
        ],
        "description": "tranxuanbach"
    }
}