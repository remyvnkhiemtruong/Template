{
    "tranxuanbach": {
        "prefix": "chinese_remainder_theorem_linear",
        "body": [
            "// T must be able to hold lcm of mods",
            "template<class T>",
            "struct chinese_remainder_theorem_linear{",
            "#define IS_INTEGRAL(T) (is_integral_v<T> || is_same_v<T, __int128_t> || is_same_v<T, __uint128_t>)",
            "#define IS_SIGNED(T) (is_signed_v<T> || is_same_v<T, __int128_t>)",
            "\tstatic_assert(IS_SIGNED(T));",
            "#ifdef LOCAL",
            "\t#define ASSERT(c) assert(c)",
            "#else",
            "\t#define ASSERT(c) 42",
            "#endif",
            "\tvector<T> mod;",
            "\tvector<T> mod_prefix = {1};",
            "\tvector<T> q;",
            "\tvector<T> gcd;",
            "\tvector<T> coef;",
            "\ttemplate<class U>",
            "\tpair<U, U> _inv_gcd(U a, U b){",
            "\t\ta %= b;",
            "\t\tif(a < 0) a += b;",
            "\t\tif(a == 0) return {b, 0};",
            "\t\tU s = b, t = a, m0 = 0, m1 = 1, u, tmp;",
            "\t\twhile(t){",
            "\t\t\tm0 -= m1 * (u = s / t);",
            "\t\t\ttmp = s -= t * u;",
            "\t\t\ts = t, t = tmp, tmp = m0, m0 = m1, m1 = tmp;",
            "\t\t}",
            "\t\tif(m0 < 0) m0 += b / s;",
            "\t\treturn {s, m0};",
            "\t}",
            "\t// O(n * log(MAXVAL))",
            "\ttemplate<class U>",
            "\tchinese_remainder_theorem_linear(const vector<U> &mod){ init(mod); }",
            "\t// O(n * log(MAXVAL))",
            "\ttemplate<class... U, typename enable_if<(IS_INTEGRAL(U) && ...)>::type* = nullptr>",
            "\tchinese_remainder_theorem_linear(const U &... mods): chinese_remainder_theorem_linear(vector<T>({(T)mods...})){ }",
            "\ttemplate<class U>",
            "\tvoid init(const vector<U> &mod){",
            "\t\tthis->mod.resize((int)mod.size());",
            "\t\tcopy(mod.begin(), mod.end(), this->mod.begin());",
            "\t\tmod_prefix.resize((int)mod.size() + 1, 1);",
            "\t\tq.resize((int)mod.size());",
            "\t\tgcd.resize((int)mod.size());",
            "\t\tcoef.resize((int)mod.size());",
            "\t\tT m0 = 1;",
            "\t\tfor(auto i = 0; i < (int)mod.size(); ++ i){",
            "\t\t\tASSERT(mod[i] >= 1);",
            "\t\t\tT m1 = mod[i];",
            "\t\t\tif(m0 < m1) swap(m0, m1);",
            "\t\t\tif(m0 % m1 == 0) continue;",
            "\t\t\ttie(gcd[i], coef[i]) = _inv_gcd(m0, m1);",
            "\t\t\tm0 *= q[i] = m1 / gcd[i];",
            "\t\t\tmod_prefix[i + 1] = m0;",
            "\t\t}",
            "\t}",
            "\t// O(n * log(MAXVAL))",
            "\ttemplate<class... U, typename enable_if<(IS_INTEGRAL(U) && ...)>::type* = nullptr>",
            "\tvoid init(const U &... mods){",
            "\t\tinit<T>(vector<T>({(T)mods...}));",
            "\t}",
            "\t// Returns {0, 0} if no solution, otherwise {unique solution, lcm(mods...)}",
            "\t// O(n)",
            "\ttemplate<class U>",
            "\tarray<T, 2> run(const vector<U> &rem){",
            "\t\tT r0 = 0, m0 = 1;",
            "\t\tfor(auto i = 0; i < (int)mod.size(); ++ i){",
            "\t\t\tT r1 = rem[i], m1 = mod[i];",
            "\t\t\tASSERT(0 <= r1 && r1 < m1);",
            "\t\t\tif(m0 < m1) swap(r0, r1), swap(m0, m1);",
            "\t\t\tif(m0 % m1 == 0){",
            "\t\t\t\tif(r0 % m1 != r1) return {0, 0};",
            "\t\t\t\tcontinue;",
            "\t\t\t}",
            "\t\t\tif((r1 - r0) % gcd[i]) return {0, 0};",
            "\t\t\tr0 += (r1 - r0) / gcd[i] % q[i] * coef[i] % q[i] * m0;",
            "\t\t\tm0 *= q[i];",
            "\t\t\tif(r0 < 0) r0 += m0;",
            "\t\t}",
            "\t\treturn {r0, m0};",
            "\t}",
            "\t// Returns {0, 0} if no solution, otherwise {unique solution, lcm(mods...)}",
            "\t// O(n)",
            "\ttemplate<class... U, typename enable_if<(IS_INTEGRAL(U) && ...)>::type* = nullptr>",
            "\tarray<T, 2> run(const U &... rems){",
            "\t\tASSERT(sizeof...(rems) == (int)mod.size());",
            "\t\tT r0 = 0, m0 = 1;",
            "\t\tint i = 0;",
            "\t\tfor(auto r1: {(T)rems...}){",
            "\t\t\tT m1 = mod[i];",
            "\t\t\tASSERT(0 <= r1 && r1 < m1);",
            "\t\t\tif(m0 < m1) swap(r0, r1), swap(m0, m1);",
            "\t\t\tif(m0 % m1 == 0){",
            "\t\t\t\tif(r0 % m1 != r1) return {0, 0};",
            "\t\t\t\t++ i;",
            "\t\t\t\tcontinue;",
            "\t\t\t}",
            "\t\t\tif((r1 - r0) % gcd[i]) return {0, 0};",
            "\t\t\tr0 += (r1 - r0) / gcd[i] % q[i] * coef[i] % q[i] * m0;",
            "\t\t\tm0 *= q[i];",
            "\t\t\tif(r0 < 0) r0 += m0;",
            "\t\t\t++ i;",
            "\t\t}",
            "\t\treturn {r0, m0};",
            "\t}",
            "#undef IS_INTEGRAL",
            "#undef IS_SIGNED",
            "#undef ASSERT",
            "};"
        ],
        "description": "tranxuanbach"
    }
}