{
    "tranxuanbach": {
        "prefix": "heavy_light_decomposition",
        "body": [
            "// Requires graph",
            "struct heavy_light_decomposition{",
            "\tint n;",
            "\tvector<vector<int>> adj; // stores edge ids",
            "\tvector<int> pv;",
            "\tvector<int> pe;",
            "\tvector<int> size;",
            "\tvector<int> root_of;",
            "\tvector<int> root;",
            "\tvector<int> depth;",
            "\tvector<int> next; // highest point of the heavy path",
            "\tvector<int> prev; // lowest point of the heavy path",
            "\tvector<int> pos;",
            "\tvector<int> end;",
            "\tvector<int> order;",
            "\tvector<int> was;",
            "\tvoid init(int n){",
            "\t\tassert(n >= 1);",
            "\t\tthis->n = n;",
            "\t\tadj.assign(n, {});",
            "\t\tpv.assign(n, -1);",
            "\t\tpe.assign(n, -1);",
            "\t\torder.clear();",
            "\t\tpos.assign(n, -1);",
            "\t\tend.assign(n, -1);",
            "\t\tsize.assign(n, 1);",
            "\t\troot_of.assign(n, -1);",
            "\t\troot.clear();",
            "\t\tdepth.assign(n, -1);",
            "\t\tnext.assign(n, -1);",
            "\t\tprev.assign(n, -1);",
            "\t\twas.assign(n, -2);",
            "\t\tattempt = -1;",
            "\t}",
            "\tint attempt;",
            "\ttemplate<class T>",
            "\tvoid build(const graph<T> &g, const vector<int> &src){",
            "\t\tassert(g.n <= n);",
            "\t\t++ attempt;",
            "\t\troot.clear(), order.clear();",
            "\t\tfor(auto id = 0; id < (int)g.edge.size(); ++ id){",
            "\t\t\tif(g.ignore && g.ignore(id)) continue;",
            "\t\t\tauto &e = g.edge[id];",
            "\t\t\tadj[e.from].push_back(id), adj[e.to].push_back(id);",
            "\t\t}",
            "\t\tauto dfs_init = [&](auto self, int u)->void{",
            "\t\t\tassert(was[u] != attempt); // CYCLE FOUND",
            "\t\t\twas[u] = attempt;",
            "\t\t\tprev[u] = u;",
            "\t\t\tsize[u] = 1;",
            "\t\t\tif(root_of[u] != u){",
            "\t\t\t\tadj[u].erase(find(adj[u].begin(), adj[u].end(), pe[u]));",
            "\t\t\t}",
            "\t\t\tfor(auto &id: adj[u]){",
            "\t\t\t\tint v = g(u, id);",
            "\t\t\t\tpv[v] = u;",
            "\t\t\t\tpe[v] = id;",
            "\t\t\t\tdepth[v] = depth[u] + 1;",
            "\t\t\t\troot_of[v] = root_of[u];",
            "\t\t\t\tnext[v] = u;",
            "\t\t\t\tself(self, v);",
            "\t\t\t\tsize[u] += size[v];",
            "\t\t\t\tif(size[v] > size[g(u, adj[u][0])]) swap(id, adj[u][0]);",
            "\t\t\t}",
            "\t\t\tif(!adj[u].empty()) prev[u] = prev[g(u, adj[u][0])];",
            "\t\t};",
            "\t\tauto dfs_hld = [&](auto self, int u)->void{",
            "\t\t\tpos[u] = (int)order.size();",
            "\t\t\torder.push_back(u);",
            "\t\t\tif(!adj[u].empty()){",
            "\t\t\t\tint hv = g(u, adj[u][0]);",
            "\t\t\t\tfor(auto id: adj[u]){",
            "\t\t\t\t\tint v = g(u, id);",
            "\t\t\t\t\tnext[v] = (v == hv ? next[u] : v);",
            "\t\t\t\t\tself(self, v);",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t\tend[u] = (int)order.size();",
            "\t\t};",
            "\t\tfor(auto r: src){",
            "\t\t\tif(was[r] == attempt) continue;",
            "\t\t\tpv[r] = pe[r] = -1;",
            "\t\t\tdepth[r] = 0;",
            "\t\t\troot_of[r] = r;",
            "\t\t\troot.push_back(r);",
            "\t\t\tnext[r] = r;",
            "\t\t\tdfs_init(dfs_init, r);",
            "\t\t\tdfs_hld(dfs_hld, r);",
            "\t\t}",
            "\t}",
            "\t// Check if u is visited during the last build call",
            "\tbool visited(int u) const{",
            "\t\tassert(0 <= u && u < n);",
            "\t\treturn was[u] == attempt;",
            "\t}",
            "\t// O(1)",
            "\tbool ancestor_of(int u, int v) const{",
            "\t\treturn pos[u] <= pos[v] && end[v] <= end[u];",
            "\t}",
            "\tint lca(int u, int v) const{",
            "\t\tfor(; next[u] != next[v]; v = pv[next[v]]) if(depth[next[u]] > depth[next[v]]) swap(u, v);",
            "\t\treturn depth[u] < depth[v] ? u : v;",
            "\t}",
            "\tint steps(int u, int v, int w = -1) const{",
            "\t\treturn depth[u] + depth[v] - 2 * depth[~w ? w : lca(u, v)];",
            "\t}",
            "\t// f reads the position in the data structure",
            "\t// One application of f",
            "\tvoid access_node(int u, auto f) const{",
            "\t\tf(pos[u]);",
            "\t}",
            "\t// One application of f",
            "\ttemplate<int VALS_IN_EDGES = 0>",
            "\tvoid access_subtree(int u, auto f) const{",
            "\t\tf(pos[u] + VALS_IN_EDGES, end[u]);",
            "\t}",
            "\t// f(left, right, (left->right ?))",
            "\t// O(log(n)) applications of f",
            "\ttemplate<int VALS_IN_EDGES = 0>",
            "\tvoid access_path(int u, int v, auto f) const{",
            "\t\tbool dir = true;",
            "\t\tfor(; next[u] != next[v]; v = pv[next[v]]){",
            "\t\t\tif(depth[next[u]] > depth[next[v]]) swap(u, v), dir = !dir;",
            "\t\t\tf(pos[next[v]], pos[v] + 1, dir);",
            "\t\t}",
            "\t\tif(depth[u] > depth[v]) swap(u, v), dir = !dir;",
            "\t\tf(pos[u] + VALS_IN_EDGES, pos[v] + 1, dir);",
            "\t}",
            "\t// Pair of indices {l, r} in the data structure. resr is reversed(v->next[v], pv[next[v]]-> ...)",
            "\t// O(log(n))",
            "\tauto get_path(int u, int v) const{",
            "\t\tvector<pair<int, int>> resl, resr;",
            "\t\taccess_path(u, v, [&](int l, int r, bool dir){ (dir ? resl : resr).push_back({l, r}); });",
            "\t\treturn pair{resl, resr};",
            "\t}",
            "};"
        ],
        "description": "tranxuanbach"
    }
}