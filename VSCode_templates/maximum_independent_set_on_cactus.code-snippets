{
    "tranxuanbach": {
        "prefix": "maximum_independent_set_on_cactus",
        "body": [
            "// g must be an edge cactus",
            "// O(|V| + |E|)",
            "// Requires graph",
            "template<class T, class U>",
            "vector<int> maximum_independent_set_on_cactus(const graph<T> &g, const vector<U> &weight){",
            "\tassert((int)weight.size() == g.n);",
            "\tint n = g.n;",
            "\tvector<int> order, roots, pos(n, -1), depth(n), pv(n, -1), pe(n, -1);",
            "\tvector<array<int, 2>> min_depth(n);",
            "\tauto dfs = [&](auto self, int u, int p)->void{",
            "\t\tpos[u] = (int)order.size();",
            "\t\torder.push_back(u);",
            "\t\tmin_depth[u] = {depth[u], u};",
            "\t\tfor(auto id: g.adj[u]){",
            "\t\t\tif(id == p || g.ignore && g.ignore(id)) continue;",
            "\t\t\tint v = g(u, id);",
            "\t\t\tif(!~pos[v]){",
            "\t\t\t\tpv[v] = u;",
            "\t\t\t\tpe[v] = id;",
            "\t\t\t\tdepth[v] = depth[u] + 1;",
            "\t\t\t\tself(self, v, id);",
            "\t\t\t\tmin_depth[u] = min(min_depth[u], min_depth[v]);",
            "\t\t\t}",
            "\t\t\telse if(depth[v] < depth[u]) min_depth[u] = min(min_depth[u], array{depth[v], u});",
            "\t\t}",
            "\t};",
            "\tfor(auto u = 0; u < n; ++ u) if(!~pos[u]) roots.push_back(u), dfs(dfs, u, -1);",
            "\tvector<array<U, 2>> dp(n);",
            "\tfor(auto t = n - 1; t >= 0; -- t){",
            "\t\tint u = order[t];",
            "\t\tdp[u][1] = weight[u];",
            "\t\tfor(auto id: g.adj[u]){",
            "\t\t\tif(id == pe[u] || g.ignore && g.ignore(id)) continue;",
            "\t\t\tint v = g(u, id);",
            "\t\t\tif(pv[v] != u || min_depth[v][0] < depth[u]) continue;",
            "\t\t\tif(min_depth[v][0] > depth[u]) dp[u] = {dp[u][0] + max(dp[v][0], dp[v][1]), dp[u][1] + dp[v][0]};",
            "\t\t\telse{",
            "\t\t\t\tstatic vector<int> cycle;",
            "\t\t\t\tcycle.clear();",
            "\t\t\t\tfor(auto w = min_depth[v][1]; w != u; w = pv[w]) cycle.push_back(w);",
            "\t\t\t\tarray<U, 4> dp_cycle{dp[cycle[0]][0], numeric_limits<U>::min() / 2, numeric_limits<U>::min() / 2, dp[cycle[0]][1]};",
            "\t\t\t\tfor(auto t = 1; t < (int)cycle.size(); ++ t){",
            "\t\t\t\t\tint v = cycle[t];",
            "\t\t\t\t\tdp_cycle = {",
            "\t\t\t\t\t\tdp[v][0] + max(dp_cycle[0], dp_cycle[1]),",
            "\t\t\t\t\t\tdp[v][1] + dp_cycle[0],",
            "\t\t\t\t\t\tdp[v][0] + max(dp_cycle[2], dp_cycle[3]),",
            "\t\t\t\t\t\tdp[v][1] + dp_cycle[2]",
            "\t\t\t\t\t};",
            "\t\t\t\t}",
            "\t\t\t\tdp[u] = {dp[u][0] + *max_element(dp_cycle.begin(), dp_cycle.end()), dp[u][1] + dp_cycle[0]};",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "\tvector<int> state(n, -1);",
            "\tfor(auto u: roots) state[u] = dp[u][0] < dp[u][1];",
            "\tfor(auto u: order){",
            "\t\tfor(auto id: g.adj[u]){",
            "\t\t\tif(id == pe[u] || g.ignore && g.ignore(id)) continue;",
            "\t\t\tint v = g(u, id);",
            "\t\t\tif(pv[v] != u || min_depth[v][0] < depth[u]) continue;",
            "\t\t\tif(min_depth[v][0] > depth[u]) state[v] = state[u] ? 0 : dp[v][0] < dp[v][1];",
            "\t\t\telse{",
            "\t\t\t\tstatic vector<int> cycle;",
            "\t\t\t\tcycle.clear();",
            "\t\t\t\tfor(auto w = min_depth[v][1]; w != u; w = pv[w]) cycle.push_back(w);",
            "\t\t\t\tvector<array<U, 4>> dp_cycle((int)cycle.size());",
            "\t\t\t\tdp_cycle[0] = {dp[cycle[0]][0], numeric_limits<U>::min() / 2, numeric_limits<U>::min() / 2, dp[cycle[0]][1]};",
            "\t\t\t\tfor(auto t = 1; t < (int)cycle.size(); ++ t){",
            "\t\t\t\t\tint v = cycle[t];",
            "\t\t\t\t\tdp_cycle[t] = {",
            "\t\t\t\t\t\tdp[v][0] + max(dp_cycle[t - 1][0], dp_cycle[t - 1][1]),",
            "\t\t\t\t\t\tdp[v][1] + dp_cycle[t - 1][0],",
            "\t\t\t\t\t\tdp[v][0] + max(dp_cycle[t - 1][2], dp_cycle[t - 1][3]),",
            "\t\t\t\t\t\tdp[v][1] + dp_cycle[t - 1][2]",
            "\t\t\t\t\t};",
            "\t\t\t\t}",
            "\t\t\t\tint fstate, bstate;",
            "\t\t\t\tif(state[u]) fstate = bstate = 0;",
            "\t\t\t\telse if(max(dp_cycle.back()[0], dp_cycle.back()[1]) >= max(dp_cycle.back()[2], dp_cycle.back()[3])) fstate = 0, bstate = dp_cycle.back()[0] < dp_cycle.back()[1];",
            "\t\t\t\telse fstate = 1, bstate = dp_cycle.back()[2] < dp_cycle.back()[3];",
            "\t\t\t\tstate[cycle.back()] = bstate;",
            "\t\t\t\tfor(auto t = (int)cycle.size() - 2; t >= 0; -- t){",
            "\t\t\t\t\tint v = cycle[t], nv = cycle[t + 1];",
            "\t\t\t\t\tstate[v] = state[nv] ? 0 : dp_cycle[t][fstate << 1] < dp_cycle[t][fstate << 1 | 1];",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "\tvector<int> res;",
            "\tfor(auto u = 0; u < n; ++ u) if(state[u]) res.push_back(u);",
            "\treturn res;",
            "};"
        ],
        "description": "tranxuanbach"
    }
}