{
    "tranxuanbach": {
        "prefix": "partitions",
        "body": [
            "// Enumerate all partitions of 0 to n in lexicographical order.",
            "vector<vector<vector<int>>> enumerate_partitions(int n){",
            "\tassert(0 <= n);",
            "\tvector<vector<vector<int>>> p(n + 1);",
            "\tp[0] = {{}};",
            "\tfor(auto x = 1; x <= n; ++ x) for(auto last = x; last >= 1; -- last) for(auto q: p[x - last]){",
            "\t\tif(!q.empty() && q.back() < last) break;",
            "\t\tq.push_back(last);",
            "\t\tp[x].push_back(q);",
            "\t}",
            "\tfor(auto x = 1; x <= n; ++ x){",
            "\t\treverse(p[x].begin(), p[x].end());",
            "\t\tfor(auto &q: p[x]) reverse(q.begin(), q.end());",
            "\t}",
            "\treturn p;",
            "}",
            "// Enumerate all partitions of 0 to n in lexicographical order, along with its occurence as set of sizes of cycles in S_n.",
            "template<class T, bool PRECOMPUTE_INVERSE = false>",
            "vector<vector<pair<vector<int>, T>>> enumerate_partitions_with_count(int n){",
            "\tauto p = enumerate_partitions(n);",
            "\tvector<T> fact(n + 1, 1), invfact, inv;",
            "\tfor(auto x = 1; x <= n; ++ x) fact[x] = fact[x - 1] * x;",
            "\tif constexpr(PRECOMPUTE_INVERSE){",
            "\t\tinvfact.resize(n + 1), inv.resize(n + 1, 1);",
            "\t\tinvfact[n] = 1 / fact[n];",
            "\t\tfor(auto x = n - 1; x >= 1; -- x){",
            "\t\t\tinvfact[x] = invfact[x + 1] * (x + 1);",
            "\t\t\tinv[x + 1] = invfact[x + 1] * fact[x];",
            "\t\t}",
            "\t}",
            "\tvector<vector<pair<vector<int>, T>>> res(n + 1);",
            "\tfor(auto x = 0; x <= n; ++ x){",
            "\t\tfor(auto q: p[x]){",
            "\t\t\tT cnt = fact[x];",
            "\t\t\tfor(auto y: q){",
            "\t\t\t\tif constexpr(PRECOMPUTE_INVERSE) cnt *= inv[y];",
            "\t\t\t\telse cnt /= y;",
            "\t\t\t}",
            "\t\t\tfor(auto l = 0; l < (int)q.size(); ){",
            "\t\t\t\tint r = l;",
            "\t\t\t\twhile(r < (int)q.size() && q[l] == q[r]) ++ r;",
            "\t\t\t\tif constexpr(PRECOMPUTE_INVERSE) cnt *= invfact[r - l];",
            "\t\t\t\telse cnt /= fact[r - l];",
            "\t\t\t\tl = r;",
            "\t\t\t}",
            "\t\t\tres[x].push_back({q, cnt});",
            "\t\t}",
            "\t}",
            "\treturn res;",
            "}"
        ],
        "description": "tranxuanbach"
    }
}