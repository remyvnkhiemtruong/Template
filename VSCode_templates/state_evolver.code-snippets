{
    "tranxuanbach": {
        "prefix": "state_evolver",
        "body": [
            "template<class T>",
            "struct state_evolver{",
            "\tmap<T, int> dist;",
            "\tmap<T, T> prev;",
            "\tvector<T> init_states;",
            "\toptional<T> ending_state_ptr;",
            "\tvector<T> _q;",
            "\tvoid evolve(const vector<T> &init_states, auto adjacent_states, auto is_ending_state){",
            "\t\tdist.clear();",
            "\t\tprev.clear();",
            "\t\tthis->init_states = init_states;",
            "\t\tending_state_ptr = {};",
            "\t\t_q.clear();",
            "\t\tfor(auto s: init_states){",
            "\t\t\tdist[s] = 0;",
            "\t\t\tif(is_ending_state(s)){",
            "\t\t\t\tending_state_ptr = s;",
            "\t\t\t\treturn;",
            "\t\t\t}",
            "\t\t\t_q.push_back(s);",
            "\t\t}",
            "\t\tfor(auto qbeg = 0; qbeg < (int)_q.size(); ++ qbeg){",
            "\t\t\tauto s = _q[qbeg];",
            "\t\t\tint d = dist[s];",
            "\t\t\tfor(auto t: adjacent_states(s)){",
            "\t\t\t\tif(dist.contains(t)) continue;",
            "\t\t\t\tdist[t] = d + 1;",
            "\t\t\t\tprev[t] = s;",
            "\t\t\t\tif(is_ending_state(t)){",
            "\t\t\t\t\tending_state_ptr = t;",
            "\t\t\t\t\treturn;",
            "\t\t\t\t}",
            "\t\t\t\t_q.push_back(t);",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "\tvoid evolve(const vector<T> &init_states, auto adjacent_states){",
            "\t\tevolve(init_states, adjacent_states, [&](auto){ return false; });",
            "\t}",
            "\tbool path_found() const{",
            "\t\treturn (bool)ending_state_ptr;",
            "\t}",
            "\t// list of {state, prev_state}",
            "\tvector<vector<array<T, 2>>> get_all_states(){",
            "\t\tvector<vector<array<T, 2>>> all_states;",
            "\t\tfor(auto [s, d]: dist){",
            "\t\t\tif(d == 0) continue;",
            "\t\t\tassert(prev.contains(s));",
            "\t\t\tif((int)all_states.size() < d) all_states.resize(d);",
            "\t\t\tall_states[d - 1].push_back({s, prev[s]});",
            "\t\t}",
            "\t\treturn {init_states, all_states};",
            "\t}",
            "\tvector<T> get_path(){",
            "\t\tassert(path_found());",
            "\t\tvector<T> path;",
            "\t\tfor(auto s = *ending_state_ptr; ; ){",
            "\t\t\tpath.push_back(s);",
            "\t\t\tif(!prev.contains(s)) break;",
            "\t\t\ts = prev[s];",
            "\t\t}",
            "\t\treverse(path.begin(), path.end());",
            "\t\treturn path;",
            "\t}",
            "};"
        ],
        "description": "tranxuanbach"
    }
}