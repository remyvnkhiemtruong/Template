{
    "tranxuanbach": {
        "prefix": "enumerate_maximal_cliques",
        "body": [
            "// Bron-Kerbosch algorithm for enumerating all maximum cliques.",
            "// Reads adjacency matrix represented with bitmask",
            "// n must be equal or less than 64 (works under 100ms).",
            "// O(3^(n/3))",
            "void enumerate_maximal_cliques(const vector<unsigned long long> &input_adjm, auto process_while){",
            "\tint n = (int)input_adjm.size();",
            "\tassert(n <= 64);",
            "\tif(n == 0) return;",
            "\tvector<int> deg(n), order(n), pos(n);",
            "\tfor(auto u = 0; u < n; ++ u) deg[u] = __builtin_popcountll(input_adjm[u]);",
            "\tiota(order.begin(), order.end(), 0);",
            "\tsort(order.begin(), order.end(), [&](int u, int v){ return deg[u] < deg[v]; });",
            "\tfor(auto t = 0; t < n; ++ t) pos[order[t]] = t;",
            "\tusing ull = unsigned long long;",
            "\tvector<ull> adjm(n);",
            "\tfor(auto u = 0; u < n; ++ u) for(auto v = u + 1; v < n; ++ v) if(input_adjm[u] & 1ull << v) adjm[pos[u]] ^= 1ull << pos[v], adjm[pos[v]] ^= 1ull << pos[u];",
            "\tauto dfs = [&](auto self, ull r, ull p)->bool{",
            "\t\tif(p == 0) return process_while(r);",
            "\t\tint u = __builtin_ctzll(p);",
            "\t\tull c = p & ~adjm[u];",
            "\t\twhile(c){",
            "\t\t\tu = __builtin_ctzll(c);",
            "\t\t\tull umask = 1ull << u;",
            "\t\t\tr |= umask;",
            "\t\t\tif(!self(self, r, p & adjm[u])) return false;",
            "\t\t\tr &= ~umask;",
            "\t\t\tp &= ~umask;",
            "\t\t\tc ^= umask;",
            "\t\t}",
            "\t\treturn true;",
            "\t};",
            "\tdfs(dfs, 0, (1ull << n) - 1);",
            "}"
        ],
        "description": "tranxuanbach"
    }
}