{
    "tranxuanbach": {
        "prefix": "point3",
        "body": [
            "template<class T>",
            "struct point3{",
            "\tT x{}, y{}, z{};",
            "\tpoint3(){ }",
            "\ttemplate<class U> point3(const point3<U> &otr): x(otr.x), y(otr.y), z(otr.z){ }",
            "\ttemplate<class U, class V, class W> point3(U x, V y, W z): x(x), y(y), z(z){ }",
            "\ttemplate<class U> point3(const array<U, 3> &p): x(p[0]), y(p[1]), z(p[2]){ }",
            "\tfriend istream &operator>>(istream &in, point3 &p){",
            "\t\treturn in >> p.x >> p.y >> p.z;",
            "\t}",
            "\tfriend ostream &operator<<(ostream &out, const point3 &p){",
            "\t\treturn out << \"{\" << p.x << \", \" << p.y << \", \" << p.z << \"}\";",
            "\t}",
            "\ttemplate<class U> operator array<U, 3>() const{",
            "\t\treturn {x, y, z};",
            "\t}",
            "\tT operator*(const point3 &otr) const{",
            "\t\treturn x * otr.x + y * otr.y + z * otr.z;",
            "\t}",
            "\tpoint3 operator^(const point3 &otr) const{",
            "\t\treturn {y * otr.z - z * otr.y, z * otr.x - x * otr.z, x * otr.y - y * otr.x};",
            "\t}",
            "\tpoint3 operator+(const point3 &otr) const{",
            "\t\treturn {x + otr.x, y + otr.y, z + otr.z};",
            "\t}",
            "\tpoint3 &operator+=(const point3 &otr){",
            "\t\treturn *this = *this + otr;",
            "\t}",
            "\tpoint3 operator-(const point3 &otr) const{",
            "\t\treturn {x - otr.x, y - otr.y, z - otr.z};",
            "\t}",
            "\tpoint3 &operator-=(const point3 &otr){",
            "\t\treturn *this = *this - otr;",
            "\t}",
            "\tpoint3 operator-() const{",
            "\t\treturn {-x, -y, -z};",
            "\t}",
            "#define scalarop_l(op) friend point3 operator op(const T &c, const point3 &p){ return {c op p.x, c op p.y, c op p.z}; }",
            "\tscalarop_l(+) scalarop_l(-) scalarop_l(*) scalarop_l(/)",
            "#define scalarop_r(op) point3 operator op(const T &c) const{ return {x op c, y op c, z op c}; }",
            "\tscalarop_r(+) scalarop_r(-) scalarop_r(*) scalarop_r(/)",
            "#define scalarapply(applyop, op) point3 &operator applyop(const T &c){ return *this = *this op c; }",
            "\tscalarapply(+=, +) scalarapply(-=, -) scalarapply(*=, *) scalarapply(/=, /)",
            "#define compareop(op) bool operator op(const point3 &otr) const{ return tuple(x, y, z) op tuple(otr.x, otr.y, otr.z); }",
            "\tcompareop(>) compareop(<) compareop(>=) compareop(<=) compareop(==) compareop(!=)",
            "#undef scalarop_l",
            "#undef scalarop_r",
            "#undef scalarapply",
            "#undef compareop",
            "\tdouble norm() const{",
            "\t\treturn sqrt(x * x + y * y + z * z);",
            "\t}",
            "\tdouble norm_l() const{",
            "\t\treturn sqrtl(x * x + y * y + z * z);",
            "\t}",
            "\tT squared_norm() const{",
            "\t\treturn x * x + y * y + z * z;",
            "\t}",
            "\tpoint3<double> unit() const{",
            "\t\treturn point3<double>(x, y, z) / norm();",
            "\t}",
            "\tpoint3<long double> unit_l() const{",
            "\t\treturn point3<long double>(x, y, z) / norm_l();",
            "\t}",
            "\tpoint3 reflect_x() const{",
            "\t\treturn {x, -y, -z};",
            "\t}",
            "\tpoint3 reflect_y() const{",
            "\t\treturn {-x, y, -z};",
            "\t}",
            "\tpoint3 reflect_z() const{",
            "\t\treturn {-x, -y, z};",
            "\t}",
            "\tpoint3 reflect_xy() const{",
            "\t\treturn {x, y, -z};",
            "\t}",
            "\tpoint3 reflect_yz() const{",
            "\t\treturn {-x, y, z};",
            "\t}",
            "\tpoint3 reflect_zx() const{",
            "\t\treturn {x, -y, z};",
            "\t}",
            "\tpoint3 reflect(const point3 &o = {}) const{",
            "\t\treturn {2 * o.x - x, 2 * o.y - y, 2 * o.z - z};",
            "\t}",
            "\tbool parallel_to(const point3 &q) const{",
            "\t\tif constexpr(is_floating_point_v<T>) return (*this ^ q).norm() <= 1e-9;",
            "\t\telse return (*this ^ q).norm() == 0;",
            "\t}",
            "};",
            "template<class T, class U>",
            "point3<double> lerp(const point3<T> &p, const point3<U> &q, double t){",
            "\treturn point3<double>(p) * (1 - t) + point3<double>(q) * t;",
            "}",
            "template<class T, class U>",
            "point3<long double> lerp_l(const point3<T> &p, const point3<U> &q, long double t){",
            "\treturn point3<long double>(p) * (1 - t) + point3<long double>(q) * t;",
            "}",
            "template<class T>",
            "double distance(const point3<T> &p, const point3<T> &q){",
            "\treturn (p - q).norm();",
            "}",
            "template<class T>",
            "long double distance_l(const point3<T> &p, const point3<T> &q){",
            "\treturn (p - q).norm_l();",
            "}",
            "template<class T>",
            "T squared_distance(const point3<T> &p, const point3<T> &q){",
            "\treturn (p - q).squared_norm();",
            "}",
            "template<class T>",
            "T quadruple_of_squared_area(const point3<T> &p, const point3<T> &q, const point3<T> &r){",
            "\treturn (q - p ^ r - p).squared_norm();",
            "}",
            "template<class T>",
            "T sextupled_volume(const point3<T> &p, const point3<T> &q, const point3<T> &r, const point3<T> &s){",
            "\treturn (q - p) * (r - p ^ s - p);",
            "}",
            "template<class T>",
            "double angle(const point3<T> &p, const point3<T> &q){",
            "\tauto a = atan2((p ^ q).norm(), p * q);",
            "\tif(a < 0) a += 2 * acos(-1);",
            "\treturn a;",
            "}",
            "template<class T>",
            "long double angle_l(const point3<T> &p, const point3<T> &q){",
            "\tauto a = atan2l((p ^ q).norml(), p * q);",
            "\tif(a < 0) a += 2 * acosl(-1);",
            "\treturn a;",
            "}",
            "template<class T>",
            "bool positively_oriented(const point3<T> &p, const point3<T> &q, const point3<T> &r, const point3<T> &s){",
            "\treturn sextupled_volume(p, q, r, s) > 0;",
            "}",
            "template<class T>",
            "bool negatively_oriented(const point3<T> &p, const point3<T> &q, const point3<T> &r, const point3<T> &s){",
            "\treturn sextupled_volume(p, q, r, s) < 0;",
            "}",
            "template<class T>",
            "bool colinear(const point3<T> &p, const point3<T> &q, const point3<T> &r){",
            "\treturn (q - p ^ r - p) == point3<T>{};",
            "}",
            "template<class T>",
            "bool colinear(const point3<T> &a){",
            "\tint i = 1;",
            "\twhile(i < (int)a.size() && a[0] == a[i]) ++ i;",
            "\tif(i == (int)a.size()) return true;",
            "\tfor(auto j = i + 1; j < (int)a.size(); ++ j) if(!colinear(a[0], a[i], a[j])) return false;",
            "\treturn true;",
            "}",
            "template<class T>",
            "bool coplanar(const point3<T> &p, const point3<T> &q, const point3<T> &r, const point3<T> &s){",
            "\treturn sextupled_volume(p, q, r, s) == 0;",
            "}",
            "template<class T>",
            "bool coplanar(const vector<point3<T>> &a){",
            "\tint i = 1;",
            "\twhile(i < (int)a.size() && a[0] == a[i]) ++ i;",
            "\tif(i == (int)a.size()) return true;",
            "\tint j = i + 1;",
            "\twhile(j < (int)a.size() && colinear(a[0], a[i], a[j])) ++ j;",
            "\tif(j == (int)a.size()) return true;",
            "\tfor(auto k = j + 1; k < (int)a.size(); ++ k) if(!coplanar(a[0], a[i], a[j], a[k])) return false;",
            "\treturn true;",
            "}",
            "",
            "using point3int = point3<int>;",
            "using point3ll = point3<long long>;",
            "using point3lll = point3<__int128_t>;",
            "using point3d = point3<double>;",
            "using point3ld = point3<long double>;"
        ],
        "description": "tranxuanbach"
    }
}