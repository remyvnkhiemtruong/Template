{
    "tranxuanbach": {
        "prefix": "minimum_cost_matroid_intersection_spfa",
        "body": [
            "// Requires matroid",
            "template<class T>",
            "struct minimum_cost_matroid_intersection_spfa{",
            "\tint n;",
            "\tvector<int> state;",
            "\tminimum_cost_matroid_intersection_spfa(int n): n(n), state(n), dist(n + 1), adj(n + 1), pv(n + 1), in_q(n + 1){ }",
            "\tvector<pair<T, int>> dist;",
            "\tvector<vector<pair<int, T>>> adj;",
            "\tvector<int> pv, q, in_q;",
            "\ttemplate<class M1, class M2>",
            "\tbool augment(const vector<T> &cost, M1 &m1, M2 &m2){",
            "\t\tfill(dist.begin(), dist.end(), pair<T, int>{numeric_limits<T>::max() / 2, 0});",
            "\t\tfor(auto &s: adj) s.clear();",
            "\t\tfill(pv.begin(), pv.end(), -1);",
            "\t\tint beg = 0;",
            "\t\tq.clear();",
            "\t\tfill(in_q.begin(), in_q.end(), false);",
            "\t\tm1.clear();",
            "\t\tm2.clear();",
            "\t\tfor(auto u = 0; u < n; ++ u) if(state[u]){",
            "\t\t\tm1.insert(u);",
            "\t\t\tm2.insert(u);",
            "\t\t}",
            "\t\tfor(auto u = 0; u < n; ++ u) if(!state[u]){",
            "\t\t\tif(m1.check(u)){",
            "\t\t\t\tdist[pv[u] = u] = {cost[u], 0};",
            "\t\t\t\tq.push_back(u);",
            "\t\t\t\tin_q[u] = true;",
            "\t\t\t}",
            "\t\t\tif(m2.check(u)) adj[u].push_back({n, 0});",
            "\t\t}",
            "\t\tfor(auto u = 0; u < n; ++ u) if(state[u]){",
            "\t\t\tm1.clear();",
            "\t\t\tm2.clear();",
            "\t\t\tfor(auto v = 0; v < n; ++ v) if(u != v && state[v]){",
            "\t\t\t\tm1.insert(v);",
            "\t\t\t\tm2.insert(v);",
            "\t\t\t}",
            "\t\t\tfor(auto v = 0; v < n; ++ v) if(!state[v]){",
            "\t\t\t\tif(m1.check(v)) adj[u].push_back({v, cost[v]});",
            "\t\t\t\tif(m2.check(v)) adj[v].push_back({u, -cost[u]});;",
            "\t\t\t}",
            "\t\t}",
            "\t\twhile(beg < (int)q.size()){",
            "\t\t\tint u = q[beg ++];",
            "\t\t\tin_q[u] = false;",
            "\t\t\tfor(auto [v, w]: adj[u]){",
            "\t\t\t\tpair<T, int> dist_next{dist[u].first + w, dist[u].second + 1};",
            "\t\t\t\tif(dist_next < dist[v]){",
            "\t\t\t\t\tdist[v] = dist_next;",
            "\t\t\t\t\tpv[v] = u;",
            "\t\t\t\t\tif(!in_q[v]){",
            "\t\t\t\t\t\tq.push_back(v);",
            "\t\t\t\t\t\tin_q[v] = true;",
            "\t\t\t\t\t}",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t}",
            "\t\tif(!~pv[n]) return false;",
            "\t\tfor(auto u = pv[n]; ; u = pv[u]){",
            "\t\t\tstate[u] ^= 1;",
            "\t\t\tif(pv[u] == u) break;",
            "\t\t}",
            "\t\treturn true;",
            "\t}",
            "\t/*",
            "\t---------------------------------------------",
            "\t| # of member function calls where          |",
            "\t| r is the size of the answer and           |",
            "\t| N is the size of the ground set           |",
            "\t---------------------------------------------",
            "\t| Member Function | M1         | M2         |",
            "\t---------------------------------------------",
            "\t| insert()        | O(r^3)     | O(r^2 * n) |",
            "\t| check()         | O(r^2 * n) | O(r^2 * n) |",
            "\t| clear()         | O(r^2)     | O(r * n)   |",
            "\t---------------------------------------------",
            "\t*/",
            "\ttemplate<class M1, class M2>",
            "\tvector<int> minimum_cost_maximum_common_independent_set(const vector<T> &cost, M1 m1, M2 m2){",
            "\t\tfill(state.begin(), state.end(), false);",
            "\t\twhile(augment<M1, M2>(cost, m1, m2));",
            "\t\tvector<int> res;",
            "\t\tfor(auto u = 0; u < n; ++ u) if(state[u]) res.push_back(u);",
            "\t\treturn res;",
            "\t}",
            "};"
        ],
        "description": "tranxuanbach"
    }
}