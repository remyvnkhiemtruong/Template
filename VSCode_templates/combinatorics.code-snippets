{
    "tranxuanbach": {
        "prefix": "combinatorics",
        "body": [
            "template<class T>",
            "struct combinatorics{",
            "#ifdef LOCAL",
            "\t#define ASSERT(c) assert(c)",
            "#else",
            "\t#define ASSERT(c) 42",
            "#endif",
            "\t// O(n)",
            "\tstatic vector<T> precalc_fact(int n){",
            "\t\tvector<T> f(n + 1, 1);",
            "\t\tfor(auto i = 1; i <= n; ++ i) f[i] = f[i - 1] * i;",
            "\t\treturn f;",
            "\t}",
            "\t// O(n * m)",
            "\tstatic vector<vector<T>> precalc_C(int n, int m){",
            "\t\tvector<vector<T>> c(n + 1, vector<T>(m + 1));",
            "\t\tfor(auto i = 0; i <= n; ++ i) for(auto j = 0; j <= min(i, m); ++ j) c[i][j] = i && j ? c[i - 1][j - 1] + c[i - 1][j] : T(1);",
            "\t\treturn c;",
            "\t}",
            "\tint SZ = 0;",
            "\tvector<T> inv, fact, invfact;",
            "\tcombinatorics(){ }",
            "\t// O(SZ)",
            "\tcombinatorics(int SZ): SZ(SZ), inv(SZ + 1, 1), fact(SZ + 1, 1), invfact(SZ + 1, 1){",
            "\t\tfor(auto i = 1; i <= SZ; ++ i) fact[i] = fact[i - 1] * i;",
            "\t\tinvfact[SZ] = 1 / fact[SZ];",
            "\t\tfor(auto i = SZ - 1; i >= 0; -- i){",
            "\t\t\tinvfact[i] = invfact[i + 1] * (i + 1);",
            "\t\t\tinv[i + 1] = invfact[i + 1] * fact[i];",
            "\t\t}",
            "\t}",
            "\t// O(1)",
            "\tT C(int n, int k) const{",
            "\t\tASSERT(0 <= min(n, k) && max(n, k) <= SZ);",
            "\t\treturn n >= k ? fact[n] * invfact[k] * invfact[n - k] : T{0};",
            "\t}",
            "\t// O(1)",
            "\tT P(int n, int k) const{",
            "\t\tASSERT(0 <= min(n, k) && max(n, k) <= SZ);",
            "\t\treturn n >= k ? fact[n] * invfact[n - k] : T{0};",
            "\t}",
            "\t// O(1)",
            "\tT H(int n, int k) const{",
            "\t\tASSERT(0 <= min(n, k));",
            "\t\tif(n == 0) return 0;",
            "\t\treturn C(n + k - 1, k);",
            "\t}",
            "\t// Multinomial Coefficient",
            "\tT mC(int n, const vector<int> &a) const{",
            "\t\tASSERT((int)a.size() >= 2 && accumulate(a.begin(), a.end(), 0) == n);",
            "\t\tASSERT(0 <= min(n, *min_element(a.begin(), a.end())) && max(n, *max_element(a.begin(), a.end())) <= SZ);",
            "\t\tT res = fact[n];",
            "\t\tfor(auto x: a) res *= invfact[x];",
            "\t\treturn res;",
            "\t}",
            "\t// Multinomial Coefficient",
            "\ttemplate<class... U, typename enable_if<(is_integral_v<U> && ...)>::type* = nullptr>",
            "\tT mC(int n, U... pack){",
            "\t\tASSERT(sizeof...(pack) >= 2 && (... + pack) == n);",
            "\t\treturn (fact[n] * ... * invfact[pack]);",
            "\t}",
            "\t// O(min(k, n - k))",
            "\tT naive_C(long long n, long long k) const{",
            "\t\tASSERT(0 <= min(n, k));",
            "\t\tif(n < k) return 0;",
            "\t\tT res = 1;",
            "\t\tk = min(k, n - k);",
            "\t\tASSERT(k <= SZ);",
            "\t\tfor(auto i = n; i > n - k; -- i) res *= i;",
            "\t\treturn res * invfact[k];",
            "\t}",
            "\t// O(k)",
            "\tT naive_P(long long n, int k) const{",
            "\t\tASSERT(0 <= min<long long>(n, k));",
            "\t\tif(n < k) return 0;",
            "\t\tT res = 1;",
            "\t\tfor(auto i = n; i > n - k; -- i) res *= i;",
            "\t\treturn res;",
            "\t}",
            "\t// O(k)",
            "\tT naive_H(long long n, int k) const{",
            "\t\tASSERT(0 <= min<long long>(n, k));",
            "\t\treturn naive_C(n + k - 1, k);",
            "\t}",
            "\t// O(1)",
            "\tbool parity_C(long long n, long long k) const{",
            "\t\tASSERT(0 <= min(n, k));",
            "\t\treturn n >= k ? (n & k) == k : false;",
            "\t}",
            "\t// Number of ways to place n '('s and k ')'s starting with m copies of '(' such that in each prefix, number of '(' is equal or greater than ')'",
            "\t// Catalan(n, n, 0): n-th catalan number",
            "\t// Catalan(s, s+k-1, k-1): sum of products of k catalan numbers where the index of product sums up to s.",
            "\t// O(1)",
            "\tT Catalan(int n, int k, int m = 0) const{",
            "\t\tASSERT(0 <= min({n, k, m}));",
            "\t\treturn k <= m ? C(n + k, n) : k <= n + m ? C(n + k, n) - C(n + k, k - m - 1) : T();",
            "\t}",
            "#undef ASSERT",
            "};"
        ],
        "description": "tranxuanbach"
    }
}