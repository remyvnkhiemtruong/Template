{
    "tranxuanbach": {
        "prefix": "maximum_density_subset",
        "body": [
            "// Implementation of https://www2.eecs.berkeley.edu/Pubs/TechRpts/1984/CSD-84-171.pdf",
            "// Density of a graph is sum of edge weights plus vertex weights, divided by the number of vertices. Returns a subgraph with the maximum density",
            "// U must be able to hold 4 * |V|^2 * (sum(edge weight) + max(vertex weight))",
            "// O(log(|V|)) computations of min cut on a graph with |V| vertices and |V| + |E| edges",
            "// Requires flow_network, dinic, and graph",
            "template<class T, class U>",
            "vector<int> maximum_density_subset(const graph<T> &g, vector<U> vertex_weight = {}){",
            "\tfor(auto e: g.edge) assert(e.cost >= 0);",
            "\tint n = g.n;",
            "\tif(n == 1) return {0};",
            "\tconst U scale = (U)2 * n * (n - 1);",
            "\tif(vertex_weight.empty()) vertex_weight.assign(n, 0);",
            "\tfor(auto &x: vertex_weight) x *= scale;",
            "\tU shift = 1 + 2 * max<U>(0, *max_element(vertex_weight.begin(), vertex_weight.end()));",
            "\tvector<U> deg(n);",
            "\tfor(auto id = 0; id < (int)g.edge.size(); ++ id){",
            "\t\tif(g.ignore && g.ignore(id)) continue;",
            "\t\tauto [u, v, w] = g.edge[id];",
            "\t\tw *= scale;",
            "\t\tdeg[u] += w, deg[v] += w, shift += w;",
            "\t}",
            "\tflow_network<U> F(n + 2);",
            "\tdinic_maximum_flow<U> D(F);",
            "\tint source = n, sink = n + 1;",
            "\tvector<int> edge_id(n);",
            "\tfor(auto u = 0; u < n; ++ u){",
            "\t\tF.orient(source, u, shift);",
            "\t\tedge_id[u] = F.orient(u, sink, shift - deg[u] - 2 * vertex_weight[u]);",
            "\t}",
            "\tfor(auto id = 0; id < (int)g.edge.size(); ++ id){",
            "\t\tif(g.ignore && g.ignore(id)) continue;",
            "\t\tauto [u, v, w] = g.edge[id];",
            "\t\tF.link(u, v, w * scale);",
            "\t}",
            "\tU cut_weight;",
            "\tvector<int> left_cut, right_cut;",
            "\tauto notenough = [&](U guess)->bool{",
            "\t\tF.clear_flow();",
            "\t\tfor(auto u = 0; u < n; ++ u){",
            "\t\t\tint id = edge_id[u];",
            "\t\t\tF.edge[id].capacity += 2 * guess;",
            "\t\t}",
            "\t\ttie(cut_weight, left_cut, right_cut) = D.minimum_cut(source, sink);",
            "\t\tfor(auto u = 0; u < n; ++ u){",
            "\t\t\tint id = edge_id[u];",
            "\t\t\tF.edge[id].capacity -= 2 * guess;",
            "\t\t}",
            "\t\treturn (int)left_cut.size() >= 2;",
            "\t};",
            "\tU low = 0, high = shift;",
            "\twhile(high - low >= 2){",
            "\t\tU mid = low + (high - low >> 1);",
            "\t\t(notenough(mid) ? low : high) = mid;",
            "\t}",
            "\tassert(notenough(low));",
            "\tleft_cut.pop_back();",
            "\treturn left_cut;",
            "}"
        ],
        "description": "tranxuanbach"
    }
}