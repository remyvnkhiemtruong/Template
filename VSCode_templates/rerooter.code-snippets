{
    "tranxuanbach": {
        "prefix": "rerooter",
        "body": [
            "// Requires graph",
            "template<class T, class F>",
            "struct rerooter{",
            "\tint n, attempt;",
            "\t// Given a tree T rooted at r, let f(T) be the value at dp[r] after the following process",
            "\t// For each vertex u in reversed dfs order, set dp[u] = T_id",
            "\t// For each child v of u with edge id, set dp[u] = TT(dp[u], apply_edge(id, f[v]))",
            "\t// Finally, set dp[u] = apply_vertex(u, dp[u])",
            "\t// dp_subtr[u] holds f(T) where T is the subtree rooted at u",
            "\t// dp_compl[u] for u != root holds f(T) where T is the complement subtree of the subtree rooted at u, where its root is the parent vertex of u",
            "\tvector<T> dp_subtr;",
            "\tvector<T> dp_compl;",
            "\tvector<T> pref;",
            "\tvector<int> pv;",
            "\tvector<int> pe;",
            "\tvector<int> order;",
            "\tvector<int> size;",
            "\tvector<int> root_of;",
            "\tvector<int> root;",
            "\tvector<int> was;",
            "\tF TT; // commutative monoid operation",
            "\tT T_id; // commutative monoid identity",
            "\trerooter(F TT, T T_id): TT(TT), T_id(T_id){ }",
            "\tvoid init(int n){",
            "\t\tthis->n = n;",
            "\t\tdp_subtr.assign(n, T_id);",
            "\t\tdp_compl.assign(n, T_id);",
            "\t\tpv.assign(n, -1);",
            "\t\tpe.assign(n, -1);",
            "\t\torder.clear();",
            "\t\tsize.assign(n, 0);",
            "\t\troot_of.assign(n, -1);",
            "\t\troot.clear();",
            "\t\twas.assign(n, -2);",
            "\t\tattempt = -1;",
            "\t}",
            "\t// O(n) apply_vertex() and apply_edge() calls where n is the number of nodes in the component of u",
            "\tvoid _dfs(const graph<auto> &g, int u, auto apply_vertex, auto apply_edge){",
            "\t\tpv[u] = pe[u] = -1;",
            "\t\troot_of[u] = u;",
            "\t\troot.push_back(u);",
            "\t\tauto recurse = [&](auto self, int u)->void{",
            "\t\t\twas[u] = attempt;",
            "\t\t\torder.push_back(u);",
            "\t\t\tsize[u] = 1;",
            "\t\t\tdp_subtr[u] = T_id;",
            "\t\t\tfor(auto id: g.adj[u]){",
            "\t\t\t\tif(id == pe[u] || g.ignore && g.ignore(id)) continue;",
            "\t\t\t\tint v = g(u, id);",
            "\t\t\t\tpe[v] = id;",
            "\t\t\t\troot_of[v] = root_of[u];",
            "\t\t\t\tself(self, v);",
            "\t\t\t\tsize[u] += size[v];",
            "\t\t\t\tdp_subtr[u] = TT(dp_subtr[u], apply_edge(id, dp_subtr[v]));",
            "\t\t\t}",
            "\t\t\tdp_subtr[u] = apply_vertex(u, dp_subtr[u]);",
            "\t\t};",
            "\t\trecurse(recurse, u);",
            "\t\tfor(auto u: order){",
            "\t\t\tpref.assign(g.degree(u) + 1, T_id);",
            "\t\t\tfor(auto i = 0; i < g.degree(u); ++ i){",
            "\t\t\t\tint id = g.adj[u][i];",
            "\t\t\t\tif(id == pe[u] || g.ignore && g.ignore(id)){",
            "\t\t\t\t\tpref[i + 1] = pref[i];",
            "\t\t\t\t\tcontinue;",
            "\t\t\t\t}",
            "\t\t\t\tint v = g(u, id);",
            "\t\t\t\tpref[i + 1] = TT(pref[i], apply_edge(id, dp_subtr[v]));",
            "\t\t\t}",
            "\t\t\tT suff = T_id;",
            "\t\t\tfor(auto i = g.degree(u) - 1; i >= 0; -- i){",
            "\t\t\t\tint id = g.adj[u][i];",
            "\t\t\t\tif(id == pe[u] || g.ignore && g.ignore(id)) continue;",
            "\t\t\t\tint v = g(u, id);",
            "\t\t\t\tdp_compl[v] = apply_vertex(u, TT(~pe[u] ? apply_edge(pe[u], dp_compl[u]) : T_id, TT(pref[i], suff)));",
            "\t\t\t\tsuff = TT(suff, apply_edge(id, dp_subtr[v]));",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "\tvoid dfs(const graph<auto> &g, const vector<int> &src, auto apply_vertex, auto apply_edge){",
            "\t\tassert(g.n <= n);",
            "\t\t++ attempt;",
            "\t\tfor(auto u: src){",
            "\t\t\tassert(0 <= u && u < g.n);",
            "\t\t\tif(was[u] != attempt) _dfs(g, u, apply_vertex, apply_edge);",
            "\t\t}",
            "\t}",
            "\tvoid dfs(const graph<auto> &g, const vector<int> &src, auto apply_vertex){",
            "\t\tdfs(g, src, apply_vertex, [&](int id, const T &x){ return x; });",
            "\t}",
            "\t// O(n + m)",
            "\tvoid dfs_all(const graph<auto> &g, auto apply_vertex, auto apply_edge){",
            "\t\tassert(g.n <= n);",
            "\t\t++ attempt;",
            "\t\tfor(auto u = 0; u < g.n; ++ u) if(was[u] != attempt) _dfs(g, u, apply_vertex, apply_edge);",
            "\t}",
            "\t// O(n + m)",
            "\tvoid dfs_all(const graph<auto> &g, auto apply_vertex){",
            "\t\tdfs_all(g, apply_vertex, [&](int id, const T &x){ return x; });",
            "\t}",
            "\t// Check if u is visited during the last dfs-like call.",
            "\tbool visited(int u) const{",
            "\t\tassert(0 <= u && u < n);",
            "\t\treturn was[u] == attempt;",
            "\t}",
            "};"
        ],
        "description": "tranxuanbach"
    }
}