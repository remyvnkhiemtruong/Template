{
    "tranxuanbach": {
        "prefix": "dfs_tree",
        "body": [
            "// Requires graph",
            "template<typename T>",
            "struct dfs_tree{",
            "\tint n;",
            "\tgraph<T> *g;",
            "\tvector<int> pv, pe, order, pos, end, sz, root, depth, min_depth, dist, was;",
            "\tvoid init(graph<T> *h){",
            "\t\tg = h;",
            "\t\tn = g->n;",
            "\t\tpv.assign(n, -1);",
            "\t\tpe.assign(n, -1);",
            "\t\torder.clear();",
            "\t\tpos.assign(n, -1);",
            "\t\tend.assign(n, -1);",
            "\t\tsz.assign(n, 0);",
            "\t\troot.assign(n, -1);",
            "\t\tdepth.assign(n, -1);",
            "\t\tmin_depth.assign(n, -1);",
            "\t\tdist.assign(n, id);",
            "\t\twas.assign(n, -1);",
            "\t\tattempt = 0;",
            "\t}",
            "\tvoid clear(){",
            "\t\tpv.clear();",
            "\t\tpe.clear();",
            "\t\torder.clear();",
            "\t\tpos.clear();",
            "\t\tend.clear();",
            "\t\tsz.clear();",
            "\t\troot.clear();",
            "\t\tdepth.clear();",
            "\t\tmin_depth.clear();",
            "\t\tdist.clear();",
            "\t\twas.clear();",
            "\t}",
            "\tint attempt = 0;",
            "\tvoid dfs(int u, bool clear_order = true){",
            "\t\t++ attempt;",
            "\t\tdepth[u] = 0;",
            "\t\tdist[u] = id;",
            "\t\troot[u] = u;",
            "\t\tpv[u] = pe[u] = -1;",
            "\t\tif(clear_order){",
            "\t\t\torder.clear();",
            "\t\t}",
            "\t\tfunction<void(int)> recurse = [&](int u){",
            "\t\t\twas[u] = attempt;",
            "\t\t\tpos[u] = (int)order.size();",
            "\t\t\torder.push_back(u);",
            "\t\t\tsz[u] = 1;",
            "\t\t\tmin_depth[u] = depth[u];",
            "\t\t\tfor(auto id: g->adj[u]){",
            "\t\t\t\tif(id == pe[u] || g->ignore && g->ignore(id)){",
            "\t\t\t\t\tcontinue;",
            "\t\t\t\t}",
            "\t\t\t\tauto &e = g->edges[id];",
            "\t\t\t\tint v = e.from ^ e.to ^ u;",
            "\t\t\t\tif(was[v] == attempt){",
            "\t\t\t\t\tmin_depth[u] = min(min_depth[u], depth[v]);",
            "\t\t\t\t\tcontinue;",
            "\t\t\t\t}",
            "\t\t\t\tdepth[v] = depth[u] + 1;",
            "\t\t\t\tdist[v] = bin_op(dist[u], e.cost);",
            "\t\t\t\tpv[v] = u;",
            "\t\t\t\tpe[v] = id;",
            "\t\t\t\troot[v] = ~root[u] ? root[u] : v;",
            "\t\t\t\trecurse(v);",
            "\t\t\t\tsz[u] += sz[v];",
            "\t\t\t\tmin_depth[u] = min(min_depth[u], min_depth[v]);",
            "\t\t\t}",
            "\t\t\tend[u] = (int)order.size();",
            "\t\t};",
            "\t\trecurse(u);",
            "\t}",
            "\tvoid dfs_all(){",
            "\t\torder.clear();",
            "\t\tfor(auto u = 0; u < n; ++ u){",
            "\t\t\tif(!~depth[u]){",
            "\t\t\t\tdfs(u, false);",
            "\t\t\t}",
            "\t\t}",
            "\t\tassert((int)order.size() == n);",
            "\t}",
            "\tinline T bin_op(T x, T y){",
            "\t\treturn x + y;",
            "\t}",
            "\tT id = {};",
            "};"
        ],
        "description": "tranxuanbach"
    }
}