{
    "tranxuanbach": {
        "prefix": "polynomial",
        "body": [
            "template<class T> vector<T> normalized(vector<T> p){",
            "\twhile(!p.empty() && p.back() == 0) p.pop_back();",
            "\treturn p;",
            "}",
            "template<class T> vector<T> &operator+=(vector<T> &p, const vector<T> &q){",
            "\tp.resize(max(p.size(), q.size()));",
            "\tfor(int i = 0; i < (int)q.size(); ++ i) p[i] += q[i];",
            "\treturn p;",
            "}",
            "template<class T> vector<T> operator+(vector<T> p, const vector<T> &q){ return p += q; }",
            "template<class T> vector<T> &operator-=(vector<T> &p, const vector<T> &q){",
            "\tp.resize(max(p.size(), q.size()));",
            "\tfor(int i = 0; i < (int)q.size(); ++ i) p[i] -= q[i];",
            "\treturn p;",
            "}",
            "template<class T> vector<T> operator-(vector<T> p, const vector<T> &q){ return p -= q; }",
            "template<class T> vector<T> operator-(const vector<T> &p){",
            "\tvector<T> res = p;",
            "\tfor(int i = 0; i < (int)res.size(); ++ i) res[i] = -res[i];",
            "\treturn res;",
            "}",
            "template<class T> vector<T> operator*(const vector<T> &p, const vector<T> &q){ return convolute(p, q); }",
            "template<class T> vector<T> &operator*=(vector<T> &p, const vector<T> &q){ return p = p * q; }",
            "template<class T, class U>",
            "vector<T> &operator*=(vector<T> &p, U c){",
            "\tfor(auto &x: p) x *= c;",
            "\treturn p;",
            "}",
            "template<class T, class U>",
            "vector<T> operator*(vector<T> p, U c){ return p *= c; }",
            "template<class T, class U>",
            "vector<T> operator*(U c, vector<T> p){",
            "\tfor(auto &x: p) x = c * x;",
            "\treturn p;",
            "}",
            "template<class T>",
            "vector<T> truncated(const vector<T> &p, int n){ return vector<T>(p.begin(), p.begin() + min(n, (int)p.size())); }",
            "template<class T> vector<T> shifted(vector<T> p, int n){ // shift the polynomial to the right by n",
            "\tif(n >= 0) p.insert(p.begin(), n, 0);",
            "\telse p.erase(p.begin(), p.begin() + min(-n, (int)p.size()));",
            "\treturn p;",
            "}",
            "template<class T> vector<T> substr(const vector<T> &p, int l, int r){",
            "\treturn vector<T>(p.begin() + min(l, (int)p.size()), p.begin() + min(r, (int)p.size()));",
            "}",
            "template<class T> vector<T> inverse_series(const vector<T> &p, int n){ // get first n terms of the inverse series of p",
            "\tassert(p[0]);",
            "\tvector<T> res{1 / p[0]};",
            "\tfor(int i = 1; i < n; i <<= 1) res = truncated(res * 2 - res * res * truncated(p, i << 1), i << 1);",
            "\treturn truncated(res, n);",
            "}",
            "template<class T> vector<T> reversed(vector<T> p, int n = numeric_limits<int>::max(), bool rev = false){ // reverses and leaves only n terms",
            "\tif(rev) p.resize(max(n, (int)p.size())); // If rev = true then tail goes to head",
            "\treverse(p.begin(), p.end());",
            "\treturn truncated(p, n);",
            "}",
            "template<class T> pair<vector<T>, vector<T>> divmod_slow(const vector<T> &p, const vector<T> &q){ // when divisor or quotient is small",
            "\tvector<T> Q, R(p);",
            "\tfor(T invx = 1 / q.back(); R.size() >= q.size(); ){",
            "\t\tQ.push_back(R.back() * invx);",
            "\t\tif(Q.back()) for(int i = 0; i < q.size(); ++ i) R[(int)R.size() - i - 1] -= Q.back() * q[(int)q.size() - i - 1];",
            "\t\tR.pop_back();",
            "\t}",
            "\treturn {reversed(Q), R};",
            "}",
            "template<class T> pair<vector<T>, vector<T>> divmod(const vector<T> &p, const vector<T> &q){ // returns quotiend and remainder of a mod b",
            "\tif(p.size() < q.size()) return {{0}, p};",
            "\tint d = (int)p.size() - (int)q.size();",
            "\tif(min(d, (int)q.size() - 1) < 60) return divmod_slow(p, q);",
            "\tvector<T> Q = reversed(truncated((reversed(p, d + 1) * inverse_series(reversed(q, d + 1), d + 1)), d + 1), d + 1, true), R = p - Q * q;",
            "\treturn {Q, p - Q * q};",
            "}",
            "template<class T> vector<T> operator/(const vector<T> &p, const vector<T> &q){ return normalized(divmod(p, q).first); }",
            "template<class T> vector<T> operator%(const vector<T> &p, const vector<T> &q){ return normalized(divmod(p, q).second); }",
            "template<class T> vector<T> &operator/=(vector<T> &p, const vector<T> &q){ return p = p / q; }",
            "template<class T> vector<T> &operator%=(vector<T> &p, const vector<T> &q){ return p = p % q; }",
            "template<class T> vector<T> &operator/=(vector<T> &p, T c){",
            "\tT invc = 1 / c;",
            "\tfor(auto &x: p) x *= invc;",
            "\treturn p;",
            "}",
            "template<class T> vector<T> operator/(vector<T> p, T c){ return p /= c; }",
            "template<class T>",
            "bool is_zero(const vector<T> &p){ return p == vector<T>((int)p.size()); }",
            "template<class T> T evaluate(const vector<T> &p, T x){ // evaluates in single point x",
            "\tT res = 0;",
            "\tfor(int i = (int)p.size() - 1; i >= 0; -- i) res = res * x + p[i];",
            "\treturn res;",
            "}",
            "template<class T> vector<T> derivative(vector<T> p){ // calculate derivative",
            "\tif(p.empty()) return {};",
            "\tfor(int i = 0; i < (int)p.size() - 1; ++ i) p[i] = (i + 1) * p[i + 1];",
            "\tp.pop_back();",
            "\treturn p;",
            "}",
            "template<class T> vector<T> antiderivative(vector<T> p){ // calculate antiderivative with C = 0",
            "\tp.push_back(0);",
            "\tfor(int i = (int)p.size() - 2; i >= 0; -- i) p[i + 1] = p[i] / (i + 1);",
            "\tp[0] = 0;",
            "\treturn p;",
            "}",
            "template<class T> vector<T> log_series(const vector<T> &p, int n){ // calculate first n terms of log p(x)",
            "\treturn assert(p[0] == 1), truncated(antiderivative(truncated(derivative(p), n) * inverse_series(p, n)), n);",
            "}",
            "template<class T> vector<T> exp_series(const vector<T> &p, int n){ // calculate exp p(x) mod x^n",
            "\tif(is_zero(p)) return {1};",
            "\tassert(p[0] == 0);",
            "\tvector<T> res{1};",
            "\tfor(int i = 1; i < n; i <<= 1) res -= shifted(truncated(res * (shifted(log_series(res, i << 1), -i) - substr(p, i, i << 1)), i), i);",
            "\treturn truncated(res, n);",
            "}",
            "template<class T> vector<T> pow_series_slow(const vector<T> &p, int k, int n){ // if k is small",
            "\treturn k ? k & 1 ? truncated(p * pow_series_slow(p, k - 1, n), n) : pow_series_slow(truncated(p * p, n), k >> 1, n) : vector<T>{1};",
            "}",
            "template<class T, class U>",
            "T bpow(T x, U n){",
            "\tT res = 1;",
            "\tfor(; n; x *= x, n >>= 1) if(n & 1) res *= x;",
            "\treturn res;",
            "}",
            "template<class T> vector<T> pow_series(const vector<T> &p, long long k, int n){ // calculate first n terms of p^k",
            "\tif(is_zero(p)) return vector<T>(n);",
            "\tif(k < 60) return pow_series_slow(p, k, n);",
            "\tint i = 0;",
            "\twhile(i < (int)p.size() && p[i] == 0) ++ i;",
            "\treturn bpow(p[i], k) * truncated(shifted(exp_series(log_series(shifted(p, -i) / p[i], n) * k, n), min(i * k, 1LL * n)), n);",
            "}",
            "template<class T> vector<T> mulx(vector<T> p, T x){ // component-wise multiplication with x^k",
            "\tT cur = 1;",
            "\tfor(int i = 0; i < (int)p.size(); ++ i) p[i] *= cur, cur *= x;",
            "\treturn p;",
            "}",
            "template<class T> vector<T> mulx_sq(vector<T> p, T x){ // component-wise multiplication with x^{k^2}",
            "\tT cur = x, total = 1, xx = x * x;",
            "\tfor(int i = 0; i < (int)p.size(); ++ i) p[i] *= total, total *= cur, cur *= xx;",
            "\treturn p;",
            "}",
            "template<class T> vector<T> chirpz_even(const vector<T> &p, T z, int n){ // P(1), P(z^2), P(z^4), ..., P(z^2(n-1))",
            "\tif(is_zero(p)) return vector<T>(n, 0);",
            "\tint m = (int)p.size() - 1;",
            "\tvector<T> vv(m + n);",
            "\tT zi = 1 / z, zz = zi * zi, cur = zi, total = 1;",
            "\tfor(int i = 0; i <= max(n - 1, m); ++ i){",
            "\t\tif(i <= m){ vv[m - i] = total; }",
            "\t\tif(i < n){ vv[m + i] = total; }",
            "\t\ttotal *= cur, cur *= zz;",
            "\t}",
            "\treturn mulx_sq(substr(mulx_sq(p, z) * vv, m, m + n), z);",
            "}",
            "template<class T> vector<T> chirpz(const vector<T> &p, T z, int n){ // P(1), P(z), P(z^2), ..., P(z^(n-1))",
            "\tauto even = chirpz_even(p, z, n + 1 >> 1);",
            "\tauto odd = chirpz_even(mulx(p, z), z, n >> 1);",
            "\tvector<T> res(n);",
            "\tfor(int i = 0; i < n >> 1; ++ i) res[i << 1] = even[i], res[i << 1 | 1] = odd[i];",
            "\tif(n & 1) res[n - 1] = even.back();",
            "\treturn res;",
            "}",
            "template<typename T> vector<T> &build(const vector<T> &x, vector<vector<T>> &tree, int u, int l, int r){ // builds evaluation tree for (X-x_0)(X-x_1)...(X-x_(n-1))",
            "\tif(r - l == 1) return tree[u] = vector<T>{-x[l], 1};",
            "\telse{",
            "\t\tint m = l + (r - l >> 1);",
            "\t\treturn tree[u] = build(x, tree, u + 1, l, m) * build(x, tree, u + (m - l << 1), m, r);",
            "\t}",
            "}",
            "template<class T> vector<T> evaluate(const vector<T> &p, const vector<T> &x, const vector<vector<T>> &tree, int u, int l, int r){ // auxiliary evaluation function",
            "\tif(r - l == 1) return {evaluate(p, x[l])};",
            "\telse{",
            "\t\tint m = l + (r - l >> 1), v = u + 1, w = u + (m - l << 1);",
            "\t\tauto A = evaluate(p % tree[v], x, tree, v, l, m);",
            "\t\tauto B = evaluate(p % tree[w], x, tree, w, m, r);",
            "\t\tA.insert(A.end(), B.begin(), B.end());",
            "\t\treturn A;",
            "\t}",
            "}",
            "template<class T> vector<T> evaluate(const vector<T> &p, const vector<T> &x){ // evaluate polynomialnomial in (x_0, ..., x_(n-1))",
            "\tint n = (int)x.size();",
            "\tif(is_zero(p)) return vector<T>(n);",
            "\tvector<vector<T>> tree(n << 1);",
            "\tbuild(x, tree, 0, 0, n);",
            "\treturn evaluate(p, x, tree, 0, 0, n);",
            "}",
            "template<class T> vector<T> interpolate(const vector<T> &xp, const vector<T> &y, const vector<vector<T>> &tree, int u, int l, int r){ // auxiliary interpolation function. xp = derivative((X-x_l)...(X-x_(r-1)))",
            "\tif(r - l == 1) return {y[l] / xp[0]};",
            "\telse{",
            "\t\tint m = l + (r - l >> 1), v = u + 1, w = u + (m - l << 1);",
            "\t\tauto A = interpolate(xp % tree[v], y, tree, v, l, m);",
            "\t\tauto B = interpolate(xp % tree[w], y, tree, w, m, r);",
            "\t\treturn A * tree[w] + B * tree[v];",
            "\t}",
            "}",
            "template<class T> ostream &operator<<(ostream &out, const vector<T> &p){",
            "\tfor(auto x: p.a) out << x << \" \";",
            "\treturn out << \"\\n\";",
            "}",
            "template<class T> vector<T> generate(const vector<T> &x, int l, int r){ // computes (x-a1)(x-a2)...(x-an) without building tree",
            "\tif(r - l == 1) return vector<T>{-x[l], 1};",
            "\telse{",
            "\t\tint m = l + (r - l >> 1);",
            "\t\treturn generate(x, l, m) * generate(x, m, r);",
            "\t}",
            "}",
            "template<class T> vector<T> interpolate(const vector<T> &x, const vector<T> &y){ // interpolates minimum polynomialnomial from (xi, yi) pairs",
            "\tint n = (int)x.size();",
            "\tvector<vector<T>> tree(n << 1);",
            "\tbuild(x, tree, 0, 0, n);",
            "\treturn interpolate(derivative(tree[0]), y, tree, 0, 0, n);",
            "}"
        ],
        "description": "tranxuanbach"
    }
}