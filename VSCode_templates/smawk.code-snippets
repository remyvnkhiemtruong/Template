{
    "tranxuanbach": {
        "prefix": "smawk",
        "body": [
            "// http://web.cs.unlv.edu/larmore/Courses/CSC477/monge.pdf",
            "// The matrix has to be monotonic:",
            "//\tFor all i<j and k<l,",
            "//   f[j][k] = f[j][l] -> f[i][k] <= f[i][l] and",
            "//   f[j][k] < f[j][l] -> f[i][k] < f[i][l]",
            "//  where all comparisons are done by cmp",
            "// O(n + m)",
            "// Returns the indices of minimum column for each row",
            "template<class T, bool GET_MAX = false, class Compare = less<>>",
            "vector<int> smawk(int n, int m, auto _f, Compare cmp = less<>()){",
            "\tif(!n) return {};",
            "\tauto f = [&](int i, int j){ return GET_MAX ? -_f(i, m - 1 - j) : _f(i, j); };",
            "\tif(n >= 2 && m >= 2){",
            "\t\t#ifdef LOCAL",
            "\t\t// Verify monotonosity",
            "\t\tmt19937 rng(1564);",
            "\t\tfor(auto rep = 3; rep; -- rep){",
            "\t\t\tint i1 = rng() % (n - 1), i2 = rng() % (n - i1 - 1) + i1 + 1;",
            "\t\t\tint j1 = rng() % (m - 1), j2 = rng() % (n - j1 - 1) + j1 + 1;",
            "\t\t\tT a = f(i1, j1), b = f(i1, j2), c = f(i2, j1), d = f(i2, j2);",
            "\t\t\tif(cmp(c, d)) assert(cmp(a, b));",
            "\t\t\telse if(!cmp(d, c)) assert(!cmp(b, a));",
            "\t\t}",
            "\t\t#endif",
            "\t}",
            "\tauto solve = [&](auto self, const vector<int> &row, const vector<int> &col)->vector<int>{",
            "\t\tif((int)row.size() == 1) return vector<int>{*min_element(col.begin(), col.end(), [&](int j, int k){ return cmp(f(row[0], j), f(row[0], k)); })};",
            "\t\tif(row.size() < col.size()){ // Reduce",
            "\t\t\tvector<array<int, 2>> s; // its head(position in row arrow), active column",
            "\t\t\tfor(auto j: col){",
            "\t\t\t\twhile(true){",
            "\t\t\t\t\tif(s.empty()){",
            "\t\t\t\t\t\ts.push_back({0, j});",
            "\t\t\t\t\t\tbreak;",
            "\t\t\t\t\t}",
            "\t\t\t\t\tauto [i, last] = s.back();",
            "\t\t\t\t\tif(!cmp(f(row[i], last), f(row[i], j))) s.pop_back();",
            "\t\t\t\t\telse{",
            "\t\t\t\t\t\t++ i;",
            "\t\t\t\t\t\tif(i < (int)row.size()) s.push_back({i, j});",
            "\t\t\t\t\t\tbreak;",
            "\t\t\t\t\t}",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t\tvector<int> reduced_col((int)s.size());",
            "\t\t\tfor(int i = 0; i < (int)s.size(); ++ i) reduced_col[i] = s[i][1];",
            "\t\t\treturn self(self, row, reduced_col);",
            "\t\t}",
            "\t\telse{ // Interpolate",
            "\t\t\tvector<int> reduced_row((int)row.size() / 2), res((int)row.size());",
            "\t\t\tfor(auto i = 1; i < (int)row.size(); i += 2) reduced_row[i >> 1] = row[i];",
            "\t\t\tauto reduced_res = self(self, reduced_row, col);",
            "\t\t\tfor(auto i = 0, it = 0; i < (int)row.size(); ++ i){",
            "\t\t\t\tif(~i & 1){",
            "\t\t\t\t\tint last = i < (int)row.size() - 1 ? reduced_res[i >> 1] : col.back(), mincol = col[it];",
            "\t\t\t\t\twhile(col[it] < last){",
            "\t\t\t\t\t\t++ it;",
            "\t\t\t\t\t\tif(cmp(f(row[i], col[it]), f(row[i], mincol))) mincol = col[it];",
            "\t\t\t\t\t}",
            "\t\t\t\t\tres[i] = mincol;",
            "\t\t\t\t}",
            "\t\t\t\telse res[i] = reduced_res[i >> 1];",
            "\t\t\t}",
            "\t\t\treturn res;",
            "\t\t}",
            "\t};",
            "\tvector<int> row(n), col(m);",
            "\tiota(row.begin(), row.end(), 0), iota(col.begin(), col.end(), 0);",
            "\tauto res = solve(solve, row, col);",
            "\tif(GET_MAX) for(auto &j: res) j = m - 1 - j;",
            "\treturn res;",
            "}"
        ],
        "description": "tranxuanbach"
    }
}