{
    "tranxuanbach": {
        "prefix": "maximum_weight_matching",
        "body": [
            "// Harold N. Gabow, ",
            "// \"Data Structures for Weighted Matching and ",
            "// Extensions to b-matching and f-factors\"(2016)",
            "//(https://arxiv.org/abs/1611.07541)",
            "// Source: https://gist.github.com/min-25/b984122f97dd7f72500e0bd6e49906ca",
            "template<class CostType, class TotalCostType>",
            "struct maximum_weight_matching{",
            "\tusing cost_t = CostType;",
            "\tusing tcost_t = TotalCostType;",
            "\tenum Label{ kSeparated = -2, kInner = -1, kFree = 0, kOuter = 1 };",
            "\tstatic constexpr cost_t Inf = cost_t(1) <<(sizeof(cost_t) * 8 - 2);",
            "\ttemplate<class T>",
            "\tstruct binary_heap{",
            "\t\tstruct Node{",
            "\t\t\tbool operator <(const Node &rhs) const{ return value < rhs.value; }",
            "\t\t\tT value; int id;",
            "\t\t};",
            "\t\tbinary_heap(){}",
            "\t\tbinary_heap(int N): size_(0), node(N + 1), index(N, 0){}",
            "\t\tint size() const{ return size_; }",
            "\t\tbool empty() const{ return size_ == 0; }",
            "\t\tvoid clear(){ while(size_ > 0) index[node[size_--].id] = 0; }",
            "\t\tT min() const{ return node[1].value; }",
            "\t\tint argmin() const{ return node[1].id; } // argmin ?",
            "\t\tT get_val(int id) const{ return node[index[id]].value; }",
            "\t\tvoid pop(){ if(size_ > 0) pop(1); }",
            "\t\tvoid erase(int id){ if(index[id]) pop(index[id]); }",
            "\t\tbool has(int id) const{ return index[id] != 0; }",
            "\t\tvoid update(int id, T v){",
            "\t\t\tif(!has(id)) return push(id, v);",
            "\t\t\tbool up = (v < node[index[id]].value);",
            "\t\t\tnode[index[id]].value = v;",
            "\t\t\tif(up) up_heap(index[id]);",
            "\t\t\telse down_heap(index[id]);",
            "\t\t}",
            "\t\tvoid decrease_key(int id, T v){",
            "\t\t\tif(!has(id)) return push(id, v);",
            "\t\t\tif(v < node[index[id]].value) node[index[id]].value = v, up_heap(index[id]);",
            "\t\t}",
            "\t\tvoid push(int id, T v){",
            "\t\t\t// assert(!has(id));",
            "\t\t\tindex[id] = ++size_; node[size_] = {v, id};",
            "\t\t\tup_heap(size_);",
            "\t\t}",
            "\t\tvoid pop(int pos){",
            "\t\t\tindex[node[pos].id] = 0;",
            "\t\t\tif(pos == size_){ --size_; return; }",
            "\t\t\tbool up = (node[size_].value < node[pos].value);",
            "\t\t\tnode[pos] = node[size_ --]; index[node[pos].id] = pos;",
            "\t\t\tif(up) up_heap(pos);",
            "\t\t\telse down_heap(pos);",
            "\t\t}",
            "\t\tvoid swap_node(int a, int b){",
            "\t\t\tswap(node[a], node[b]); index[node[a].id] = a; index[node[b].id] = b;",
            "\t\t}",
            "\t\tvoid down_heap(int pos){",
            "\t\t\tfor(auto k = pos, nk = k; 2 * k <= size_; k = nk){",
            "\t\t\t\tif(node[2 * k] < node[nk]) nk = 2 * k;",
            "\t\t\t\tif(2 * k + 1 <= size_ && node[2 * k + 1] < node[nk]) nk = 2 * k + 1;",
            "\t\t\t\tif(nk == k) break;",
            "\t\t\t\tswap_node(k, nk);",
            "\t\t\t}",
            "\t\t}",
            "\t\tvoid up_heap(int pos){",
            "\t\t\tfor(auto k = pos; k > 1 && node[k] < node[k >> 1]; k >>= 1) swap_node(k, k >> 1);",
            "\t\t}",
            "\t\tint size_;",
            "\t\tvector<Node> node;",
            "\t\tvector<int> index;",
            "\t};",
            "\ttemplate<class Key>",
            "\tstruct pairing_heap{",
            "\t\tstruct Node{",
            "\t\t\tNode(): prev(-1){} // \"prev < 0\" means the node is unused.",
            "\t\t\tNode(Key v): key(v), child(0), next(0), prev(0){}",
            "\t\t\tKey key; int child, next, prev;",
            "\t\t};",
            "\t\tpairing_heap(int H, int N): heap(H), node(N){",
            "\t\t\t// It consists of `H` Pairing heaps.",
            "\t\t\t// Each heap-node ID can appear at most 1 time(s) among heaps",
            "\t\t\t// and should be in [1, N).",
            "\t\t}",
            "\t\tvoid clear(int h){ if(heap[h]) clear_rec(heap[h]), heap[h] = 0; }",
            "\t\tvoid clear_all(){",
            "\t\t\tfor(auto i = 0; i < (int)heap.size(); ++ i) heap[i] = 0;",
            "\t\t\tfor(auto i = 0; i < (int)node.size(); ++ i) node[i] = Node();",
            "\t\t}",
            "\t\tbool empty(int h) const{ return !heap[h]; }",
            "\t\tbool used(int v) const{ return node[v].prev >= 0; }",
            "\t\tKey min(int h) const{ return node[heap[h]].key; }",
            "\t\tint argmin(int h) const{ return heap[h]; }",
            "\t\tvoid pop(int h){",
            "\t\t\t// assert(!empty(h));",
            "\t\t\terase(h, heap[h]);",
            "\t\t}",
            "\t\tvoid push(int h, int v, Key key){",
            "\t\t\t// assert(!used(v));",
            "\t\t\tnode[v] = Node(key);",
            "\t\t\theap[h] = merge(heap[h], v);",
            "\t\t}",
            "\t\tvoid erase(int h, int v){",
            "\t\t\tif(!used(v)) return;",
            "\t\t\tint w = two_pass_pairing(node[v].child);",
            "\t\t\tif(!node[v].prev) heap[h] = w;",
            "\t\t\telse{",
            "\t\t\t\tcut(v);",
            "\t\t\t\theap[h] = merge(heap[h], w);",
            "\t\t\t}",
            "\t\t\tnode[v].prev = -1;",
            "\t\t}",
            "\t\tvoid decrease_key(int h, int v, Key key){",
            "\t\t\tif(!used(v)) return push(h, v, key);",
            "\t\t\tif(!node[v].prev) node[v].key = key;",
            "\t\t\telse{",
            "\t\t\t\tcut(v); node[v].key = key;",
            "\t\t\t\theap[h] = merge(heap[h], v);",
            "\t\t\t}",
            "\t\t}",
            "\t\tvoid clear_rec(int v){",
            "\t\t\tfor(; v; v = node[v].next){",
            "\t\t\t\tif(node[v].child) clear_rec(node[v].child);",
            "\t\t\t\tnode[v].prev = -1;",
            "\t\t\t}",
            "\t\t}",
            "\t\tinline void cut(int v){",
            "\t\t\tauto &n = node[v]; int pv = n.prev, nv = n.next;",
            "\t\t\tauto &pn = node[pv];",
            "\t\t\tif(pn.child == v) pn.child = nv;",
            "\t\t\telse pn.next = nv;",
            "\t\t\tnode[nv].prev = pv;",
            "\t\t\tn.next = n.prev = 0;",
            "\t\t}",
            "\t\tint merge(int l, int r){",
            "\t\t\tif(!l) return r;",
            "\t\t\tif(!r) return l;",
            "\t\t\tif(node[l].key > node[r].key) swap(l, r);",
            "\t\t\tint lc = node[r].next = node[l].child;",
            "\t\t\tnode[l].child = node[lc].prev = r;",
            "\t\t\treturn node[r].prev = l;",
            "\t\t}",
            "\t\tint two_pass_pairing(int root){",
            "\t\t\tif(!root) return 0;",
            "\t\t\tint a = root; root = 0;",
            "\t\t\twhile(a){",
            "\t\t\t\tint b = node[a].next, na = 0;",
            "\t\t\t\tnode[a].prev = node[a].next = 0;",
            "\t\t\t\tif(b) na = node[b].next, node[b].prev = node[b].next = 0;",
            "\t\t\t\ta = merge(a, b);",
            "\t\t\t\tnode[a].next = root; root = a; a = na;",
            "\t\t\t}",
            "\t\t\tint s = node[root].next; node[root].next = 0;",
            "\t\t\twhile(s){",
            "\t\t\t\tint t = node[s].next; node[s].next = 0;",
            "\t\t\t\troot = merge(root, s);",
            "\t\t\t\ts = t;",
            "\t\t\t}",
            "\t\t\treturn root;",
            "\t\t}",
            "\t\tvector<int> heap;",
            "\t\tvector<Node> node;",
            "\t};",
            "\ttemplate<class T>",
            "\tstruct PriorityQueue: public priority_queue<T, vector<T>, greater<T> >{",
            "\t\tPriorityQueue(){}",
            "\t\tPriorityQueue(int N){ this->c.reserve(N);}",
            "\t\tT min() const{ return this->top(); }",
            "\t\tvoid clear(){ this->c.clear(); }",
            "\t};",
            "\ttemplate<class T>",
            "\tstruct Queue{",
            "\t\tQueue(){}",
            "\t\tQueue(int N): qh(0), qt(0), data(N){}",
            "\t\tT operator [](int i) const{ return data[i]; }",
            "\t\tvoid enqueue(int u){ data[qt ++] = u; }",
            "\t\tint dequeue(){ return data[qh ++]; }",
            "\t\tbool empty() const{ return qh == qt; }",
            "\t\tvoid clear(){ qh = qt = 0; }",
            "\t\tint size() const{ return qt; }",
            "\t\tint qh, qt;",
            "\t\tvector<T> data;",
            "\t};",
            "\ttemplate<class T> using ModifiableHeap = binary_heap<T>;",
            "\ttemplate<class T> using ModifiableHeaps = pairing_heap<T>;",
            "\ttemplate<class T> using FastHeap = PriorityQueue<T>;",
            "\tstruct Edge{ int to; cost_t cost; };",
            "\tstruct Link{ int from, to; };",
            "\tstruct Node{ ",
            "\t\tstruct NodeLink{ int b, v; };",
            "\t\tNode(){}",
            "\t\tNode(int u): parent(0), size(1){ link[0] = link[1] = {u, u}; }",
            "\t\tint next_v() const{ return link[0].v; }",
            "\t\tint next_b() const{ return link[0].b; }",
            "\t\tint prev_v() const{ return link[1].v; }",
            "\t\tint prev_b() const{ return link[1].b; }",
            "\t\tint parent, size;",
            "\t\tNodeLink link[2];",
            "\t};",
            "\tstruct Event{",
            "\t\tEvent(){}",
            "\t\tEvent(cost_t time, int id): time(time), id(id){}",
            "\t\tbool operator <(const Event &rhs) const{ return time < rhs.time; }",
            "\t\tbool operator >(const Event &rhs) const{ return time > rhs.time; }",
            "\t\tcost_t time; int id;",
            "\t};",
            "\tstruct EdgeEvent{",
            "\t\tEdgeEvent(){}",
            "\t\tEdgeEvent(cost_t time, int from, int to): time(time), from(from), to(to){}",
            "\t\tbool operator >(const EdgeEvent &rhs) const{ return time > rhs.time; }",
            "\t\tbool operator <(const EdgeEvent &rhs) const{ return time < rhs.time; }",
            "\t\tcost_t time; int from, to; ",
            "\t};",
            "\ttcost_t compute_optimal_value() const{",
            "\t\ttcost_t ret = 0;",
            "\t\tfor(auto u = 1; u <= N; ++ u) if(mate[u] > u){",
            "\t\t\tcost_t max_c = 0;",
            "\t\t\tfor(auto eid = ofs[u]; eid < ofs[u + 1]; ++ eid){",
            "\t\t\t\tif(edges[eid].to == mate[u]) max_c = max(max_c, edges[eid].cost);",
            "\t\t\t}",
            "\t\t\tret += max_c;",
            "\t\t}",
            "\t\treturn ret >> 1;",
            "\t}",
            "\tinline tcost_t reduced_cost(int u, int v, const Edge &e) const{",
            "\t\treturn tcost_t(potential[u]) + potential[v] - e.cost;",
            "\t}",
            "\tvoid rematch(int v, int w){",
            "\t\tint t = mate[v]; mate[v] = w;",
            "\t\tif(mate[t] != v) return;",
            "\t\tif(link[v].to == surface[link[v].to]){",
            "\t\t\tmate[t] = link[v].from;",
            "\t\t\trematch(mate[t], t);",
            "\t\t}",
            "\t\telse{",
            "\t\t\tint x = link[v].from, y = link[v].to;",
            "\t\t\trematch(x, y); rematch(y, x);",
            "\t\t}",
            "\t}",
            "\tvoid fix_mate_and_base(int b){",
            "\t\tif(b <= N) return;",
            "\t\tint bv = base[b], mv = node[bv].link[0].v, bmv = node[bv].link[0].b;",
            "\t\tint d = (node[bmv].link[1].v == mate[mv]) ? 0 : 1;",
            "\t\twhile(1){",
            "\t\t\tint mv = node[bv].link[d].v, bmv = node[bv].link[d].b;",
            "\t\t\tif(node[bmv].link[1 ^ d].v != mate[mv]) break;",
            "\t\t\tfix_mate_and_base(bv); fix_mate_and_base(bmv);",
            "\t\t\tbv = node[bmv].link[d].b;",
            "\t\t}",
            "\t\tfix_mate_and_base(base[b] = bv);",
            "\t\tmate[b] = mate[bv];",
            "\t}",
            "\tvoid reset_time(){",
            "\t\ttime_current_ = 0; event1 = {Inf, 0};",
            "\t}",
            "\tvoid reset_blossom(int b){",
            "\t\tlabel[b] = kFree; link[b].from = 0; slack[b] = Inf; lazy[b] = 0;",
            "\t}",
            "\tvoid reset_all(){",
            "\t\tlabel[0] = kFree; link[0].from = 0;",
            "\t\tfor(auto v = 1; v <= N; ++ v){ // should be optimized for sparse graphs.",
            "\t\t\tif(label[v] == kOuter) potential[v] -= time_current_;",
            "\t\t\telse{",
            "\t\t\t\tint bv = surface[v];",
            "\t\t\t\tpotential[v] += lazy[bv];",
            "\t\t\t\tif(label[bv] == kInner) potential[v] += time_current_ - time_created[bv];",
            "\t\t\t}",
            "\t\t\treset_blossom(v);",
            "\t\t}",
            "\t\tfor(auto b = N + 1, r = B - unused_bid_idx_; r > 0 && b < S; ++ b) if(base[b] != b){",
            "\t\t\tif(surface[b] == b){",
            "\t\t\t\tfix_mate_and_base(b);",
            "\t\t\t\tif(label[b] == kOuter) potential[b] += (time_current_ - time_created[b]) << 1;",
            "\t\t\t\telse if(label[b] == kInner) fix_blossom_potential<kInner>(b);",
            "\t\t\t\telse fix_blossom_potential<kFree>(b);",
            "\t\t\t}",
            "\t\t\theap2s.clear(b);",
            "\t\t\treset_blossom(b); -- r;",
            "\t\t}",
            "",
            "\t\tque.clear();",
            "\t\treset_time(); heap2.clear();",
            "\t\theap3.clear(); heap4.clear();",
            "\t}",
            "\tvoid do_edmonds_search(int root){",
            "\t\tif(potential[root] == 0) return;",
            "\t\tlink_blossom(surface[root],{0, 0});",
            "\t\tpush_outer_and_fix_potentials(surface[root], 0);",
            "\t\tfor(bool augmented = false; !augmented; ){",
            "\t\t\taugmented = augment(root);",
            "\t\t\tif(augmented) break;",
            "\t\t\taugmented = adjust_dual_variables(root);",
            "\t\t}",
            "\t\treset_all();",
            "\t}",
            "\ttemplate<Label Lab>",
            "\tinline cost_t fix_blossom_potential(int b){",
            "\t\t// Return the amount.",
            "\t\t//(If v is an atom, the potential[v] will not be changed.)",
            "\t\tcost_t d = lazy[b]; lazy[b] = 0;",
            "\t\tif(Lab == kInner){",
            "\t\t\tcost_t dt = time_current_ - time_created[b];",
            "\t\t\tif(b > N) potential[b] -= dt << 1;",
            "\t\t\td += dt;",
            "\t\t}",
            "\t\treturn d;",
            "\t}",
            "\ttemplate<Label Lab>",
            "\tinline void update_heap2(int x, int y, int by, cost_t t){",
            "\t\tif(t >= slack[y]) return;",
            "\t\tslack[y] = t; best_from[y] = x;",
            "\t\tif(y == by){",
            "\t\t\tif(Lab != kInner) heap2.decrease_key(y, EdgeEvent(t + lazy[y], x, y));",
            "\t\t}",
            "\t\telse{",
            "\t\t\tint gy = group[y];",
            "\t\t\tif(gy != y){",
            "\t\t\t\tif(t >= slack[gy]) return;",
            "\t\t\t\tslack[gy] = t;",
            "\t\t\t}",
            "\t\t\theap2s.decrease_key(by, gy, EdgeEvent(t, x, y));",
            "\t\t\tif(Lab == kInner) return;",
            "\t\t\tEdgeEvent m = heap2s.min(by);",
            "\t\t\theap2.decrease_key(by, EdgeEvent(m.time + lazy[by], m.from, m.to));",
            "\t\t}",
            "\t}",
            "\tvoid activate_heap2_node(int b){",
            "\t\tif(b <= N){",
            "\t\t\tif(slack[b] < Inf) heap2.push(b, EdgeEvent(slack[b] + lazy[b], best_from[b], b));",
            "\t\t}",
            "\t\telse{",
            "\t\t\tif(heap2s.empty(b)) return;",
            "\t\t\tEdgeEvent m = heap2s.min(b);",
            "\t\t\theap2.push(b, EdgeEvent(m.time + lazy[b], m.from, m.to));",
            "\t\t}",
            "\t}",
            "\tvoid swap_blossom(int a, int b){",
            "\t\t// Assume that `b` is a maximal blossom.",
            "\t\tswap(base[a], base[b]); if(base[a] == a) base[a] = b;",
            "\t\tswap(heavy[a], heavy[b]); if(heavy[a] == a) heavy[a] = b;",
            "\t\tswap(link[a], link[b]);",
            "\t\tswap(mate[a], mate[b]);",
            "\t\tswap(potential[a], potential[b]); swap(lazy[a], lazy[b]);",
            "\t\tswap(time_created[a], time_created[b]);",
            "\t\tfor(auto d = 0; d < 2; ++ d) node[node[a].link[d].b].link[1 ^ d].b = b;",
            "\t\tswap(node[a], node[b]);",
            "\t}",
            "\tvoid set_surface_and_group(int b, int sf, int g){",
            "\t\tsurface[b] = sf, group[b] = g;",
            "\t\tif(b <= N) return;",
            "\t\tfor(auto bb = base[b]; surface[bb] != sf; bb = node[bb].next_b()){",
            "\t\t\tset_surface_and_group(bb, sf, g);",
            "\t\t}",
            "\t}",
            "\tvoid merge_smaller_blossoms(int bid){",
            "\t\tint lb = bid, largest_size = 1;",
            "\t\tfor(auto beta = base[bid], b = beta; ;){",
            "\t\t\tif(node[b].size > largest_size) largest_size = node[b].size, lb = b;",
            "\t\t\tif((b = node[b].next_b()) == beta) break;",
            "\t\t}",
            "\t\tfor(auto beta = base[bid], b = beta; ;){",
            "\t\t\tif(b != lb) set_surface_and_group(b, lb, b);",
            "\t\t\tif((b = node[b].next_b()) == beta) break;",
            "\t\t}",
            "\t\tgroup[lb] = lb;",
            "\t\tif(largest_size > 1){",
            "\t\t\tsurface[bid] = heavy[bid] = lb; ",
            "\t\t\tswap_blossom(lb, bid);",
            "\t\t}",
            "\t\telse heavy[bid] = 0;",
            "\t}",
            "\tvoid contract(int x, int y, int eid){",
            "\t\tint bx = surface[x], by = surface[y]; assert(bx != by);",
            "\t\tconst int h = -(eid + 1);",
            "\t\tlink[surface[mate[bx]]].from = link[surface[mate[by]]].from = h;",
            "",
            "\t\tint lca = -1;",
            "\t\twhile(1){",
            "\t\t\tif(mate[by] != 0) swap(bx, by);",
            "\t\t\tbx = lca = surface[link[bx].from];",
            "\t\t\tif(link[surface[mate[bx]]].from == h) break;",
            "\t\t\tlink[surface[mate[bx]]].from = h;",
            "\t\t}",
            "\t\tconst int bid = unused_bid[--unused_bid_idx_]; assert(unused_bid_idx_ >= 0);",
            "\t\tint tree_size = 0;",
            "\t\tfor(auto d = 0; d < 2; ++ d){",
            "\t\t\tfor(auto bv = surface[x]; bv != lca; ){",
            "\t\t\t\tint mv = mate[bv], bmv = surface[mv], v = mate[mv];",
            "\t\t\t\tint f = link[v].from, t = link[v].to;",
            "\t\t\t\ttree_size += node[bv].size + node[bmv].size;",
            "\t\t\t\tlink[mv] = {x, y};",
            "",
            "\t\t\t\tif(bv > N) potential[bv] += (time_current_ - time_created[bv]) << 1;",
            "\t\t\t\tif(bmv > N) heap4.erase(bmv);",
            "\t\t\t\tpush_outer_and_fix_potentials(bmv, fix_blossom_potential<kInner>(bmv));",
            "",
            "\t\t\t\tnode[bv].link[d] = {bmv, mv};",
            "\t\t\t\tnode[bmv].link[1 ^ d] = {bv, v}; node[bmv].link[d] = {bv = surface[f], f};",
            "\t\t\t\tnode[bv].link[1 ^ d] = {bmv, t};",
            "\t\t\t}",
            "\t\t\tnode[surface[x]].link[1 ^ d] = {surface[y], y};",
            "\t\t\tswap(x, y);",
            "\t\t}",
            "\t\tif(lca > N) potential[lca] += (time_current_ - time_created[lca]) << 1;",
            "\t\tnode[bid].size = tree_size + node[lca].size;",
            "\t\tbase[bid] = lca; link[bid] = link[lca]; mate[bid] = mate[lca];",
            "\t\tlabel[bid] = kOuter;",
            "\t\tsurface[bid] = bid; time_created[bid] = time_current_;",
            "\t\tpotential[bid] = 0; lazy[bid] = 0;",
            "",
            "\t\tmerge_smaller_blossoms(bid); // O(n log n) time / Edmonds search",
            "\t}",
            "\tvoid link_blossom(int v, Link l){",
            "\t\tlink[v] = {l.from, l.to};",
            "\t\tif(v <= N) return;",
            "\t\tint b = base[v]; link_blossom(b, l);",
            "\t\tint pb = node[b].prev_b();",
            "\t\tl = {node[pb].next_v(), node[b].prev_v()};",
            "\t\tfor(auto bv = b; ; ){",
            "\t\t\tint bw = node[bv].next_b();",
            "\t\t\tif(bw == b) break;",
            "\t\t\tlink_blossom(bw, l);",
            "\t\t\tLink nl = {node[bw].prev_v(), node[bv].next_v()};",
            "\t\t\tbv = node[bw].next_b();",
            "\t\t\tlink_blossom(bv, nl);",
            "\t\t}",
            "\t}",
            "\tvoid push_outer_and_fix_potentials(int v, cost_t d){",
            "\t\tlabel[v] = kOuter;",
            "\t\tif(v > N){",
            "\t\t\tfor(auto b = base[v]; label[b] != kOuter; b = node[b].next_b()){",
            "\t\t\t\tpush_outer_and_fix_potentials(b, d);",
            "\t\t\t}",
            "\t\t}",
            "\t\telse{",
            "\t\t\tpotential[v] += time_current_ + d;",
            "\t\t\tif(potential[v] < event1.time) event1 = {potential[v], v};",
            "\t\t\tque.enqueue(v);",
            "\t\t}",
            "\t}",
            "\tbool grow(int x, int y){",
            "\t\tint by = surface[y];",
            "\t\tbool visited = (label[by] != kFree);",
            "\t\tif(!visited) link_blossom(by,{0, 0});",
            "\t\tlabel[by] = kInner; time_created[by] = time_current_; heap2.erase(by);",
            "\t\tif(y != by) heap4.update(by, time_current_ +(potential[by] >> 1));",
            "\t\tint z = mate[by];",
            "\t\tif(z == 0){",
            "\t\t\trematch(x, y); rematch(y, x);",
            "\t\t\treturn true;",
            "\t\t}",
            "\t\tint bz = surface[z];",
            "\t\tif(!visited) link_blossom(bz,{x, y}); ",
            "\t\telse link[bz] = link[z] = {x, y};",
            "\t\tpush_outer_and_fix_potentials(bz, fix_blossom_potential<kFree>(bz));",
            "\t\ttime_created[bz] = time_current_; heap2.erase(bz);",
            "\t\treturn false;",
            "\t}",
            "\tvoid free_blossom(int bid){",
            "\t\tunused_bid[unused_bid_idx_++] = bid;",
            "\t\tbase[bid] = bid;",
            "\t}",
            "\tint recalculate_minimum_slack(int b, int g){",
            "\t\t// Return the destination of the best edge of blossom `g`.",
            "\t\tif(b <= N){",
            "\t\t\tif(slack[b] >= slack[g]) return 0;",
            "\t\t\tslack[g] = slack[b]; best_from[g] = best_from[b];",
            "\t\t\treturn b;",
            "\t\t}",
            "\t\tint v = 0;",
            "\t\tfor(auto beta = base[b], bb = beta; ; ){",
            "\t\t\tint w = recalculate_minimum_slack(bb, g);",
            "\t\t\tif(w != 0) v = w;",
            "\t\t\tif((bb = node[bb].next_b()) == beta) break;",
            "\t\t}",
            "\t\treturn v;",
            "\t}",
            "\tvoid construct_smaller_components(int b, int sf, int g){",
            "\t\tsurface[b] = sf, group[b] = g; // `group[b] = g` is unneeded.",
            "\t\tif(b <= N) return;",
            "\t\tfor(auto bb = base[b]; surface[bb] != sf; bb = node[bb].next_b()){",
            "\t\t\tif(bb == heavy[b]){",
            "\t\t\t\tconstruct_smaller_components(bb, sf, g);",
            "\t\t\t}",
            "\t\t\telse{",
            "\t\t\t\tset_surface_and_group(bb, sf, bb);",
            "\t\t\t\tint to = 0;",
            "\t\t\t\tif(bb > N) slack[bb] = Inf, to = recalculate_minimum_slack(bb, bb);",
            "\t\t\t\telse if(slack[bb] < Inf) to = bb;",
            "\t\t\t\tif(to > 0) heap2s.push(sf, bb, EdgeEvent(slack[bb], best_from[bb], to));",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "\tvoid move_to_largest_blossom(int bid){",
            "\t\tconst int h = heavy[bid];",
            "\t\tcost_t d = (time_current_ - time_created[bid]) + lazy[bid]; lazy[bid] = 0;",
            "\t\tfor(auto beta = base[bid], b = beta; ;){",
            "\t\t\ttime_created[b] = time_current_;",
            "\t\t\tlazy[b] = d;",
            "\t\t\tif(b != h) construct_smaller_components(b, b, b), heap2s.erase(bid, b);",
            "\t\t\tif((b = node[b].next_b()) == beta) break;",
            "\t\t}",
            "\t\tif(h > 0) swap_blossom(h, bid), bid = h;",
            "\t\tfree_blossom(bid);",
            "\t}",
            "\tvoid expand(int bid){",
            "\t\tint mv = mate[base[bid]];",
            "\t\tmove_to_largest_blossom(bid); // O(n log n) time / Edmonds search",
            "\t\tLink old_link = link[mv];",
            "\t\tint old_base = surface[mate[mv]], root = surface[old_link.to];",
            "\t\tint d = (mate[root] == node[root].link[0].v) ? 1 : 0;",
            "\t\tfor(auto b = node[old_base].link[d ^ 1].b; b != root; ){",
            "\t\t\tlabel[b] = kSeparated; activate_heap2_node(b); b = node[b].link[d ^ 1].b;",
            "\t\t\tlabel[b] = kSeparated; activate_heap2_node(b); b = node[b].link[d ^ 1].b;",
            "\t\t}",
            "\t\tfor(auto b = old_base; ; b = node[b].link[d].b){",
            "\t\t\tlabel[b] = kInner;",
            "\t\t\tint nb = node[b].link[d].b;",
            "\t\t\tif(b == root) link[mate[b]] = old_link;",
            "\t\t\telse link[mate[b]] = {node[b].link[d].v, node[nb].link[d ^ 1].v};",
            "\t\t\tlink[surface[mate[b]]] = link[mate[b]]; // fix tree links",
            "\t\t\tif(b > N){",
            "\t\t\t\tif(potential[b] == 0) expand(b);",
            "\t\t\t\telse heap4.push(b, time_current_ +(potential[b] >> 1));",
            "\t\t\t}",
            "\t\t\tif(b == root) break;",
            "\t\t\tpush_outer_and_fix_potentials(nb, fix_blossom_potential<kInner>(b = nb));",
            "\t\t}",
            "\t}",
            "\tbool augment(int root){",
            "\t\t// Return true if an augmenting path is found.",
            "\t\twhile(!que.empty()){",
            "\t\t\tint x = que.dequeue(), bx = surface[x];",
            "\t\t\tif(potential[x] == time_current_){",
            "\t\t\t\tif(x != root) rematch(x, 0);",
            "\t\t\t\treturn true;",
            "\t\t\t}",
            "\t\t\tfor(auto eid = ofs[x]; eid < ofs[x + 1]; ++ eid){",
            "\t\t\t\tauto &e = edges[eid]; int y = e.to, by = surface[y];",
            "\t\t\t\tif(bx == by) continue;",
            "\t\t\t\tLabel l = label[by];",
            "\t\t\t\tif(l == kOuter){",
            "\t\t\t\t\tcost_t t = reduced_cost(x, y, e) >> 1; // < 2 * Inf",
            "\t\t\t\t\tif(t == time_current_){",
            "\t\t\t\t\t\tcontract(x, y, eid); bx = surface[x];",
            "\t\t\t\t\t}",
            "\t\t\t\t\telse if(t < event1.time){",
            "\t\t\t\t\t\theap3.emplace(t, x, eid);",
            "\t\t\t\t\t}",
            "\t\t\t\t}",
            "\t\t\t\telse{",
            "\t\t\t\t\ttcost_t t = reduced_cost(x, y, e); // < 3 * Inf",
            "\t\t\t\t\tif(t >= Inf) continue;",
            "\t\t\t\t\tif(l != kInner){",
            "\t\t\t\t\t\tif(cost_t(t) + lazy[by] == time_current_){",
            "\t\t\t\t\t\t\tif(grow(x, y)) return true;",
            "\t\t\t\t\t\t}",
            "\t\t\t\t\t\telse update_heap2<kFree>(x, y, by, t);",
            "\t\t\t\t\t}",
            "\t\t\t\t\telse{",
            "\t\t\t\t\t\tif(mate[x] != y) update_heap2<kInner>(x, y, by, t);",
            "\t\t\t\t\t}",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t}",
            "\t\treturn false;",
            "\t}",
            "\tbool adjust_dual_variables(int root){",
            "\t\t// delta1 : rematch",
            "\t\tcost_t time1 = event1.time;",
            "\t\t// delta2 : grow",
            "\t\tcost_t time2 = Inf;",
            "\t\tif(!heap2.empty()) time2 = heap2.min().time;",
            "\t\t// delta3 : contract : O(m log n) time / Edmonds search [ bottleneck(?) ]",
            "\t\tcost_t time3 = Inf;",
            "\t\twhile(!heap3.empty()){",
            "\t\t\tEdgeEvent e = heap3.min();",
            "\t\t\tint x = e.from, y = edges[e.to].to; // e.to is some edge id.",
            "\t\t\tif(surface[x] != surface[y]){",
            "\t\t\t\ttime3 = e.time;",
            "\t\t\t\tbreak;",
            "\t\t\t}",
            "\t\t\telse heap3.pop();",
            "\t\t}",
            "\t\t// delta4 : expand",
            "\t\tcost_t time4 = Inf;",
            "\t\tif(!heap4.empty()) time4 = heap4.min();",
            "\t\t// -- events --",
            "\t\tcost_t time_next = min(min(time1, time2), min(time3, time4));",
            "\t\tassert(time_current_ <= time_next && time_next < Inf);",
            "\t\ttime_current_ = time_next;",
            "\t\tif(time_current_ == event1.time){",
            "\t\t\tint x = event1.id;",
            "\t\t\tif(x != root) rematch(x, 0);",
            "\t\t\treturn true;",
            "\t\t}",
            "\t\twhile(!heap2.empty() && heap2.min().time == time_current_){",
            "\t\t\tint x = heap2.min().from, y = heap2.min().to;",
            "\t\t\tif(grow(x, y)) return true; // `grow` function will call `heap2.erase(by)`.",
            "\t\t}",
            "\t\twhile(!heap3.empty() && heap3.min().time == time_current_){",
            "\t\t\tint x = heap3.min().from, eid = heap3.min().to;",
            "\t\t\tint y = edges[eid].to; heap3.pop();",
            "\t\t\tif(surface[x] == surface[y]) continue;",
            "\t\t\tcontract(x, y, eid);",
            "\t\t}",
            "\t\twhile(!heap4.empty() && heap4.min() == time_current_){",
            "\t\t\tint b = heap4.argmin(); heap4.pop();",
            "\t\t\texpand(b);",
            "\t\t}",
            "\t\treturn false;",
            "\t}",
            "\tint N, B, S; // N = |V|, B = (|V| - 1) / 2, S = N + B + 1",
            "\tvector<int> ofs;",
            "\tvector<Edge> edges;",
            "\tQueue<int> que;",
            "\tvector<int> mate, surface, base;",
            "\tvector<Link> link;",
            "\tvector<Label> label;",
            "\tvector<cost_t> potential;",
            "\tvector<int> unused_bid; int unused_bid_idx_;",
            "\tvector<Node> node;",
            "\t// for O(n * m * log(n)) implementation",
            "\tvector<int> heavy, group;",
            "\tvector<cost_t> time_created, lazy, slack;",
            "\tvector<int> best_from;",
            "\tcost_t time_current_;",
            "\tEvent event1;",
            "\tModifiableHeap<EdgeEvent> heap2;",
            "\tModifiableHeaps<EdgeEvent> heap2s;",
            "\tFastHeap<EdgeEvent> heap3;",
            "\tModifiableHeap<cost_t> heap4;",
            "\tvoid initialize(){",
            "\t\tque = Queue<int>(N);",
            "\t\tmate.assign(S, 0);",
            "\t\tlink.assign(S,{0, 0});",
            "\t\tlabel.assign(S, kFree);",
            "\t\tbase.resize(S); for(auto u = 1; u < S; ++ u) base[u] = u;",
            "\t\tsurface.resize(S); for(auto u = 1; u < S; ++ u) surface[u] = u;",
            "\t\tpotential.resize(S);",
            "\t\tnode.resize(S); for(auto b = 1; b < S; ++ b) node[b] = Node(b);",
            "\t\tunused_bid.resize(B); for(auto i = 0; i < B; ++ i) unused_bid[i] = N + B - i;",
            "\t\tunused_bid_idx_ = B;",
            "\t\t// for O(nm log n) implementation",
            "\t\treset_time();",
            "\t\ttime_created.resize(S);",
            "\t\tslack.resize(S); for(auto i = 0; i < S; ++ i) slack[i] = Inf;",
            "\t\tbest_from.assign(S, 0);",
            "\t\theavy.assign(S, 0);",
            "\t\tlazy.assign(S, 0);",
            "\t\tgroup.resize(S); for(auto i = 0; i < S; ++ i) group[i] = i;",
            "\t}",
            "\tvoid set_potential(){",
            "\t\tfor(auto u = 1; u <= N; ++ u){",
            "\t\t\tcost_t max_c = 0;",
            "\t\t\tfor(auto eid = ofs[u]; eid < ofs[u + 1]; ++ eid){",
            "\t\t\t\tmax_c = max(max_c, edges[eid].cost);",
            "\t\t\t}",
            "\t\t\tpotential[u] = max_c >> 1;",
            "\t\t}",
            "\t}",
            "\tvoid find_maximal_matching(){",
            "\t\t// Find a maximal matching naively.",
            "\t\tfor(auto u = 1; u <= N; ++ u) if(!mate[u]){",
            "\t\t\tfor(auto eid = ofs[u]; eid < ofs[u + 1]; ++ eid){",
            "\t\t\t\tauto &e = edges[eid]; int v = e.to;",
            "\t\t\t\tif(mate[v] > 0 || reduced_cost(u, v, e) > 0) continue;",
            "\t\t\t\tmate[u] = v; mate[v] = u;",
            "\t\t\t\tbreak;",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "\tmaximum_weight_matching(int N, const vector<tuple<int, int, cost_t>> &in): N(N), B((N - 1) / 2), S(N + B + 1), ofs(N + 2), edges(in.size() * 2), heap2(S), heap2s(S, S), heap3(edges.size()), heap4(S){",
            "\t\tfor(auto [u, v, w]: in) ++ ofs[u + 2], ++ ofs[v + 2];",
            "\t\tfor(auto i = 1; i <= N + 1; ++ i) ofs[i] += ofs[i - 1];",
            "\t\tfor(auto [u, v, w]: in){",
            "\t\t\tedges[ofs[u + 1] ++] = {v + 1, w * 2};",
            "\t\t\tedges[ofs[v + 1] ++] = {u + 1, w * 2};",
            "\t\t}",
            "\t\tfor(auto i = N + 1; i > 0; -- i) ofs[i] = ofs[i - 1];",
            "\t\tofs[0] = 0;",
            "\t}",
            "\t// O(n * m * log(n)) time and O(n + m) space",
            "\ttcost_t solve(bool init_matching = false){",
            "\t\tinitialize();",
            "\t\tset_potential();",
            "\t\tif(init_matching) find_maximal_matching();",
            "\t\tfor(auto u = 1; u <= N; ++ u) if(!mate[u]) do_edmonds_search(u);",
            "\t\ttcost_t res = compute_optimal_value();",
            "\t\treturn res;",
            "\t}",
            "\t// solve() must be called beforehand.",
            "\tvector<array<int, 2>> get_matching_edges(){",
            "\t\tvector<array<int, 2>>\tres;",
            "\t\tfor(auto u = 1; u <= N; ++ u) if(u < mate[u]) res.push_back({u - 1, mate[u] - 1});",
            "\t\treturn res;",
            "\t}",
            "};"
        ],
        "description": "tranxuanbach"
    }
}