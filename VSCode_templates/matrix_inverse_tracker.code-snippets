{
    "tranxuanbach": {
        "prefix": "matrix_inverse_tracker",
        "body": [
            "// Maintain the determinant, inverse determinant, and the inverse of a matrix up to addition updates of another matrix of small rank",
            "// M must be a matrix type",
            "// Assumes T is a field",
            "// Requires matrix, matrix_fixed, or matrix_Z2",
            "template<class M>",
            "struct matrix_inverse_tracker{",
            "\tusing T = M::ring_t;",
            "\tint n;",
            "\tM matrix;",
            "\tT determinant;",
            "\tM inverse_matrix;",
            "\tT inverse_determinant;",
            "\t// Assumes a is invertible",
            "\tmatrix_inverse_tracker(const M &a):",
            "\t\tn(a.n),",
            "\t\tmatrix(a),",
            "\t\tdeterminant(a.determinant_field()),",
            "\t\tinverse_matrix(*a.inverse()),",
            "\t\tinverse_determinant(T(1) / determinant){",
            "\t\tassert(a.m == n);",
            "\t}",
            "\t// Shermanâ€“Morrison formula and matrix determinant lemma",
            "\t// Apply a += u * v^T if the resulting matrix is invertible",
            "\t// O(n^2) operations on T",
            "\tbool update(const M::domain_t &u, const M::range_t &v){",
            "\t\tauto au = inverse_matrix * u;",
            "\t\tT c = T(1);",
            "\t\tfor(auto i = 0; i < n; ++ i) c += v[i] * au[i];",
            "\t\tif(c == T(0)) return false;",
            "\t\tfor(auto i = 0; i < n; ++ i) for(auto j = 0; j < n; ++ j) matrix[i][j] += u[i] * v[j];",
            "\t\tdeterminant *= c;",
            "\t\tinverse_determinant *= c = T(1) / c;",
            "\t\tauto va = v * inverse_matrix;",
            "\t\tfor(auto &x: va) x *= c;",
            "\t\tfor(auto i = 0; i < n; ++ i) for(auto j = 0; j < n; ++ j) inverse_matrix[i][j] -= au[i] * va[j];",
            "\t\treturn true;",
            "\t}",
            "\t// Woodbury matrix identity and generalized matrix determinant lemma",
            "\t// Assumes that C is invertible",
            "\t// Apply a += U * C * V if the resulting matrix is invertible",
            "\t// O(k) find_inverse() calls along with O(k * n^2 + k^3) operations on T",
            "\ttemplate<class M1, class M2, class M3>",
            "\tbool update(const M1 &U, const M2 &C, const M3 &V){",
            "\t\tint k = C.n;",
            "\t\tassert(U.n == n && U.m == k);",
            "\t\tassert(C.n == k && C.m == k);",
            "\t\tassert(V.n == k && V.m == n);",
            "\t\tT det_C = C.determinant_field();",
            "\t\tT det_C_inv = T(1) / det_C;",
            "\t\tauto au = inverse_matrix * U;",
            "\t\tauto D = *C.inverse() + V * au;",
            "\t\tauto invDp = D.inverse();",
            "\t\tif(!invDp) return false;",
            "\t\tmatrix += U * C * V;",
            "\t\tdeterminant *= D.determinant_field() * det_C;",
            "\t\tinverse_determinant *= (D = *invDp).determinant_field() * det_C_inv;",
            "\t\tauto va = V * inverse_matrix;",
            "\t\tinverse_matrix -= au * D * va;",
            "\t\treturn true;",
            "\t}",
            "};"
        ],
        "description": "tranxuanbach"
    }
}