{
    "tranxuanbach": {
        "prefix": "number_theoric_transform",
        "body": [
            "// T must be of modular type",
            "// mod must be a prime",
            "// Requires modular",
            "template<class T>",
            "struct number_theoric_transform_wrapper{",
            "\t// i \\in [2^k, 2^{k+1}) holds w_{2^k+1}^{i-2^k}",
            "\tstatic vector<T> root, buffer1, buffer2;",
            "\tstatic void adjust_root(int n){",
            "\t\tif(root.empty()) root = {1, 1};",
            "\t\tfor(auto k = (int)root.size(); k < n; k <<= 1){",
            "\t\t\troot.resize(n, 1);",
            "\t\t\tT w = T::primitive_root().power((T::mod() - 1) / (k << 1));",
            "\t\t\tfor(auto i = k; i < k << 1; ++ i) root[i] = i & 1 ? root[i >> 1] * w : root[i >> 1];",
            "\t\t}",
            "\t}",
            "\t// n must be a power of two",
            "\t// p must have next n memories allocated",
            "\t// O(n * log(n))",
            "\tstatic void transform(int n, T *p, bool invert = false){",
            "\t\tassert(n && __builtin_popcount(n) == 1 && (T::mod() - 1) % n == 0);",
            "\t\tfor(auto i = 1, j = 0; i < n; ++ i){",
            "\t\t\tint bit = n >> 1;",
            "\t\t\tfor(; j & bit; bit >>= 1) j ^= bit;",
            "\t\t\tj ^= bit;",
            "\t\t\tif(i < j) swap(p[i], p[j]);",
            "\t\t}",
            "\t\tadjust_root(n);",
            "\t\tfor(auto len = 1; len < n; len <<= 1) for(auto i = 0; i < n; i += len << 1) for(auto j = 0; j < len; ++ j){",
            "\t\t\tT x = p[i + j], y = p[len + i + j] * root[len + j];",
            "\t\t\tp[i + j] = x + y, p[len + i + j] = x - y;",
            "\t\t}",
            "\t\tif(invert){",
            "\t\t\treverse(p + 1, p + n);",
            "\t\t\tT inv_n = T(1) / n;",
            "\t\t\tfor(auto i = 0; i < n; ++ i) p[i] *= inv_n;",
            "\t\t}",
            "\t}",
            "\tstatic void transform(vector<T> &p, bool invert = false){",
            "\t\ttransform((int)p.size(), p.data(), invert);",
            "\t}",
            "\t// Double the length of the ntt array",
            "\t// n must be a power of two",
            "\t// p must have next 2n memories allocated",
            "\t// O(n * log(n))",
            "\tstatic void double_up(int n, T *p){",
            "\t\tassert(n && __builtin_popcount(n) == 1 && (T().mod() - 1) % (n << 1) == 0);",
            "\t\tbuffer1.resize(n << 1);",
            "\t\tfor(auto i = 0; i < n; ++ i) buffer1[i << 1] = p[i];",
            "\t\ttransform(n, p, true);",
            "\t\tadjust_root(n << 1);",
            "\t\tfor(auto i = 0; i < n; ++ i) p[i] *= root[n | i];",
            "\t\ttransform(n, p);",
            "\t\tfor(auto i = 0; i < n; ++ i) buffer1[i << 1 | 1] = p[i];",
            "\t\tcopy(buffer1.begin(), buffer1.begin() + 2 * n, p);",
            "\t}",
            "\tstatic void double_up(vector<T> &p){",
            "\t\tint n = (int)p.size();",
            "\t\tp.resize(n << 1);",
            "\t\tdouble_up(n, p.data());",
            "\t}",
            "\t// O(n * m)",
            "\tstatic vector<T> convolute_naive(const vector<T> &p, const vector<T> &q){",
            "\t\tvector<T> res(max((int)p.size() + (int)q.size() - 1, 0));",
            "\t\tfor(auto i = 0; i < (int)p.size(); ++ i) for(auto j = 0; j < (int)q.size(); ++ j) res[i + j] += p[i] * q[j];",
            "\t\treturn res;",
            "\t}",
            "\t// O((n + m) * log(n + m))",
            "\tstatic vector<T> convolute(const vector<T> &p, const vector<T> &q){",
            "\t\tif(min(p.size(), q.size()) < 55) return convolute_naive(p, q);",
            "\t\tint m = (int)p.size() + (int)q.size() - 1, n = 1 << __lg(m) + 1;",
            "\t\tbuffer1.assign(n, 0);",
            "\t\tcopy(p.begin(), p.end(), buffer1.begin());",
            "\t\ttransform(buffer1);",
            "\t\tbuffer2.assign(n, 0);",
            "\t\tcopy(q.begin(), q.end(), buffer2.begin());",
            "\t\ttransform(buffer2);",
            "\t\tfor(auto i = 0; i < n; ++ i) buffer1[i] *= buffer2[i];",
            "\t\ttransform(buffer1, true);",
            "\t\treturn vector<T>(buffer1.begin(), buffer1.begin() + m);",
            "\t}",
            "\t// O((n + m) * log(n + m))",
            "\tstatic vector<T> square(const vector<T> &p){",
            "\t\tif((int)p.size() < 40) return convolute_naive(p, p);",
            "\t\tint m = 2 * (int)p.size() - 1, n = 1 << __lg(m) + 1;",
            "\t\tbuffer1.assign(n, 0);",
            "\t\tcopy(p.begin(), p.end(), buffer1.begin());",
            "\t\ttransform(buffer1);",
            "\t\tfor(auto i = 0; i < n; ++ i) buffer1[i] *= buffer1[i];",
            "\t\ttransform(buffer1, true);",
            "\t\treturn vector<T>(buffer1.begin(), buffer1.begin() + m);",
            "\t}",
            "\t// O((n + m) * log(n + m))",
            "\tstatic vector<T> arbitrarily_convolute(const vector<T> &p, const vector<T> &q){",
            "\t\tusing modular0 = modular_fixed_base<unsigned int, 1045430273>;",
            "\t\tusing modular1 = modular_fixed_base<unsigned int, 1051721729>;",
            "\t\tusing modular2 = modular_fixed_base<unsigned int, 1053818881>;",
            "\t\tusing ntt0 = number_theoric_transform_wrapper<modular0>;",
            "\t\tusing ntt1 = number_theoric_transform_wrapper<modular1>;",
            "\t\tusing ntt2 = number_theoric_transform_wrapper<modular2>;",
            "\t\tvector<modular0> p0((int)p.size()), q0((int)q.size());",
            "\t\tfor(auto i = 0; i < (int)p.size(); ++ i) p0[i] = p[i].data;",
            "\t\tfor(auto i = 0; i < (int)q.size(); ++ i) q0[i] = q[i].data;",
            "\t\tauto xy0 = ntt0::convolute(p0, q0);",
            "\t\tvector<modular1> p1((int)p.size()), q1((int)q.size());",
            "\t\tfor(auto i = 0; i < (int)p.size(); ++ i) p1[i] = p[i].data;",
            "\t\tfor(auto i = 0; i < (int)q.size(); ++ i) q1[i] = q[i].data;",
            "\t\tauto xy1 = ntt1::convolute(p1, q1);",
            "\t\tvector<modular2> p2((int)p.size()), q2((int)q.size());",
            "\t\tfor(auto i = 0; i < (int)p.size(); ++ i) p2[i] = p[i].data;",
            "\t\tfor(auto i = 0; i < (int)q.size(); ++ i) q2[i] = q[i].data;",
            "\t\tauto xy2 = ntt2::convolute(p2, q2);",
            "\t\tstatic const modular1 r01 = 1 / modular1(modular0::mod());",
            "\t\tstatic const modular2 r02 = 1 / modular2(modular0::mod());",
            "\t\tstatic const modular2 r12 = 1 / modular2(modular1::mod());",
            "\t\tstatic const modular2 r02r12 = r02 * r12;",
            "\t\tstatic const T w1 = modular0::mod();",
            "\t\tstatic const T w2 = w1 * modular1::mod();",
            "\t\tint n = (int)p.size() + (int)q.size() - 1;",
            "\t\tvector<T> res(n);",
            "\t\tfor(auto i = 0; i < n; ++ i){",
            "\t\t\tusing ull = unsigned long long;",
            "\t\t\tull a = xy0[i].data;",
            "\t\t\tull b = (xy1[i].data + modular1::mod() - a) * r01.data % modular1::mod();",
            "\t\t\tull c = ((xy2[i].data + modular2::mod() - a) * r02r12.data + (modular2::mod() - b) * r12.data) % modular2::mod();",
            "\t\t\tres[i] = xy0[i].data + w1 * b + w2 * c;",
            "\t\t}",
            "\t\treturn res;",
            "\t}",
            "};",
            "template<class T> vector<T> number_theoric_transform_wrapper<T>::root;",
            "template<class T> vector<T> number_theoric_transform_wrapper<T>::buffer1;",
            "template<class T> vector<T> number_theoric_transform_wrapper<T>::buffer2;",
            "",
            "using ntt = number_theoric_transform_wrapper<modular>;"
        ],
        "description": "tranxuanbach"
    }
}