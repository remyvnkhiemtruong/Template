{
    "tranxuanbach": {
        "prefix": "binary_trie_split_merge",
        "body": [
            "// Solves https://codeforces.com/contest/1515/problem/H",
            "template<class T, int lim>",
            "class binary_trie_split_merge{",
            "private:",
            "\tT reversed(T x){",
            "\t\tT res = 0;",
            "\t\tfor(auto bit = 0; bit < lim; ++ bit) res = res << 1 | x & 1, x >>= 1;",
            "\t\treturn res;",
            "\t}",
            "public:",
            "\tstruct node{",
            "\t\tarray<shared_ptr<node>, 2> next;",
            "\t\tint count = 0;",
            "\t\tT lazy_xor = 0, sum_and = (1 << lim) - 1, sum_or = 0;",
            "\t};",
            "\tusing ptr = shared_ptr<node>;",
            "\tptr build(const vector<T> &a){",
            "\t\tptr root{new node()};",
            "\t\tfor(auto x: a){",
            "\t\t\tx = reversed(x);",
            "\t\t\tauto u = root;",
            "\t\t\tfor(auto bit = 0; bit < lim; ++ bit){",
            "\t\t\t\tauto &v = u->next[x >> bit & 1];",
            "\t\t\t\tif(!v) v = ptr{new node()};",
            "\t\t\t\tu = v;",
            "\t\t\t}",
            "\t\t\tu->count = 1;",
            "\t\t}",
            "\t\tauto dfs = [&](auto self, ptr u)->void{",
            "\t\t\tif(!u) return;",
            "\t\t\tfor(auto i = 0; i < 2; ++ i) self(self, u->next[i]);",
            "\t\t\trefresh(u);",
            "\t\t};",
            "\t\tdfs(dfs, root);",
            "\t\treturn root;",
            "\t}",
            "private:",
            "\tvoid apply(ptr u, T lazy_xor){",
            "\t\tif(!lazy_xor) return;",
            "\t\tT dif = (u->sum_and ^ u->sum_or) & lazy_xor ^ lazy_xor;",
            "\t\tu->sum_and ^= dif, u->sum_or ^= dif;",
            "\t}",
            "\tvoid push(ptr u){",
            "\t\tif(!u->lazy_xor) return;",
            "\t\tfor(auto i = 0; i < 2; ++ i) if(u->next[i]) u->next[i]->lazy_xor ^= u->lazy_xor >> 1, apply(u->next[i], u->lazy_xor >> 1);",
            "\t\tif(u->lazy_xor & 1) swap(u->next[0], u->next[1]);",
            "\t\tu->lazy_xor = 0;",
            "\t}",
            "\tvoid refresh(ptr u){",
            "\t\tu->count = 0, u->sum_and = (1 << lim) - 1, u->sum_or = 0;",
            "\t\tfor(auto i = 0; i < 2; ++ i) if(u->next[i]){",
            "\t\t\tu->count += u->next[i]->count;",
            "\t\t\tu->sum_and &= u->next[i]->sum_and << 1 | 1;",
            "\t\t\tu->sum_or |= u->next[i]->sum_or << 1;",
            "\t\t}",
            "\t\tif(u->next[0]) u->sum_and ^= 1;",
            "\t\tif(u->next[1]) u->sum_or ^= 1;",
            "\t\tu->sum_or &= (1 << lim) - 1;",
            "\t\tu->count += !u->next[0] && !u->next[1];",
            "\t\tapply(u, u->lazy_xor);",
            "\t}",
            "\t// O(lim), assumes the subtree of u is not empty",
            "\tT min_element(ptr u){",
            "\t\tassert(u->count);",
            "\t\tpush(u);",
            "\t\tif(u->next[0]) return min_element(u->next[0]) << 1;",
            "\t\telse if(u->next[1]) return min_element(u->next[1]) << 1 | 1;",
            "\t\telse return 0;",
            "\t}",
            "\t// O(lim), assumes the subtree of u is not empty",
            "\tT max_element(ptr u){",
            "\t\tassert(u->count);",
            "\t\tpush(u);",
            "\t\tif(u->next[1]) return max_element(u->next[1]) << 1 | 1;",
            "\t\telse if(u->next[0]) return max_element(u->next[0]) << 1;",
            "\t\telse return 0;",
            "\t}",
            "\t// If x is present, return it. Otherwise, return the closest number sharing the longest prefix with x",
            "\t// O(lim)",
            "\tT approximate(ptr u, T x){",
            "\t\tassert(u->count);",
            "\t\tif(!u->next[0] && !u->next[1]) return 0;",
            "\t\tpush(u);",
            "\t\tif(u->next[x & 1]) return approximate(u->next[x & 1], x >> 1) << 1 | x & 1;",
            "\t\telse if(x & 1) return max_element(u->next[0]) << 1;",
            "\t\telse return min_element(u->next[1]) << 1 | 1;",
            "\t}",
            "\t// Assumes x and its next is present, return the length of the largest prefix with next element",
            "\t// O(lim)",
            "\tint splitting_depth_with_next(ptr u, T x){",
            "\t\tif(!u->next[0] && !u->next[1]) return numeric_limits<int>::min();",
            "\t\tpush(u);",
            "\t\tif(x & 1) return splitting_depth_with_next(u->next[1], x >> 1) + 1;",
            "\t\telse{",
            "\t\t\tint res = splitting_depth_with_next(u->next[0], x >> 1) + 1;",
            "\t\t\tif(u->next[1]) res = max(res, 0);",
            "\t\t\treturn res;",
            "\t\t}",
            "\t}",
            "\t// Assumes x and its previous is present, return the length of the largest prefix with previous element",
            "\tint splitting_depth_with_prev(ptr u, T x){",
            "\t\tif(!u->next[0] && !u->next[1]) return numeric_limits<int>::min();",
            "\t\tpush(u);",
            "\t\tif(~x & 1) return splitting_depth_with_prev(u->next[0], x >> 1) + 1;",
            "\t\telse{",
            "\t\t\tint res = splitting_depth_with_prev(u->next[1], x >> 1) + 1;",
            "\t\t\tif(u->next[0]) res = max(res, 0);",
            "\t\t\treturn res;",
            "\t\t}",
            "\t}",
            "\tbool cmp(T x, T y){",
            "\t\tif(x == y) false;",
            "\t\tT z = (x ^ y) & -(x ^ y);",
            "\t\treturn (x & z) < (y & z);",
            "\t}",
            "public:",
            "\t// O(lim) time and O(lim) space",
            "\ttemplate<bool REVERSE = true>",
            "\tpair<ptr, ptr> split(ptr u, T x){",
            "\t\tif(REVERSE) x = reversed(x);",
            "\t\tif(!u->count || cmp(max_element(u), x)) return {u, ptr{new node()}};",
            "\t\telse if(!cmp(min_element(u), x)) return {ptr{new node()}, u};",
            "\t\tT y = approximate(u, x);",
            "\t\tint obj = cmp(y, x) ? splitting_depth_with_next(u, y) : splitting_depth_with_prev(u, y);",
            "\t\tauto recurse = [&](auto self, ptr u, T x, int depth)->array<ptr, 2>{",
            "\t\t\tif(depth == obj){",
            "\t\t\t\tptr v{new node()};",
            "\t\t\t\tswap(u->next[1], v->next[1]);",
            "\t\t\t\trefresh(u), refresh(v);",
            "\t\t\t\treturn {u, v};",
            "\t\t\t}",
            "\t\t\tauto t = self(self, u->next[x & 1], x >> 1, depth + 1);",
            "\t\t\tu->next[x & 1] = t[~x & 1], refresh(u);",
            "\t\t\tptr v{new node()};",
            "\t\t\tv->next[x & 1] = t[x & 1], refresh(v);",
            "\t\t\treturn x & 1 ? array{u, v} : array{v, u};",
            "\t\t};",
            "\t\tauto res = recurse(recurse, u, y, 0);",
            "\t\treturn {res[0], res[1]};",
            "\t}",
            "\tptr merge(ptr u, ptr v){",
            "\t\tif(!u || !v) return u ?: v;",
            "\t\tpush(u), push(v);",
            "\t\tu->next = {merge(u->next[0], v->next[0]), merge(u->next[1], v->next[1])};",
            "\t\trefresh(u);",
            "\t\treturn u;",
            "\t}",
            "\t// O(1)",
            "\ttemplate<bool REVERSE = true>",
            "\tptr update_bitwise_xor(ptr u, T x){",
            "\t\tif(REVERSE) x = reversed(x);",
            "\t\tu->lazy_xor ^= x, apply(u, x);",
            "\t\treturn u;",
            "\t}",
            "\t// Amortized O(lim^2)",
            "\ttemplate<bool REVERSE = true>",
            "\tptr update_bitwise_or(ptr u, T x){",
            "\t\tif(REVERSE) x = reversed(x);",
            "\t\tauto recurse = [&](auto self, ptr u, T x)->ptr{",
            "\t\t\tif(!u || x == (x & u->sum_and)) return u;",
            "\t\t\tpush(u);",
            "\t\t\tif(x & 1) u->next = {0, self(self, merge(u->next[0], u->next[1]), x >> 1)};",
            "\t\t\telse u->next = {self(self, u->next[0], x >> 1), self(self, u->next[1], x >> 1)};",
            "\t\t\trefresh(u);",
            "\t\t\treturn u;",
            "\t\t};",
            "\t\treturn recurse(recurse, update_bitwise_xor<false>(u, u->sum_or & x ^ x), x);",
            "\t}",
            "\t// Amortized O(lim^2)",
            "\ttemplate<bool REVERSE = true>",
            "\tptr update_bitwise_and(ptr u, T x){",
            "\t\tif(REVERSE) x = reversed(x);",
            "\t\treturn update_bitwise_xor<false>(update_bitwise_or<false>(update_bitwise_xor<false>(u, (1 << lim) - 1), (1 << lim) - 1 ^ x), (1 << lim) - 1);",
            "\t}",
            "\tvoid print(ptr u){",
            "\t\t#ifdef LOCAL",
            "\t\tstring s;",
            "\t\tauto dfs = [&](auto self, ptr u)->void{",
            "\t\t\tif(!u) return;",
            "\t\t\tpush(u);",
            "\t\t\tcerr << \"Node: \" << s << \"\\nCount: \" << u->count << \", and_sum: \" << bitset<lim>(u->sum_and) << \", or_sum: \" << bitset<lim>(u->sum_or) << endl;",
            "\t\t\tfor(auto i = 0; i < 2; ++ i){",
            "\t\t\t\ts.push_back('0' + i);",
            "\t\t\t\tself(self, u->next[i]);",
            "\t\t\t\ts.pop_back();",
            "\t\t\t}",
            "\t\t};",
            "\t\tdfs(dfs, u);",
            "\t\tcerr << endl;",
            "\t\t#endif",
            "\t}",
            "};"
        ],
        "description": "tranxuanbach"
    }
}