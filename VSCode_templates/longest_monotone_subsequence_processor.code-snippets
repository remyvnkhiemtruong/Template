{
    "tranxuanbach": {
        "prefix": "longest_monotone_subsequence_processor",
        "body": [
            "// Process the longest subsequence s0, ..., s(k-1) satisfying cmp(s0, s1) && ... && cmp(s(k-2), s(k-1))",
            "template<class T, class U = int, class Compare = less<>>",
            "struct longest_monotone_subsequence_processor{",
            "\tCompare cmp;",
            "\t// less: longest increasing subsequence",
            "\t// less_equal: longest non-decreasing subsequence",
            "\t// greater: longest decreasing subsequence",
            "\t// greater_equal: longest non-increasing subsequence",
            "\tint n = 0;",
            "\tvector<T> sequence;",
            "\tvector<int> active; // position of the optimal last element among monotone sequences of length i+1",
            "\tvector<int> prev; // second-to-last element of the longest monotone sequence ending at i, -1 if non exists",
            "\tvector<int> length; // length of the longest monotone subsequence ending at i",
            "\tvector<U> count; // number of the longest monotone subsequences ending at i",
            "\tvector<vector<int>> classes = vector<vector<int>>(1); // classes[len]: set of indices i where length[i] = len (in increasing order)",
            "\tvector<int> aux_it = vector<int>(1); // auxiliary position array for counting",
            "\tvector<U> aux_sum = vector<U>{1}; // auxiliary sum array for counting",
            "\tlongest_monotone_subsequence_processor(Compare cmp = less<>()){ }",
            "\tlongest_monotone_subsequence_processor(const vector<T> &a, Compare cmp = less<>()){",
            "\t\tinsert(a);",
            "\t}",
            "\tvoid insert(const vector<T> &a){",
            "\t\tfor(auto x: a) insert(x);",
            "\t}",
            "\tvoid insert(T x){ // O(log n)",
            "\t\tint i = n ++;",
            "\t\tsequence.push_back(x);",
            "\t\tprev.push_back(-1);",
            "\t\tlength.push_back(-1);",
            "\t\tcount.push_back(0);",
            "\t\tauto it = partition_point(active.begin(), active.end(), [&](int i){ return cmp(sequence[i], x); });",
            "\t\tif(it == active.end()){",
            "\t\t\tactive.emplace_back();",
            "\t\t\tclasses.emplace_back();",
            "\t\t\taux_it.emplace_back();",
            "\t\t\taux_sum.emplace_back();",
            "\t\t\tit = std::prev(active.end());",
            "\t\t}",
            "\t\t*it = i;",
            "\t\tprev[i] = it == active.begin() ? -1 : *std::prev(it);",
            "\t\tint len = length[i] = it - active.begin() + 1;",
            "\t\twhile(aux_it[len - 1] < (int)classes[len - 1].size() && !cmp(sequence[classes[len - 1][aux_it[len - 1]]], x)){",
            "\t\t\taux_sum[len - 1] -= count[classes[len - 1][aux_it[len - 1] ++]];",
            "\t\t}",
            "\t\tcount[i] = aux_sum[len - 1];",
            "\t\tclasses[len].push_back(i);",
            "\t\taux_sum[len] += count[i];",
            "\t}",
            "\tint lms_length() const{",
            "\t\treturn (int)active.size();",
            "\t}",
            "\tvector<int> lms_indices() const{",
            "\t\tint len = lms_length(), i = active.back();",
            "\t\tvector<int> res(len);",
            "\t\twhile(len --) res[len] = i, i = prev[i];",
            "\t\treturn res;",
            "\t}",
            "\tvector<T> lms() const{",
            "\t\tvector<T> res;",
            "\t\tres.reserve(lms_length());",
            "\t\tfor(auto i: lms_indices()) res.push_back(sequence[i]);",
            "\t\treturn res;",
            "\t}",
            "\tU lms_count() const{",
            "\t\tU res = 0;",
            "\t\tint len = lms_length();",
            "\t\tfor(auto i = 0; i < n; ++ i) if(length[i] == len) res += count[i];",
            "\t\treturn res;",
            "\t}",
            "};"
        ],
        "description": "tranxuanbach"
    }
}