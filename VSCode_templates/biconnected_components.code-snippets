{
    "tranxuanbach": {
        "prefix": "biconnected_components",
        "body": [
            "// Requires graph",
            "struct biconnected_components{",
            "\tint n, attempt, comp_attempt;",
            "\tvector<int> pos;",
            "\tvector<int> stack;",
            "\tvector<int> was;",
            "\tvector<int> comp_was;",
            "\t// block-cut tree descriptions",
            "\tvector<vector<int>> belongs; // vertex -> list of 2-vertex-connected components",
            "\tvector<vector<int>> comp_vertex; // list of vertices in a 2-vertex-connected component",
            "\tvector<vector<int>> comp_edge; // list of edges in a 2-vertex-connected component",
            "\tvector<int> bridge;",
            "\tbiconnected_components(){ }",
            "\tbiconnected_components(int n){ init(n); }",
            "\ttemplate<class T>",
            "\tbiconnected_components(const graph<T> &g){ init(g.n); run_all(g); }",
            "\tvoid init(int n){",
            "\t\tthis->n = n;",
            "\t\tpos.assign(n, -1);",
            "\t\twas.assign(n, -2);",
            "\t\tattempt = -1;",
            "\t\tcomp_was.assign(n, -2);",
            "\t\tcomp_attempt = -1;",
            "\t\tbelongs.assign(n, {});",
            "\t\tcomp_vertex.clear();",
            "\t\tcomp_edge.clear();",
            "\t\tbridge.clear();",
            "\t}",
            "\t// O(n + m) where n and m are the number of reachable nodes and edges respectively.",
            "\ttemplate<class T>",
            "\tvoid _run(const graph<T> &g, const vector<int> &src){",
            "\t\tint it = 0;",
            "\t\tauto recurse = [&](auto self, int u, int pe)->int{",
            "\t\t\tint low = pos[u] = ++ it;",
            "\t\t\tbelongs[u].clear();",
            "\t\t\twas[u] = attempt;",
            "\t\t\tfor(auto id: g.adj[u]){",
            "\t\t\t\tif(g.ignore && g.ignore(id) || id == pe) continue;",
            "\t\t\t\tint v = g(u, id);",
            "\t\t\t\tif(was[v] != attempt){",
            "\t\t\t\t\twas[v] = attempt;",
            "\t\t\t\t\tpos[v] = 0;",
            "\t\t\t\t}",
            "\t\t\t\tif(pos[v]){",
            "\t\t\t\t\tlow = min(low, pos[v]);",
            "\t\t\t\t\tif(pos[v] < pos[u]) stack.push_back(id);",
            "\t\t\t\t}",
            "\t\t\t\telse{",
            "\t\t\t\t\tint size = (int)stack.size(), up = self(self, v, id);",
            "\t\t\t\t\tlow = min(low, up);",
            "\t\t\t\t\tif(up == pos[u]){",
            "\t\t\t\t\t\t++ comp_attempt;",
            "\t\t\t\t\t\tstack.push_back(id);",
            "\t\t\t\t\t\tvector<int> comp_v;",
            "\t\t\t\t\t\tvector<int> comp_e(stack.begin() + size, stack.end());",
            "\t\t\t\t\t\tfor(auto id: comp_e){",
            "\t\t\t\t\t\t\tauto [u, v, _] = g.edge[id];",
            "\t\t\t\t\t\t\tif(comp_was[u] != comp_attempt){",
            "\t\t\t\t\t\t\t\tcomp_was[u] = comp_attempt;",
            "\t\t\t\t\t\t\t\tcomp_v.push_back(u);",
            "\t\t\t\t\t\t\t}",
            "\t\t\t\t\t\t\tif(comp_was[v] != comp_attempt){",
            "\t\t\t\t\t\t\t\tcomp_was[v] = comp_attempt;",
            "\t\t\t\t\t\t\t\tcomp_v.push_back(v);",
            "\t\t\t\t\t\t\t}",
            "\t\t\t\t\t\t}",
            "\t\t\t\t\t\tfor(auto u: comp_v) belongs[u].push_back((int)comp_vertex.size());",
            "\t\t\t\t\t\tcomp_vertex.push_back(move(comp_v));",
            "\t\t\t\t\t\tcomp_edge.push_back(move(comp_e));",
            "\t\t\t\t\t\tstack.resize(size);",
            "\t\t\t\t\t}",
            "\t\t\t\t\telse if(up < pos[u]) stack.push_back(id);",
            "\t\t\t\t\telse{",
            "\t\t\t\t\t\tbelongs[g.edge[id].from].push_back((int)comp_vertex.size());",
            "\t\t\t\t\t\tbelongs[g.edge[id].to].push_back((int)comp_vertex.size());",
            "\t\t\t\t\t\tcomp_vertex.push_back({g.edge[id].from, g.edge[id].to});",
            "\t\t\t\t\t\tcomp_edge.push_back({id});",
            "\t\t\t\t\t\tbridge.push_back(id);",
            "\t\t\t\t\t}",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t\treturn low;",
            "\t\t};",
            "\t\tfor(auto u: src) if(was[u] != attempt) recurse(recurse, u, -1);",
            "\t}",
            "\ttemplate<class T>",
            "\tvoid run(const graph<T> &g, const vector<int> &src){",
            "\t\tassert(g.n <= n);",
            "\t\tfor(auto u: src) assert(0 <= u && u < g.n);",
            "\t\tcomp_vertex.clear();",
            "\t\tcomp_edge.clear();",
            "\t\tbridge.clear();",
            "\t\t++ attempt;",
            "\t\t_run(g, src);",
            "\t}",
            "\ttemplate<class T>",
            "\tvoid run_all(const graph<T> &g){",
            "\t\tassert(g.n <= n);",
            "\t\tcomp_vertex.clear();",
            "\t\tcomp_edge.clear();",
            "\t\tbridge.clear();",
            "\t\t++ attempt;",
            "\t\tvector<int> src(g.n);",
            "\t\tiota(src.begin(), src.end(), 0);",
            "\t\t_run(g, src);",
            "\t}",
            "\t// Check if u is visited during the last run-like call.",
            "\tbool visited(int u) const{",
            "\t\tassert(0 <= u && u < n);",
            "\t\treturn was[u] == attempt;",
            "\t}",
            "\tbool is_articulation_point(int u) const{",
            "\t\tassert(0 <= u && u < n && visited(n));",
            "\t\treturn (int)belongs[u].size() >= 2;",
            "\t}",
            "\tbool is_bridge_component(int i) const{",
            "\t\tassert(0 <= i && i < (int)comp_vertex.size());",
            "\t\treturn (int)comp_edge[i].size() == 1;",
            "\t}",
            "\t// # of 2-vertex-connected components",
            "\tint count() const{",
            "\t\treturn (int)comp_vertex.size();",
            "\t}",
            "};"
        ],
        "description": "tranxuanbach"
    }
}