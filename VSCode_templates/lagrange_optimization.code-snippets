{
    "tranxuanbach": {
        "prefix": "lagrange_optimization",
        "body": [
            "// Implmentation of the lagrange optimization at https://koosaga.com/243",
            "// T f(T lambda, vector<int> &prev, vector<int> &cnt): Solve the dp augmented by lambda, store the previous state in prev and # of \"splits\" of each prefix in cnt. Should return the optimal cost.",
            "// n: length of the interval of our dp.",
            "// k: sought # of splits",
            "// lambda must lie in [low, high)",
            "// NOTE: the cost function must be multiplied by 2.",
            "// Returns {optimal_answer, array of sizes of prefix}",
            "// O(log MAXVAL) calls of f()",
            "template<class T, bool GET_MAX = true>",
            "pair<T, vector<int>> lagrange_optimization(int n, int k, auto f, T low, T high){",
            "\tT resp, resq;",
            "\tvector<int> prevp(n + 1), cntp(n + 1), prevq(n + 1), cntq(n + 1);",
            "\tauto pred = [&](T lambda){",
            "\t\tswap(resp, resq), swap(prevp, prevq), swap(cntp, cntq);",
            "\t\tresp = f(lambda, prevp, cntp);",
            "\t\treturn GET_MAX ? cntp.back() <= k : cntp.back() >= k;",
            "\t};",
            "\tfor(-- low; high - low >= 2; ){",
            "\t\tauto mid = low + (high - low >> 1);",
            "\t\t(pred(mid << 1 | 1) ? low : high) = mid;",
            "\t}",
            "\tT lambda = low << 1 | 1;",
            "\tpred(lambda + 2), pred(lambda);",
            "\tif(cntp.back() == k){",
            "\t\tvector<int> path{n};",
            "\t\tfor(auto u = n; u; ) path.push_back(u = prevp[u]);",
            "\t\treturn {resp - lambda * k >> 1, path};",
            "\t}",
            "\telse{",
            "\t\tresp = resp - lambda * cntp.back() >> 1;",
            "\t\tresq = resq - (lambda + 2) * cntq.back() >> 1;",
            "\t\tT res = resp + (resq - resp) / (cntq.back() - cntp.back()) * (k - cntp.back());",
            "\t\tint i = n, j = n, d = k - cntp.back();",
            "\t\twhile(true){",
            "\t\t\tif(prevp[i] <= prevq[j]){",
            "\t\t\t\twhile(prevp[i] <= prevq[j] && cntq[j] - cntp[i] > d) j = prevq[j];",
            "\t\t\t\tif(prevp[i] <= prevq[j] && cntq[j] - cntp[i] == d) break;",
            "\t\t\t}",
            "\t\t\telse i = prevp[i], j = prevq[j];",
            "\t\t}",
            "\t\tvector<int> path{n};",
            "\t\tfor(auto u = n; u != i; ) path.push_back(u = prevp[u]);",
            "\t\tpath.push_back(prevq[j]);",
            "\t\tfor(auto u = prevq[j]; u; ) path.push_back(u = prevq[u]);",
            "\t\treturn {res, path};",
            "\t}",
            "}"
        ],
        "description": "tranxuanbach"
    }
}