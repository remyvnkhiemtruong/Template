{
    "tranxuanbach": {
        "prefix": "chinese_remainder_theorem_coprime_fixed_width",
        "body": [
            "// Assumes all the mods are coprime to eachother",
            "// Requires modular",
            "template<class return_t, class... modular_ts>",
            "struct chinese_remainder_theorem_coprime_fixed_width{",
            "\tstatic constexpr size_t N = sizeof...(modular_ts);",
            "\ttemplate<size_t I>",
            "\tusing modular_t = tuple_element_t<I, tuple<modular_ts...>>;",
            "\ttuple<array<modular_ts, N>...> inverse;",
            "\ttemplate<size_t... Is>",
            "\tvoid _constexpr_for_impl(auto f, index_sequence<Is...>) const{",
            "\t\t(f(integral_constant<size_t, Is>{}), ...);",
            "\t}",
            "\ttemplate<size_t N>",
            "\tvoid _constexpr_for(auto f) const{",
            "\t\t_constexpr_for_impl(f, make_index_sequence<N>{});",
            "\t}",
            "\tarray<return_t, N + 1> mod_prefix;",
            "\tchinese_remainder_theorem_coprime_fixed_width(){",
            "\t\tmod_prefix[0] = 1;",
            "\t\t_constexpr_for<N>([&](auto i_t){",
            "\t\t\tconstexpr size_t i = i_t.value;",
            "\t\t\t_constexpr_for<i>([&](auto j_t){",
            "\t\t\t\tconstexpr size_t j = j_t.value;",
            "\t\t\t\tget<i>(inverse)[j] = modular_t<i>(1) / modular_t<j>::mod();",
            "\t\t\t});",
            "\t\t\tif constexpr(i >= 2) for(auto j = i - 1; j >= 1; -- j) get<i>(inverse)[j - 1] *= get<i>(inverse)[j];",
            "\t\t\tmod_prefix[i + 1] = mod_prefix[i] * modular_t<i>::mod();",
            "\t\t});",
            "\t}",
            "\treturn_t run(const tuple<modular_ts...> &rem) const{",
            "\t\treturn_t res = 0;",
            "\t\ttuple<modular_ts...> coef;",
            "\t\t_constexpr_for<N>([&](auto i_t){",
            "\t\t\tconstexpr size_t i = i_t.value;",
            "\t\t\tif constexpr(i == 0) get<i>(coef) = get<i>(rem);",
            "\t\t\telse{",
            "\t\t\t\tget<i>(coef) = get<i>(rem).data * get<i>(inverse)[0];",
            "\t\t\t\t_constexpr_for<i>([&](auto j_t){",
            "\t\t\t\t\tconstexpr size_t j = j_t.value;",
            "\t\t\t\t\tget<i>(coef) -= get<j>(coef).data * get<i>(inverse)[j];",
            "\t\t\t\t});",
            "\t\t\t}",
            "\t\t\tif constexpr(i == 0) res += get<i>(coef).data;",
            "\t\t\telse res += get<i>(coef).data * mod_prefix[i];",
            "\t\t});",
            "\t\treturn res;",
            "\t}",
            "\treturn_t run(const modular_ts &... rems) const{",
            "\t\treturn run(tuple<modular_ts...>{rems...});",
            "\t}",
            "};"
        ],
        "description": "tranxuanbach"
    }
}