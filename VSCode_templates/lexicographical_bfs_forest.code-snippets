{
    "tranxuanbach": {
        "prefix": "lexicographical_bfs_forest",
        "body": [
            "// Requires graph",
            "struct lexicographical_bfs_forest{",
            "\tint n;",
            "\tvector<int> pos, order, was, latest, slice_size;",
            "\tvector<vector<int>> cell_sizes;",
            "\tlexicographical_bfs_forest(int n){",
            "\t\tinit(n);",
            "\t}",
            "\tvoid init(int n){",
            "\t\tthis->n = n;",
            "\t\torder.clear();",
            "\t\tpos.assign(n, -1);",
            "\t\twas.assign(n, -1);",
            "\t\tlatest.assign(n, -1); // latest neighbour preceeding current node in ordering",
            "\t\tslice_size.assign(n, -1);",
            "\t\tcell_sizes.assign(n, vector<int>{});",
            "\t\tattempt = 0;",
            "\t}",
            "\tint attempt;",
            "\t// Perform lexicographical bfs with tie broken by the initial order",
            "\t// O(|V| + |E|)",
            "\ttemplate<class T>",
            "\tvoid bfs(const graph<T> &g, const vector<int> &initial_order, bool complement = false){",
            "\t\t++ attempt;",
            "\t\torder.clear();",
            "\t\tfor(auto &v: cell_sizes) v.clear();",
            "\t\tvector<vector<int>> adj(n); // adj list sorted by the initial ordering",
            "\t\tfor(auto u: initial_order) for(auto id: g.adj[u]){",
            "\t\t\tif(g.ignore && g.ignore(id)) continue;",
            "\t\t\tadj[g(u, id)].push_back(u);",
            "\t\t}",
            "\t\tint n = g.n;",
            "\t\tusing set_type = pair<list<int>, int>;",
            "\t\tlist<set_type> sets({{list<int>(initial_order.begin(), initial_order.end()), 0}});",
            "\t\tvector<list<set_type>::iterator> belongs(n, sets.begin());",
            "\t\tvector<list<int>::iterator> pos_in_set(n, sets.front().first.begin());",
            "\t\tfor(auto i = 1; i < n; ++ i) pos_in_set[initial_order[i]] = next(pos_in_set[initial_order[i - 1]]);",
            "\t\tvector<vector<array<int, 2>>> query_cell_sizes(n + 1);",
            "\t\tfor(auto it = 1; !sets.empty(); ++ it){",
            "\t\t\tint u = sets.front().first.front(), cnt = count_if(adj[u].begin(), adj[u].end(), [&](int v){ return was[v] != attempt && belongs[u] == belongs[v]; });",
            "\t\t\tslice_size[u] = (int)sets.front().first.size();",
            "\t\t\tif(complement) cnt = slice_size[u] - 1 - cnt;",
            "\t\t\tassert((int)order.size() + 1 + cnt <= n);",
            "\t\t\tif(slice_size[u] != cnt + 1) query_cell_sizes[(int)order.size() + 1 + cnt].push_back({u, slice_size[u] - 1 - cnt});",
            "\t\t\tfor(auto [u, sz]: query_cell_sizes[(int)order.size()]){",
            "\t\t\t\tint sum = 0;",
            "\t\t\t\tfor(auto it = sets.begin(); it != sets.end(); ++ it){",
            "\t\t\t\t\tsum += (int)it->first.size();",
            "\t\t\t\t\tcell_sizes[u].push_back((int)it->first.size());",
            "\t\t\t\t\tif(sum >= sz) break;",
            "\t\t\t\t}",
            "\t\t\t\tassert(sum == sz);",
            "\t\t\t}",
            "\t\t\tsets.front().first.pop_front();",
            "\t\t\tif(sets.front().first.empty()) sets.pop_front();",
            "\t\t\twas[u] = attempt;",
            "\t\t\tpos[u] = (int)order.size();",
            "\t\t\torder.push_back(u);",
            "\t\t\tfor(auto v: adj[u]){",
            "\t\t\t\tif(was[v] == attempt){",
            "\t\t\t\t\tif(!~latest[u] || pos[latest[u]] < pos[v]) latest[u] = v;",
            "\t\t\t\t\tcontinue;",
            "\t\t\t\t}",
            "\t\t\t\tlist<set_type>::iterator move_from = belongs[v], move_to;",
            "\t\t\t\tif(move_from->second != it){",
            "\t\t\t\t\tmove_from->second = it;",
            "\t\t\t\t\tmove_to = complement ? sets.insert(next(move_from), set_type{}) : sets.insert(move_from, set_type{});",
            "\t\t\t\t}",
            "\t\t\t\telse move_to = complement ? next(move_from) : prev(move_from);",
            "\t\t\t\tmove_from->first.erase(pos_in_set[v]);",
            "\t\t\t\tbelongs[v] = move_to;",
            "\t\t\t\tpos_in_set[v] = move_to->first.insert(move_to->first.end(), v);",
            "\t\t\t\tif(move_from->first.empty()) sets.erase(move_from);",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "\ttemplate<class T>",
            "\tvoid bfs(const graph<T> &g, bool complement = false){",
            "\t\tvector<int> initial_order(n);",
            "\t\tiota(initial_order.begin(), initial_order.end(), 0);",
            "\t\tbfs(g, initial_order, complement);",
            "\t}",
            "};"
        ],
        "description": "tranxuanbach"
    }
}