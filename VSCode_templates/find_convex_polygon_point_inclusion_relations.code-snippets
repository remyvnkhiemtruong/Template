{
    "tranxuanbach": {
        "prefix": "find_convex_polygon_point_inclusion_relations",
        "body": [
            "// Given a set of disjoint convex polygons, given in CCW, and points, determine the inclusion relation",
            "// n-th convex polygon is an auxiliary square of infinite size",
            "// polygon_inclusion(i, j): polygon i directly contains polygon j",
            "// point_inclusion(i, j): polygon i directly contains point j",
            "// B_large must be able to hold up to cube of coordinates",
            "// O(p * log(p)) where p is the number of total points",
            "template<class B, class B_large = __int128_t>",
            "void find_convex_polygon_point_inclusion_relations(const vector<vector<array<B, 2>>> &polygon, const vector<array<B, 2>> &point, auto polygon_inclusion, auto point_inclusion){",
            "\tint n = (int)polygon.size(), m = (int)point.size();",
            "\tvector<int> pv(n, -1);",
            "\t// x, 0, i, j : lower polygon    (i,j)->(i,j+1)",
            "\t// x, 1, i, j : upper polygon    (i,j+1)->(i,j)",
            "\t// x, 2, i, j : polygon deletion",
            "\t// x, 3, i    : locate point",
            "\tvector<tuple<B, int, int, int>> event;",
            "\tauto next = [&](int i, int j)->int{",
            "\t\treturn j + 1 < (int)polygon[i].size() ? j + 1 : 0;",
            "\t};",
            "\tfor(auto i = 0; i < n; ++ i){",
            "\t\tassert(polygon[i].size() >= 3);",
            "\t\tint j = min_element(polygon[i].begin(), polygon[i].end()) - polygon[i].begin();",
            "\t\tB xlow = polygon[i][j][0];",
            "\t\tB xhigh = (*max_element(polygon[i].begin(), polygon[i].end()))[0];",
            "\t\tif(polygon[i][next(i, j)][0] == polygon[i][j][0]) j = next(i, j);",
            "\t\tfor(; polygon[i][j][0] != xhigh; j = next(i, j)) event.push_back({polygon[i][j][0], 0, i, j});",
            "\t\tevent.push_back({xhigh, 2, i, j});",
            "\t\tif(polygon[i][next(i, j)][0] == xhigh) j = next(i, j);",
            "\t\tevent.push_back({xhigh, 2, i, j});",
            "\t\tfor(; polygon[i][j][0] != xlow; j = next(i, j)) event.push_back({polygon[i][next(i, j)][0], 1, i, j});",
            "\t}",
            "\tfor(auto i = 0; i < m; ++ i){",
            "\t\tauto [x, y] = point[i];",
            "\t\tevent.push_back({x, 3, i, -1});",
            "\t}",
            "\tsort(event.begin(), event.end(), [&](auto e, auto f){",
            "\t\tif(get<0>(e) != get<0>(f)){",
            "\t\t\treturn get<0>(e) < get<0>(f);",
            "\t\t}",
            "\t\tint te = max(get<1>(e) - 1, 0), tf = max(get<1>(f) - 1, 0);",
            "\t\treturn te != tf ? te < tf : get<2>(e) < get<2>(f);",
            "\t});",
            "\tB X, Y;",
            "\tusing T = array<int, 3>; // id, ind, type(lower, upper)",
            "\tauto cmp = [&](const T &a, const T &b)->bool{",
            "\t\tauto [i, indi, ti] = a;",
            "\t\tauto [j, indj, tj] = b;",
            "\t\tif(i == j) return ti < tj;",
            "\t\tarray<B, 2> fromi, di, fromj, dj;",
            "\t\tfor(auto rep = 2; rep; -- rep){",
            "\t\t\tif(~i){",
            "\t\t\t\tif(!ti){",
            "\t\t\t\t\tfromi = polygon[i][indi];",
            "\t\t\t\t\tdi = polygon[i][next(i, indi)];",
            "\t\t\t\t}",
            "\t\t\t\telse{",
            "\t\t\t\t\tfromi = polygon[i][next(i, indi)];",
            "\t\t\t\t\tdi = polygon[i][indi];",
            "\t\t\t\t}",
            "\t\t\t\tfor(auto t = 0; t < 2; ++ t) di[t] -= fromi[t];",
            "\t\t\t}",
            "\t\t\telse{",
            "\t\t\t\tfromi = {X, Y};",
            "\t\t\t\tdi = {1, 0};",
            "\t\t\t}",
            "\t\t\tassert(di[0]);",
            "\t\t\tswap(i, j), swap(indi, indj), swap(ti, tj), swap(fromi, fromj), swap(di, dj);",
            "\t\t}",
            "\t\treturn (B_large(fromi[1]) * di[0] + B_large(X - fromi[0]) * di[1]) * dj[0] < (B_large(fromj[1]) * dj[0] + B_large(X - fromj[0]) * dj[1]) * di[0];",
            "\t};",
            "\tmultiset<T, decltype(cmp)> sweepline(cmp);",
            "\tfor(auto [xpos, type, i, j]: event){",
            "\t\tX = xpos;",
            "\t\tif(type == 0){",
            "\t\t\tT e{i, j, type};",
            "\t\t\tauto it = sweepline.lower_bound(e);",
            "\t\t\tif(it == sweepline.end() || cmp(e, *it)){",
            "\t\t\t\t// start of a polygon",
            "\t\t\t\tpv[i] = it != sweepline.begin() ? (*prev(it))[2] ? pv[(*prev(it))[0]] : (*prev(it))[0] : n;",
            "\t\t\t\tpolygon_inclusion(pv[i], i);",
            "\t\t\t\tsweepline.insert(it, e);",
            "\t\t\t}",
            "\t\t\telse sweepline.insert(sweepline.erase(it), e);",
            "\t\t}",
            "\t\telse if(type == 1){",
            "\t\t\tT e{i, j, type};",
            "\t\t\tauto it = sweepline.lower_bound(e);",
            "\t\t\tsweepline.insert(it != sweepline.end() && !cmp(e, *it) ? sweepline.erase(it) : it, e);",
            "\t\t}",
            "\t\telse if(type == 2){",
            "\t\t\tT e{-1, -1, 2};",
            "\t\t\tY = polygon[i][j][1];",
            "\t\t\tauto it = sweepline.lower_bound(e);",
            "\t\t\tassert(it != sweepline.end());",
            "\t\t\tsweepline.erase(it);",
            "\t\t}",
            "\t\telse{",
            "\t\t\tT e{-1, -1, 2};",
            "\t\t\tY = point[i][1];",
            "\t\t\tauto it = sweepline.lower_bound(e);",
            "\t\t\tif(it != sweepline.begin()){",
            "\t\t\t\tit = prev(it);",
            "\t\t\t\tint j = (*it)[0];",
            "\t\t\t\tpoint_inclusion((*it)[2] == 0 ? j : pv[j], i);",
            "\t\t\t}",
            "\t\t\telse point_inclusion(n, i);",
            "\t\t}",
            "\t}",
            "}"
        ],
        "description": "tranxuanbach"
    }
}