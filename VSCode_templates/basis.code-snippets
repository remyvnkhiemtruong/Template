{
    "tranxuanbach": {
        "prefix": "basis",
        "body": [
            "template<class T, T (*zero)(), T (*one)()>",
            "struct basis_base{",
            "\tint width, count = 0;",
            "\tvector<vector<T>> data;",
            "\tvector<int> pivot;",
            "\tstruct modifier_type{",
            "\t\tint type;",
            "\t\t// Type 0: row[to] += row[from] * val",
            "\t\t// Type 1: row[to] *= val",
            "\t\t// Type 2: insert row[from] into row[to]",
            "\t\tint from, to;",
            "\t\tT val;",
            "\t};",
            "\tvector<modifier_type> log;",
            "\tbasis_base(int width, const vector<vector<T>> &a = {}): width(width){",
            "\t\tfor(auto &v: a) insert(v);",
            "\t}",
            "\t// O(1)",
            "\tint rank() const{",
            "\t\treturn (int)data.size();",
            "\t}",
            "\t// O(rank * width)",
            "\tvector<T> reduce(vector<T> v) const{",
            "\t\tassert((int)v.size() == width);",
            "\t\tfor(auto i = 0; i < rank(); ++ i) if(v[pivot[i]] != zero()){",
            "\t\t\tT x = v[pivot[i]];",
            "\t\t\tfor(auto j = 0; j <= pivot[i]; ++ j) v[j] -= x * data[i][j];",
            "\t\t}",
            "\t\treturn v;",
            "\t}",
            "\t// Insert a row while maintaining the lower triangular form",
            "\t// O(rank * width + multiplicative_inverse())",
            "\tbool insert(vector<T> v){",
            "\t\tassert((int)v.size() == width);",
            "\t\tfor(auto i = 0; i < rank(); ++ i) if(v[pivot[i]] != zero()){",
            "\t\t\tT x = v[pivot[i]];",
            "\t\t\tfor(auto j = 0; j <= pivot[i]; ++ j) v[j] -= x * data[i][j];",
            "\t\t\tlog.push_back({0, i, count, -x});",
            "\t\t}",
            "\t\tint p  = -1;",
            "\t\tfor(auto j = width - 1; j >= 0; -- j) if(v[j] != zero()){",
            "\t\t\tp = j;",
            "\t\t\tbreak;",
            "\t\t}",
            "\t\tif(!~p) return ++ count, false;",
            "\t\tif(v[p] != one()){",
            "\t\t\tT inv = one() / v[p];",
            "\t\t\tfor(auto j = 0; j <= p; ++ j) v[j] *= inv;",
            "\t\t\tlog.push_back({1, -1, count, inv});",
            "\t\t}",
            "\t\tfor(auto i = 0; i < rank(); ++ i) if(data[i][p] != zero()){",
            "\t\t\tT x = data[i][p];",
            "\t\t\tfor(auto j = 0; j <= p; ++ j) data[i][j] -= x * v[j];",
            "\t\t\tlog.push_back({0, count, i, -x});",
            "\t\t}",
            "\t\tint t = lower_bound(pivot.begin(), pivot.end(), p) - pivot.begin();",
            "\t\tpivot.insert(pivot.begin() + t, p);",
            "\t\tdata.insert(data.begin() + t, v);",
            "\t\tlog.push_back({2, count, t, zero()});",
            "\t\t++ count;",
            "\t\treturn true;",
            "\t}",
            "\t// Returns {",
            "\t//  lexicographically_smallest_sol,",
            "\t//  sol_basis_vector_1,",
            "\t//  ...,",
            "\t//  sol_basis_vector_k",
            "\t// }",
            "\t// O(rank * width)",
            "\ttemplate<bool construct_solution = true>",
            "\toptional<vector<vector<T>>> solve(vector<T> b) const{",
            "\t\tassert(count == (int)b.size());",
            "\t\tfor(auto &m: log){",
            "\t\t\tif(m.type == 0) b[m.to] += b[m.from] * m.val;",
            "\t\t\telse if(m.type == 1) b[m.to] *= m.val;",
            "\t\t\telse rotate(b.begin() + m.to, b.begin() + m.from, b.begin() + m.from + 1);",
            "\t\t}",
            "\t\tfor(auto i = rank(); i < count; ++ i) if(b[i] != zero()) return {};",
            "\t\tif(!construct_solution) return {{}};",
            "\t\tvector<vector<T>> res({vector<T>(width, zero())});",
            "\t\tvector<int> is_free(width, true);",
            "\t\tfor(auto i = 0; i < rank(); ++ i) res[0][pivot[i]] = b[i], is_free[pivot[i]] = false;",
            "\t\tfor(auto j = 0; j < width; ++ j) if(is_free[j]){",
            "\t\t\tvector<T> v(width, zero());",
            "\t\t\tv[j] = one();",
            "\t\t\tfor(auto i = rank() - 1; i >= 0 && pivot[i] > j; -- i) v[pivot[i]] = -data[i][j];",
            "\t\t\tres.push_back(v);",
            "\t\t}",
            "\t\treturn res;",
            "\t}",
            "};",
            "",
            "template<class T> T ZERO(){",
            "\treturn 0;",
            "}",
            "template<class T> T ONE(){",
            "\treturn 1;",
            "}",
            "template<class T> using basis = basis_base<T, ZERO<T>, ONE<T>>;"
        ],
        "description": "tranxuanbach"
    }
}