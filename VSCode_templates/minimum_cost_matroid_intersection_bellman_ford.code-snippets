{
    "tranxuanbach": {
        "prefix": "minimum_cost_matroid_intersection_bellman_ford",
        "body": [
            "// Requires matroid",
            "template<class T>",
            "struct minimum_cost_matroid_intersection_bellman_ford{",
            "\tint n;",
            "\tvector<int> state;",
            "\tminimum_cost_matroid_intersection_bellman_ford(int n): n(n), state(n), dist(n + 1), pv(n + 1){ }",
            "\tvector<pair<T, int>> dist;",
            "\tvector<tuple<int, int, T>> edge;",
            "\tvector<int> pv;",
            "\ttemplate<class M1, class M2>",
            "\tbool augment(const vector<T> &cost, M1 &m1, M2 &m2){",
            "\t\tfill(dist.begin(), dist.end(), pair<T, int>{numeric_limits<T>::max() / 2, 0});",
            "\t\tedge.clear();",
            "\t\tfill(pv.begin(), pv.end(), -1);",
            "\t\tm1.clear();",
            "\t\tm2.clear();",
            "\t\tfor(auto u = 0; u < n; ++ u) if(state[u]){",
            "\t\t\tm1.insert(u);",
            "\t\t\tm2.insert(u);",
            "\t\t}",
            "\t\tfor(auto u = 0; u < n; ++ u) if(!state[u]){",
            "\t\t\tif(m1.check(u)) dist[pv[u] = u] = {cost[u], 0};",
            "\t\t\tif(m2.check(u)) edge.emplace_back(u, n, 0);",
            "\t\t}",
            "\t\tfor(auto u = 0; u < n; ++ u) if(state[u]){",
            "\t\t\tm1.clear();",
            "\t\t\tm2.clear();",
            "\t\t\tfor(auto v = 0; v < n; ++ v) if(u != v && state[v]){",
            "\t\t\t\tm1.insert(v);",
            "\t\t\t\tm2.insert(v);",
            "\t\t\t}",
            "\t\t\tfor(auto v = 0; v < n; ++ v) if(!state[v]){",
            "\t\t\t\tif(m1.check(v)) edge.push_back({u, v, cost[v]});",
            "\t\t\t\tif(m2.check(v)) edge.push_back({v, u, -cost[u]});",
            "\t\t\t}",
            "\t\t}",
            "\t\tfor(auto changed = true; changed; ){",
            "\t\t\tchanged = false;",
            "\t\t\tfor(auto [u, v, w]: edge){",
            "\t\t\t\tpair<T, int> dist_next{dist[u].first + w, dist[u].second + 1};",
            "\t\t\t\tif(~pv[u] && dist_next < dist[v]){",
            "\t\t\t\t\tdist[v] = dist_next;",
            "\t\t\t\t\tpv[v] = u;",
            "\t\t\t\t\tchanged = true;",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t}",
            "\t\tif(!~pv[n]) return false;",
            "\t\tfor(auto u = pv[n]; ; u = pv[u]){",
            "\t\t\tstate[u] ^= 1;",
            "\t\t\tif(pv[u] == u) break;",
            "\t\t}",
            "\t\treturn true;",
            "\t}",
            "\t/*",
            "\t---------------------------------------------",
            "\t| # of member function calls where          |",
            "\t| r is the size of the answer and           |",
            "\t| N is the size of the ground set           |",
            "\t---------------------------------------------",
            "\t| Member Function | M1         | M2         |",
            "\t---------------------------------------------",
            "\t| insert()        | O(r^3)     | O(r^2 * n) |",
            "\t| check()         | O(r^2 * n) | O(r^2 * n) |",
            "\t| clear()         | O(r^2)     | O(r * n)   |",
            "\t---------------------------------------------",
            "\t*/",
            "\ttemplate<class M1, class M2>",
            "\tvector<int> minimum_cost_maximum_common_independent_set(const vector<T> &cost, M1 m1, M2 m2){",
            "\t\tfill(state.begin(), state.end(), false);",
            "\t\twhile(augment<M1, M2>(cost, m1, m2));",
            "\t\tvector<int> res;",
            "\t\tfor(auto u = 0; u < n; ++ u) if(state[u]) res.push_back(u);",
            "\t\treturn res;",
            "\t}",
            "};"
        ],
        "description": "tranxuanbach"
    }
}