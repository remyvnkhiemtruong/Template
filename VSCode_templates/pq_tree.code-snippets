{
    "tranxuanbach": {
        "prefix": "pq_tree",
        "body": [
            "// Implmemtation of https://www.sciencedirect.com/science/article/pii/S0022000076800451",
            "struct pq_tree{",
            "\tint n;",
            "\tbool is_null_tree = false;",
            "\tvector<vector<int>> adj;",
            "\t/*",
            "\t\tFor internal nodes, data indicates whether current node is P node(stores 0) or Q node(stores 1).",
            "\t\tFor leaf nodes, data represents the value",
            "\t*/",
            "\tvector<int> data;",
            "\tpq_tree(int n): n(n), adj(n + 1), data(n + 1), label(n + 1), in_s(n){",
            "\t\tadj[0].resize(n);",
            "\t\tiota(adj[0].begin(), adj[0].end(), 1);",
            "\t\tiota(data.begin() + 1, data.end(), 0);",
            "\t}",
            "\toperator bool(){",
            "\t\treturn !is_null_tree;",
            "\t}",
            "\tint new_node(int type, int state){",
            "\t\tadj.emplace_back();",
            "\t\tdata.push_back(type);",
            "\t\tlabel.push_back(state);",
            "\t\treturn (int)adj.size() - 1;",
            "\t}",
            "\t/*",
            "\t\tLabel",
            "\t\t0: empty",
            "\t\t1: full",
            "\t\t2: partial",
            "\t*/",
            "\tvector<int> label, in_s;",
            "\t// O(n^2)",
            "\tbool reduce(const vector<int> &s){",
            "\t\tif(is_null_tree) return false;",
            "\t\tif((int)s.size() == 1) return true;",
            "\t\tfill(in_s.begin(), in_s.end(), false);",
            "\t\tfor(auto x: s) in_s[x] = true;",
            "\t\tbool done = false;",
            "\t\tauto dfs = [&](auto self, int u)->int{",
            "\t\t\tif(adj[u].empty()){",
            "\t\t\t\t// Leaf node",
            "\t\t\t\treturn label[u] = in_s[data[u]];",
            "\t\t\t}",
            "\t\t\tint deg = (int)adj[u].size(), pertinence = 0;",
            "\t\t\tarray<int, 3> count{};",
            "\t\t\tfor(auto v: adj[u]){",
            "\t\t\t\tpertinence += self(self, v);",
            "\t\t\t\tif(is_null_tree || done) return 0;",
            "\t\t\t\t++ count[label[v]];",
            "\t\t\t}",
            "\t\t\tbool is_root = pertinence == (int)s.size();",
            "\t\t\tif(data[u] == 0){",
            "\t\t\t\t// P node",
            "\t\t\t\tif(count[0] == deg){",
            "\t\t\t\t\t// Template P0",
            "\t\t\t\t\tlabel[u] = 0;",
            "\t\t\t\t}",
            "\t\t\t\telse if(count[1] == deg){",
            "\t\t\t\t\t// Template P1",
            "\t\t\t\t\tlabel[u] = 1;",
            "\t\t\t\t}",
            "\t\t\t\telse if(count[0] + count[1] == deg){",
            "\t\t\t\t\tif(is_root){",
            "\t\t\t\t\t\t// Template P2",
            "\t\t\t\t\t\tint u2 = new_node(0, 1);",
            "\t\t\t\t\t\tauto it = partition(adj[u].begin(), adj[u].end(), [&](int v){ return label[v] == 0; });",
            "\t\t\t\t\t\tmove(it, adj[u].end(), back_inserter(adj[u2]));",
            "\t\t\t\t\t\tadj[u].erase(it, adj[u].end());",
            "\t\t\t\t\t\tadj[u].push_back(u2);",
            "\t\t\t\t\t}",
            "\t\t\t\t\telse{",
            "\t\t\t\t\t\t// Template P3",
            "\t\t\t\t\t\tarray<int, 2> v;",
            "\t\t\t\t\t\tfor(auto t = 0; t < 2; ++ t){",
            "\t\t\t\t\t\t\tif(count[t] == 1){",
            "\t\t\t\t\t\t\t\tv[t] = *find_if(adj[u].begin(), adj[u].end(), [&](int v){ return label[v] == t; });",
            "\t\t\t\t\t\t\t}",
            "\t\t\t\t\t\t\telse{",
            "\t\t\t\t\t\t\t\tv[t] = new_node(0, t);",
            "\t\t\t\t\t\t\t\tauto it = partition(adj[u].begin(), adj[u].end(), [&](int v){ return label[v] != t; });",
            "\t\t\t\t\t\t\t\tmove(it, adj[u].end(), back_inserter(adj[v[t]]));",
            "\t\t\t\t\t\t\t}",
            "\t\t\t\t\t\t}",
            "\t\t\t\t\t\tadj[u] = {v[0], v[1]};",
            "\t\t\t\t\t\tdata[u] = 1;",
            "\t\t\t\t\t\tlabel[u] = 2;",
            "\t\t\t\t\t}",
            "\t\t\t\t}",
            "\t\t\t\telse if(count[2] == 1){",
            "\t\t\t\t\tif(is_root){",
            "\t\t\t\t\t\t// Template P4",
            "\t\t\t\t\t\tif(auto it = partition(adj[u].begin(), adj[u].end(), [&](int v){ return label[v] != 1; }); adj[u].end() - it >= 2){",
            "\t\t\t\t\t\t\tint u2 = new_node(0, 1);",
            "\t\t\t\t\t\t\tmove(it, adj[u].end(), back_inserter(adj[u2]));",
            "\t\t\t\t\t\t\tadj[u].erase(it, adj[u].end());",
            "\t\t\t\t\t\t\tfor(auto v: adj[u]){",
            "\t\t\t\t\t\t\t\tif(label[v] == 2){",
            "\t\t\t\t\t\t\t\t\tif(label[adj[v].back()] != 1) reverse(adj[v].begin(), adj[v].end());",
            "\t\t\t\t\t\t\t\t\tadj[v].push_back(u2);",
            "\t\t\t\t\t\t\t\t\tbreak;",
            "\t\t\t\t\t\t\t\t}",
            "\t\t\t\t\t\t\t}",
            "\t\t\t\t\t\t}",
            "\t\t\t\t\t\telse if(adj[u].end() - it == 1){",
            "\t\t\t\t\t\t\tint u2 = adj[u].back();",
            "\t\t\t\t\t\t\tadj[u].pop_back();",
            "\t\t\t\t\t\t\tfor(auto v: adj[u]){",
            "\t\t\t\t\t\t\t\tif(label[v] == 2){",
            "\t\t\t\t\t\t\t\t\tif(label[adj[v].back()] != 1) reverse(adj[v].begin(), adj[v].end());",
            "\t\t\t\t\t\t\t\t\tadj[v].push_back(u2);",
            "\t\t\t\t\t\t\t\t\tbreak;",
            "\t\t\t\t\t\t\t\t}",
            "\t\t\t\t\t\t\t}",
            "\t\t\t\t\t\t}",
            "\t\t\t\t\t\tif(count[0] == 0){",
            "\t\t\t\t\t\t\tint v = adj[u][0];",
            "\t\t\t\t\t\t\tadj[u] = adj[v];",
            "\t\t\t\t\t\t\tadj[v].clear();",
            "\t\t\t\t\t\t\tdata[u] = 1;",
            "\t\t\t\t\t\t\tlabel[u] = 2;",
            "\t\t\t\t\t\t}",
            "\t\t\t\t\t}",
            "\t\t\t\t\telse{",
            "\t\t\t\t\t\t// Template P5",
            "\t\t\t\t\t\tarray<int, 2> v{-1, -1};",
            "\t\t\t\t\t\tfor(auto t = 0; t < 2; ++ t){",
            "\t\t\t\t\t\t\tif(count[t] == 1) v[t] = *find_if(adj[u].begin(), adj[u].end(), [&](int v){ return label[v] == t; });",
            "\t\t\t\t\t\t\telse if(count[t] >= 2){",
            "\t\t\t\t\t\t\t\tv[t] = new_node(0, t);",
            "\t\t\t\t\t\t\t\tfor(auto w: adj[u]) if(label[w] == t) adj[v[t]].push_back(w);",
            "\t\t\t\t\t\t\t}",
            "\t\t\t\t\t\t}",
            "\t\t\t\t\t\tint pu = *find_if(adj[u].begin(), adj[u].end(), [&](int v){ return label[v] == 2; });",
            "\t\t\t\t\t\tif(label[adj[pu][0]]) reverse(adj[pu].begin(), adj[pu].end());",
            "\t\t\t\t\t\tadj[u].clear();",
            "\t\t\t\t\t\tif(~v[0]) adj[u].push_back(v[0]);",
            "\t\t\t\t\t\tmove(adj[pu].begin(), adj[pu].end(), back_inserter(adj[u]));",
            "\t\t\t\t\t\tif(~v[1]) adj[u].push_back(v[1]);",
            "\t\t\t\t\t\tdata[u] = 1;",
            "\t\t\t\t\t\tlabel[u] = 2;",
            "\t\t\t\t\t}",
            "\t\t\t\t}",
            "\t\t\t\telse if(count[2] == 2 && is_root){",
            "\t\t\t\t\t// Template P6",
            "\t\t\t\t\tint v = -1;",
            "\t\t\t\t\tif(count[1] == 1){",
            "\t\t\t\t\t\tauto it = find_if(adj[u].begin(), adj[u].end(), [&](int v){ return label[v] == 1; });",
            "\t\t\t\t\t\tv = *it;",
            "\t\t\t\t\t\tadj[u].erase(it);",
            "\t\t\t\t\t}",
            "\t\t\t\t\telse if(count[1] >= 2){",
            "\t\t\t\t\t\tv = new_node(0, 1);",
            "\t\t\t\t\t\tauto it = partition(adj[u].begin(), adj[u].end(), [&](int v){ return label[v] != 1; });",
            "\t\t\t\t\t\tmove(it, adj[u].end(), back_inserter(adj[v]));",
            "\t\t\t\t\t\tadj[u].erase(it, adj[u].end());",
            "\t\t\t\t\t}",
            "\t\t\t\t\tarray<int, 2> w;",
            "\t\t\t\t\tauto it = find_if(adj[u].begin(), adj[u].end(), [&](int v){ return label[v] == 2; });",
            "\t\t\t\t\tw[0] = *it;",
            "\t\t\t\t\tit = find_if(next(it), adj[u].end(), [&](int v){ return label[v] == 2; });",
            "\t\t\t\t\tw[1] = *it;",
            "\t\t\t\t\tif(label[adj[w[0]][0]] != 0) reverse(adj[w[0]].begin(), adj[w[0]].end());",
            "\t\t\t\t\tif(~v) adj[w[0]].push_back(v);",
            "\t\t\t\t\tif(label[adj[w[1]][0]] != 1) reverse(adj[w[1]].begin(), adj[w[1]].end());",
            "\t\t\t\t\tmove(adj[w[1]].begin(), adj[w[1]].end(), back_inserter(adj[w[0]]));",
            "\t\t\t\t\tadj[w[1]].clear();",
            "\t\t\t\t\tadj[u].erase(it);",
            "\t\t\t\t\tcount[1] = 0;",
            "\t\t\t\t\tif(count[1]) is_null_tree = true;",
            "\t\t\t\t}",
            "\t\t\t\telse is_null_tree = true;",
            "\t\t\t}",
            "\t\t\telse{",
            "\t\t\t\t// Q node",
            "\t\t\t\tif(count[0] == deg){",
            "\t\t\t\t\t// Template Q0",
            "\t\t\t\t\tlabel[u] = 0;",
            "\t\t\t\t}",
            "\t\t\t\telse if(count[1] == deg){",
            "\t\t\t\t\t// Template Q1",
            "\t\t\t\t\tlabel[u] = 1;",
            "\t\t\t\t}",
            "\t\t\t\telse{",
            "\t\t\t\t\tif(label[adj[u].back()] == 0) reverse(adj[u].begin(), adj[u].end());",
            "\t\t\t\t\tif(label[adj[u].front()] != 0 && label[adj[u].back()] == 2) reverse(adj[u].begin(), adj[u].end());",
            "\t\t\t\t\tint i = 0;",
            "\t\t\t\t\twhile(label[adj[u][i]] == 0) ++ i;",
            "\t\t\t\t\tint j = i + 1;",
            "\t\t\t\t\twhile(j < deg && label[adj[u][j]] == 1) ++ j;",
            "\t\t\t\t\tif(j == deg){",
            "\t\t\t\t\t\t// Template Q2",
            "\t\t\t\t\t\tif(label[adj[u][i]] == 2){",
            "\t\t\t\t\t\t\tint v = adj[u][i];",
            "\t\t\t\t\t\t\tauto it = adj[u].erase(adj[u].begin() + i);",
            "\t\t\t\t\t\t\tif(label[adj[v][0]] != 0) reverse(adj[v].begin(), adj[v].end());",
            "\t\t\t\t\t\t\tadj[u].insert(it, adj[v].begin(), adj[v].end());",
            "\t\t\t\t\t\t\tadj[v].clear();",
            "\t\t\t\t\t\t}",
            "\t\t\t\t\t\tlabel[u] = 2;",
            "\t\t\t\t\t}",
            "\t\t\t\t\telse{",
            "\t\t\t\t\t\tint k = j + 1;",
            "\t\t\t\t\t\twhile(k < deg && label[adj[u][k]] == 0) ++ k;",
            "\t\t\t\t\t\tif(k == deg && is_root){",
            "\t\t\t\t\t\t\t// Template Q3",
            "\t\t\t\t\t\t\tif(i < j && label[adj[u][j]] == 2){",
            "\t\t\t\t\t\t\t\tint v = adj[u][j];",
            "\t\t\t\t\t\t\t\tauto it = adj[u].erase(adj[u].begin() + j);",
            "\t\t\t\t\t\t\t\tif(label[adj[v].front()] == 0) reverse(adj[v].begin(), adj[v].end());",
            "\t\t\t\t\t\t\t\tadj[u].insert(it, adj[v].begin(), adj[v].end());",
            "\t\t\t\t\t\t\t\tadj[v].clear();",
            "\t\t\t\t\t\t\t}",
            "\t\t\t\t\t\t\tif(label[adj[u][i]] == 2){",
            "\t\t\t\t\t\t\t\tint v = adj[u][i];",
            "\t\t\t\t\t\t\t\tauto it = adj[u].erase(adj[u].begin() + i);",
            "\t\t\t\t\t\t\t\tif(label[adj[v].back()] == 0) reverse(adj[v].begin(), adj[v].end());",
            "\t\t\t\t\t\t\t\tadj[u].insert(it, adj[v].begin(), adj[v].end());",
            "\t\t\t\t\t\t\t\tadj[v].clear();",
            "\t\t\t\t\t\t\t}",
            "\t\t\t\t\t\t}",
            "\t\t\t\t\t\telse is_null_tree = true;",
            "\t\t\t\t\t}",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t\tif(is_root) done = true;",
            "\t\t\treturn pertinence;",
            "\t\t};",
            "\t\tdfs(dfs, 0);",
            "\t\treturn !is_null_tree;",
            "\t}",
            "\ttemplate<class T>",
            "\tT count_permutation() const{",
            "\t\tif(is_null_tree) return 0;",
            "\t\tvector<T> fact(n + 1, 1);",
            "\t\tfor(auto x = 1; x <= n; ++ x) fact[x] = fact[x - 1] * x;",
            "\t\tauto dfs = [&](auto self, int u)->T{",
            "\t\t\tT res = adj[u].empty() ? 1 : data[u] ? 2 : fact[(int)adj[u].size()];",
            "\t\t\tfor(auto v: adj[u]) res *= self(self, v);",
            "\t\t\treturn res;",
            "\t\t};",
            "\t\treturn dfs(dfs, 0);",
            "\t}",
            "\tvector<int> frontier() const{",
            "\t\tvector<int> order;",
            "\t\tauto dfs = [&](auto self, int u)->void{",
            "\t\t\tif(adj[u].empty()) order.push_back(data[u]);",
            "\t\t\tfor(auto v: adj[u]) self(self, v);",
            "\t\t};",
            "\t\tdfs(dfs, 0);",
            "\t\treturn order;",
            "\t}",
            "};"
        ],
        "description": "tranxuanbach"
    }
}