{
    "tranxuanbach": {
        "prefix": "minimum_steiner_tree",
        "body": [
            "// Source: https://infossm.github.io/blog/2022/03/10/Minimum-Steiner-Tree/",
            "// Requires disjoint_set and graph",
            "struct minimum_steiner_tree{",
            "\t// Edge weights must be non-negative.",
            "\t// Returns null if subset does not lie in the same connected component.",
            "\t// O(m * log(m) + 2^{n-k} * alpha(n) * m)",
            "\ttemplate<class T>",
            "\tstatic optional<pair<T, vector<int>>>",
            "\tsolve_for_small_complement(const graph<auto> &g, const vector<int> &subset){",
            "\t\tif(subset.empty()) return pair<T, vector<int>>{0, {}};",
            "\t\tint n = g.n, m = (int)g.edge.size(), k = (int)subset.size();",
            "\t\tassert(n - k <= 30);",
            "\t\tassert(is_sorted(subset.begin(), subset.end()));",
            "\t\tassert(0 <= subset.front() && subset.back() < n);",
            "\t\tvector<int> order(m);",
            "\t\tiota(order.begin(), order.end(), 0);",
            "\t\torder.erase(remove_if(order.begin(), order.end(), [&](int id){ return g.ignore && g.ignore(id) || g.edge[id].from == g.edge[id].to; }), order.end());",
            "\t\tsort(order.begin(), order.end(), [&](int i, int j){ return g.edge[i].cost < g.edge[j].cost; });",
            "\t\tfor(auto id: order) assert(g.edge[id].cost >= 0);",
            "\t\tvector<int> rem, pos(n, -2);",
            "\t\tfor(auto u: subset) pos[u] = -1;",
            "\t\tfor(auto u = 0; u < n; ++ u) if(pos[u] == -2){",
            "\t\t\tpos[u] = (int)rem.size();",
            "\t\t\trem.push_back(u);",
            "\t\t}",
            "\t\tint nrem = (int)rem.size();",
            "\t\tdisjoint_set dsu(n);",
            "\t\tconst T inf = numeric_limits<T>::max() / 2;",
            "\t\tT opt = inf;",
            "\t\tint opt_mask = -1;",
            "\t\tfor(auto mask = 0; mask < 1 << nrem; ++ mask){",
            "\t\t\tdsu.clear();",
            "\t\t\tT cur = 0;",
            "\t\t\tfor(auto id: order){",
            "\t\t\t\tauto [u, v, w] = g.edge[id];",
            "\t\t\t\tif(~pos[u] && ~mask & 1 << pos[u] || ~pos[v] && ~mask & 1 << pos[v]) continue;",
            "\t\t\t\tif(dsu.merge(u, v)) cur += w;",
            "\t\t\t}",
            "\t\t\tfor(auto i = 1; i < k; ++ i) if(!dsu.share(subset[0], subset[i])) goto NEXT;",
            "\t\t\tif(opt > cur){",
            "\t\t\t\topt = cur;",
            "\t\t\t\topt_mask = mask;",
            "\t\t\t}",
            "\t\t\tNEXT:;",
            "\t\t}",
            "\t\tif(opt == inf) return {};",
            "\t\tvector<int> res;",
            "\t\tdsu.clear();",
            "\t\tfor(auto id: order){",
            "\t\t\tauto [u, v, w] = g.edge[id];",
            "\t\t\tif((!~pos[u] || opt_mask & 1 << pos[u]) && (!~pos[v] || opt_mask & 1 << pos[v]) && dsu.merge(u, v)) res.push_back(id);",
            "\t\t}",
            "\t\treturn pair{opt, res};",
            "\t}",
            "\t// Edge weights must be non-negative.",
            "\t// Returns null if subset does not lie in the same connected component.",
            "\t// O(m + n^3 + 3^k * n + 2^k * n^2)",
            "\ttemplate<class T>",
            "\tstatic optional<pair<T, vector<int>>>",
            "\tsolve_for_small_subset(const graph<auto> &g, const vector<int> &subset){",
            "\t\tif(subset.empty()) return pair<T, vector<int>>{0, {}};",
            "\t\tint n = g.n, m = (int)g.edge.size(), k = (int)subset.size();",
            "\t\tassert(k <= 30);",
            "\t\tassert(is_sorted(subset.begin(), subset.end()));",
            "\t\tassert(0 <= subset.front() && subset.back() < n);",
            "\t\tconst T inf = numeric_limits<T>::max() / 2;",
            "\t\tvector prev_dist(n, vector<int>(n, -1));",
            "\t\tvector dist(n, vector<T>(n, inf));",
            "\t\tfor(auto u = 0; u < n; ++ u) dist[u][u] = 0;",
            "\t\tfor(auto id = 0; id < m; ++ id){",
            "\t\t\tif(g.ignore && g.ignore(id)) continue;",
            "\t\t\tauto [u, v, w] = g.edge[id];",
            "\t\t\tassert(w >= 0);",
            "\t\t\tif(dist[u][v] > w){",
            "\t\t\t\tprev_dist[u][v] = prev_dist[v][u] = id;",
            "\t\t\t\tdist[u][v] = dist[v][u] = w;",
            "\t\t\t}",
            "\t\t}",
            "\t\tfor(auto w = 0; w < n; ++ w) for(auto u = 0; u < n; ++ u) for(auto v = 0; v < n; ++ v) if(dist[u][v] > dist[u][w] + dist[w][v]){",
            "\t\t\tprev_dist[u][v] = prev_dist[w][v];",
            "\t\t\tdist[u][v] = dist[u][w] + dist[w][v];",
            "\t\t}",
            "\t\tfor(auto i = 1; i < k; ++ i) if(dist[subset[0]][subset[i]] == inf) return {};",
            "\t\tvector prev_dp(1 << k, vector<array<int, 2>>(n, {-1, -1}));",
            "\t\tvector dp(1 << k, vector<T>(n, inf));",
            "\t\t\tfor(auto i = 0; i < k; ++ i) for(auto u = 0; u < n; ++ u){",
            "\t\t\tif(subset[i] != u){",
            "\t\t\t\tprev_dp[1 << i][u] = {1, subset[i]};",
            "\t\t\t\tdp[1 << i][u] = dist[subset[i]][u];",
            "\t\t\t}",
            "\t\t\telse dp[1 << i][u] = 0;",
            "\t\t}",
            "\t\tfor(auto mask = 1; mask < 1 << k; ++ mask){",
            "\t\t\tfor(auto smask = mask - 1 & mask; smask; smask = smask - 1 & mask) for(auto u = 0; u < n; ++ u) if(dp[mask][u] > dp[smask][u] + dp[mask ^ smask][u]){",
            "\t\t\t\tprev_dp[mask][u] = {0, smask};",
            "\t\t\t\tdp[mask][u] = dp[smask][u] + dp[mask ^ smask][u];",
            "\t\t\t}",
            "\t\t\tfor(auto u = 0; u < n; ++ u) for(auto v = 0; v < n; ++ v) if(dp[mask][u] > dp[mask][v] + dist[v][u]){",
            "\t\t\t\tprev_dp[mask][u] = {1, v};",
            "\t\t\t\tdp[mask][u] = dp[mask][v] + dist[v][u];",
            "\t\t\t}",
            "\t\t}",
            "\t\tfor(auto i = 1; i < k; ++ i) assert(dp.back()[subset[0]] == dp.back()[subset[i]]);",
            "\t\tvector<int> res, on_res(m);",
            "\t\tvector<array<int, 2>> stack{{(1 << k) - 1, subset[0]}};",
            "\t\twhile(!stack.empty()){",
            "\t\t\tauto [mask, u] = stack.back();",
            "\t\t\tstack.pop_back();",
            "\t\t\tif(!~prev_dp[mask][u][0]) continue;",
            "\t\t\tif(prev_dp[mask][u][0]){",
            "\t\t\t\tint v = prev_dp[mask][u][1];",
            "\t\t\t\tstack.push_back({mask, v});",
            "\t\t\t\twhile(u != v){",
            "\t\t\t\t\tint id = prev_dist[v][u];",
            "\t\t\t\t\tauto &e = g.edge[id];",
            "\t\t\t\t\tif(on_res[id]) assert(e.cost == 0);",
            "\t\t\t\t\telse{",
            "\t\t\t\t\t\ton_res[id] = true;",
            "\t\t\t\t\t\tres.push_back(id);",
            "\t\t\t\t\t}",
            "\t\t\t\t\tu ^= e.from ^ e.to;",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t\telse{",
            "\t\t\t\tint smask = prev_dp[mask][u][1];",
            "\t\t\t\tstack.push_back({smask, u});",
            "\t\t\t\tstack.push_back({mask ^ smask, u});",
            "\t\t\t}",
            "\t\t}",
            "\t\treturn pair{dp.back()[subset[0]], res};",
            "\t}",
            "};"
        ],
        "description": "tranxuanbach"
    }
}