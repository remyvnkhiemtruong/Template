{
    "tranxuanbach": {
        "prefix": "find_a_commutative_group_basis",
        "body": [
            "// Source: \"Linear and sublinear time algorithms for the basis of abelian groups\" by Li Chen and Bin Fu",
            "// op: {0, ..., n-1}^2 -> {0, ..., n-1} must define a commutative group.",
            "// Returns the list of {prime p dividing n, a basis for the Sylow p-group}",
            "// Less than 2n + log(n)^2 op() calls.",
            "// Requires find_the_order_of_all_group_elements",
            "vector<pair<int, vector<int>>> find_a_commutative_group_basis(int n, auto op, const vector<int> &order){",
            "\tassert(1 <= n);",
            "\tint id = find(order.begin(), order.end(), 1) - order.begin();",
            "\tvector<vector<int>> has(n + 1);",
            "\tfor(auto x = 0; x < n; ++ x) has[order[x]].push_back(x);",
            "\t// x^p, x^order(x)/p, log_p(order(x))",
            "\tvector<int> lift(n, -1), root(n, -1), log(n, -1), path;",
            "\tvector<pair<int, vector<int>>> res;",
            "\tvector<vector<int>> inv_root(n);",
            "\tvector<list<int>::iterator> pos(n);",
            "\tfor(auto m = n, p = 2; p <= m; ++ p){",
            "\t\tif(m % p) continue;",
            "\t\tlist<int> psubgroup;",
            "\t\tint exp = 0;",
            "\t\tfor(auto power = p; m % p == 0; m /= p, power *= p, ++ exp) psubgroup.insert(psubgroup.end(), has[power].begin(), has[power].end());",
            "\t\tfor(auto it = psubgroup.begin(); it != psubgroup.end(); ++ it) pos[*it] = it;",
            "\t\tlift[id] = id;",
            "\t\tfor(auto x: psubgroup){",
            "\t\t\tif(~lift[x]) continue;",
            "\t\t\tlift[x] = id;",
            "\t\t\tfor(auto base = x, e = p; e; base = op(base, base), e >>= 1) if(e & 1) lift[x] = op(lift[x], base);",
            "\t\t\tauto power = lift[x];",
            "\t\t\tfor(auto y = op(x, x); y != id; y = op(y, x)){",
            "\t\t\t\tpower = op(power, lift[x]);",
            "\t\t\t\tlift[y] = power;",
            "\t\t\t}",
            "\t\t}",
            "\t\troot[id] = id;",
            "\t\tlog[id] = 0;",
            "\t\tfor(auto x: psubgroup){",
            "\t\t\tif(~log[x]) continue;",
            "\t\t\tpath.clear();",
            "\t\t\tfor(auto y = x; ; y = lift[y]){",
            "\t\t\t\tpath.push_back(y);",
            "\t\t\t\tif(~log[y]) break;",
            "\t\t\t}",
            "\t\t\tfor(auto i = (int)path.size() - 2; i >= 0; -- i){",
            "\t\t\t\troot[path[i]] = path[i + 1] == id ? path[i] : root[path[i + 1]];",
            "\t\t\t\tlog[path[i]] = log[path[i + 1]] + 1;",
            "\t\t\t}",
            "\t\t}",
            "\t\tinv_root[id].clear();",
            "\t\tfor(auto x: psubgroup) inv_root[root[x]].push_back(x);",
            "\t\tvector<int> span, basis;",
            "\t\tfor(auto sum = 0; sum != exp; ){",
            "\t\t\tassert(!psubgroup.empty());",
            "\t\t\tint x = psubgroup.back();",
            "\t\t\tbasis.push_back(x);",
            "\t\t\tsum += log[x];",
            "\t\t\tint size = (int)span.size();",
            "\t\t\tfor(auto y = root[x]; y != id; y = op(y, root[x])){",
            "\t\t\t\tspan.push_back(y);",
            "\t\t\t\tfor(auto w: inv_root[y]) psubgroup.erase(pos[w]);",
            "\t\t\t\tfor(auto i = 0; i < size; ++ i){",
            "\t\t\t\t\tint z = op(y, span[i]);",
            "\t\t\t\t\tspan.push_back(z);",
            "\t\t\t\t\tfor(auto w: inv_root[z]) psubgroup.erase(pos[w]);",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t}",
            "\t\tres.push_back({p, basis});",
            "\t}",
            "\treturn res;",
            "}",
            "// Extra 2n op() calls to find the orders.",
            "vector<pair<int, vector<int>>> find_a_commutative_group_basis(int n, auto op){",
            "\treturn find_a_commutative_group_basis(n, op, find_the_order_of_all_group_elements(n, op));",
            "}",
            "// Extra 2n op() calls to find the orders.",
            "vector<pair<int, vector<int>>> find_a_commutative_group_basis(const vector<vector<int>> &g){",
            "\treturn find_a_commutative_group_basis((int)g.size(), [&](int x, int y){ return g[x][y]; }, find_the_order_of_all_group_elements(g));",
            "}"
        ],
        "description": "tranxuanbach"
    }
}