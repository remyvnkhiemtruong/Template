{
    "tranxuanbach": {
        "prefix": "distinct_substring_count_query_solver_offline",
        "body": [
            "// Adamant orz (https://codeforces.com/blog/entry/62331)",
            "// Requires suffix_automaton",
            "template<class Char_Type, class Adjacency_Type>",
            "struct distinct_substring_count_query_solver_offline{",
            "\tvector<int> &s;",
            "\tsuffix_automaton<Char_Type, Adjacency_Type> &aut;",
            "\tvector<array<int, 3>> queries;",
            "\tdistinct_substring_count_query_solver_offline(vector<Char_Type> &s, suffix_automaton<Char_Type, Adjacency_Type> &aut): s(s), aut(aut){ }",
            "\t// Query qi asks for the # of distinct substrings of the substring s[ql, qr).",
            "\tvoid query(int qi, int ql, int qr){",
            "\t\tassert(0 <= ql && ql <= qr && qr <= aut.max_len[aut.last]);",
            "\t\tqueries.push_back({qr, ql, qi});",
            "\t}",
            "\t// answer(qi, x): report that the answer to the query qi is x.",
            "\t// O(n * log^2(n))",
            "\tvoid solve(auto answer){",
            "\t\tint n = aut.max_len[aut.last], m = (int)aut.size();",
            "\t\tlong long fw_tot = 0;",
            "\t\tvector<long long> fw0(n + 1), fw1(n + 1);",
            "\t\tauto range_add = [&](int ql, int qr, int x)->void{",
            "\t\t\tlong long y = 1LL * ql * x, z = 1LL * qr * x;",
            "\t\t\tfw_tot += z - y;",
            "\t\t\tfor(auto l = ql + 1; l <= n; l += l & -l) fw0[l] += x, fw1[l] += y;",
            "\t\t\tfor(auto r = qr + 1; r <= n; r += r & -r) fw0[r] -= x, fw1[r] -= z;",
            "\t\t};",
            "\t\tauto query_sum = [&](int ql)->long long{",
            "\t\t\tlong long sum0 = 0, sum1 = 0;",
            "\t\t\tfor(auto l = ql; l; l -= l & -l) sum0 += fw0[l], sum1 += fw1[l];",
            "\t\t\treturn fw_tot - (sum0 * ql - sum1);",
            "\t\t};",
            "\t\tvector<int> seg_max(m << 1);",
            "\t\tauto set_point = [&](int p, int x)->void{",
            "\t\t\tfor(seg_max[p += m] = x; p >>= 1; ) seg_max[p] = max(seg_max[p << 1], seg_max[p << 1 | 1]);",
            "\t\t};",
            "\t\tauto query_max = [&](int l, int r)->int{",
            "\t\t\tint maxv = 0;",
            "\t\t\tfor(l += m, r += m; l < r; l >>= 1, r >>= 1){",
            "\t\t\t\tif(l & 1) maxv = max(maxv, seg_max[l ++]);",
            "\t\t\t\tif(r & 1) maxv = max(maxv, seg_max[-- r]);",
            "\t\t\t}",
            "\t\t\treturn maxv;",
            "\t\t};",
            "\t\tint it = 0;",
            "\t\tvector<int> pos(m), end(m);",
            "\t\taut.precalc_count();",
            "\t\tauto dfs = [&](auto self, int u)->void{",
            "\t\t\tpos[u] = it ++;",
            "\t\t\tfor(auto v: aut.inv_link[u]) self(self, v);",
            "\t\t\tend[u] = it;",
            "\t\t};",
            "\t\tdfs(dfs, 0);",
            "\t\tvector<vector<array<int, 2>>> has(n);",
            "\t\tfor(auto [qr, ql, qi]: queries){",
            "\t\t\tif(qr - ql <= 1) answer(qi, qr - ql);",
            "\t\t\telse has[qr - 1].push_back({ql, qi});",
            "\t\t}",
            "\t\tvector<int> upto(n), used(m);",
            "\t\tused[0] = true;",
            "\t\tfor(auto qr = 1, u_cur = 0; qr <= n; ++ qr){",
            "\t\t\tu_cur = aut.next_state(u_cur, s[qr - 1]);",
            "\t\t\trange_add(qr - aut.max_len[u_cur], qr, 1);",
            "\t\t\tint u = u_cur;",
            "\t\t\twhile(!used[u]) used[u] = true, u = aut.link[u];",
            "\t\t\twhile(u){",
            "\t\t\t\tint qr = query_max(pos[u], end[u]);",
            "\t\t\t\trange_add(qr - aut.max_len[u], qr - aut.max_len[upto[qr - 1]], -1);",
            "\t\t\t\tswap(upto[qr - 1], u);",
            "\t\t\t}",
            "\t\t\tset_point(pos[u_cur], qr);",
            "\t\t\tfor(auto [ql, qi]: has[qr - 1]) answer(qi, query_sum(ql));",
            "\t\t}",
            "\t}",
            "};"
        ],
        "description": "tranxuanbach"
    }
}