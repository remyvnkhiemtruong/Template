{
    "tranxuanbach": {
        "prefix": "dijkstra",
        "body": [
            "template<class T>",
            "struct dijkstra{",
            "\tint n;",
            "\tT base_dist;",
            "\tvector<T> dist;",
            "\tvector<int> pv;",
            "\tvector<int> pe;",
            "\tvector<int> order;",
            "\tvector<int> pos;",
            "\tvector<int> root_of;",
            "\tvector<int> root;",
            "\tvector<int> depth;",
            "\tvector<int> was;",
            "\tdijkstra(T base_dist = T{0}): base_dist(base_dist){ }",
            "\tvoid init(int n){",
            "\t\tthis->n = n;",
            "\t\tdist.assign(n, base_dist);",
            "\t\tpv.assign(n, -1);",
            "\t\tpe.assign(n, -1);",
            "\t\torder.clear();",
            "\t\tpos.assign(n, -1);",
            "\t\troot_of.assign(n, -1);",
            "\t\troot.clear();",
            "\t\tdepth.assign(n, -1);",
            "\t\twas.assign(n, -2);",
            "\t\tattempt = -1;",
            "\t}",
            "\tint attempt;",
            "\tpriority_queue<pair<T, int>, vector<pair<T, int>>, greater<pair<T, int>>> pq;",
            "\t// act_greater(v, u): dist[v] has been updated to larger value by u",
            "\t// act_equal(v, u): dist[v] equals the length of shortest path to v through u",
            "\t// O(((# of reachable nodes) + (# of reachable edges)) * log((# of reachable edges)))",
            "\t// Requires graph",
            "\ttemplate<class Graph>",
            "\tvoid _run(const Graph &g, const vector<int> &src, auto act_greater, auto act_equal){",
            "\t\tfor(auto u: src){",
            "\t\t\tif(was[u] == attempt) continue;",
            "\t\t\twas[u] = attempt;",
            "\t\t\tpq.push({dist[u] = base_dist, u});",
            "\t\t\tdepth[u] = 0;",
            "\t\t\troot_of[u] = u;",
            "\t\t\troot.push_back(u);",
            "\t\t\tpv[u] = -1;",
            "\t\t\tpe[u] = -1;",
            "\t\t}",
            "\t\torder.clear();",
            "\t\twhile(!pq.empty()){",
            "\t\t\tauto [d, u] = pq.top();",
            "\t\t\tpq.pop();",
            "\t\t\tif(d != dist[u]) continue;",
            "\t\t\tpos[u] = (int)order.size();",
            "\t\t\torder.push_back(u);",
            "\t\t\tfor(auto id: g.adj[u]){",
            "\t\t\t\tif(g.ignore && g.ignore(id)) continue;",
            "\t\t\t\tint v = g(u, id);",
            "\t\t\t\tauto &e = g.edge[id];",
            "\t\t\t\tassert(0 <= e.cost);",
            "\t\t\t\tif(was[v] != attempt || dist[u] + e.cost < dist[v]){",
            "\t\t\t\t\twas[v] = attempt;",
            "\t\t\t\t\tdepth[v] = depth[u] + 1;",
            "\t\t\t\t\tpv[v] = u;",
            "\t\t\t\t\tpe[v] = id;",
            "\t\t\t\t\troot_of[v] = root_of[u];",
            "\t\t\t\t\tpq.push({dist[v] = dist[u] + e.cost, v});",
            "\t\t\t\t\tact_greater(v, u);",
            "\t\t\t\t}",
            "\t\t\t\telse if(dist[u] + e.cost == dist[v]) act_equal(v, u);",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "\t// Requires graph",
            "\ttemplate<class Graph>",
            "\tvoid run(const Graph &g, const vector<int> &src, auto act_greater, auto act_equal){",
            "\t\tassert(g.n <= n);",
            "\t\tif(g.n == 0) return;",
            "\t\tfor(auto u: src) assert(0 <= u && u < g.n);",
            "\t\troot.clear(), order.clear();",
            "\t\t++ attempt;",
            "\t\t_run(g, src, act_greater, act_equal);",
            "\t}",
            "\t// Requires graph",
            "\ttemplate<class Graph>",
            "\tvoid run(const Graph &g, const vector<int> &src){",
            "\t\trun(g, src, [&](int, int){  }, [&](int, int){  });",
            "\t}",
            "\t// Check if u is visited during the last dijkstra-like call.",
            "\tbool visited(int u) const{",
            "\t\treturn was[u] == attempt;",
            "\t}",
            "};"
        ],
        "description": "tranxuanbach"
    }
}