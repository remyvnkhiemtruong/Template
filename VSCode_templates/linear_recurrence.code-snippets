{
    "tranxuanbach": {
        "prefix": "linear_recurrence",
        "body": [
            "// Requires modular",
            "template<class T>",
            "struct linear_recurrence{",
            "\tint N;",
            "\tvector<T> init, coef; // linear recurrence relation of form Sum{t<=i<t+N}( coef[i] * A[i] ) = A[t+N] for all t",
            "\tlinear_recurrence(const vector<T> &init, const vector<T> &coef): N((int)coef.size()), init(init), coef(coef){ }",
            "\tlinear_recurrence(const vector<T> &s){ // Berlekamp Massey Algorithm / find the minimal linear recurrence ",
            "\t\tint n = (int)s.size();",
            "\t\tN = 0;",
            "\t\tvector<T> B(n), C;",
            "\t\tcoef.resize(n);",
            "\t\tcoef[0] = B[0] = 1;",
            "\t\tT b = 1;",
            "\t\tfor(int i = 0, m = 0; i < n; ++ i){",
            "\t\t\t++ m;",
            "\t\t\tT d = s[i];",
            "\t\t\tfor(int j = 1; j <= N; ++ j) d += coef[j] * s[i - j];",
            "\t\t\tif(d == T(0)) continue;",
            "\t\t\tC = coef;",
            "\t\t\tT c = d / b;",
            "\t\t\tfor(int j = m; j < n; ++ j) coef[j] -= c * B[j - m];",
            "\t\t\tif(2 * N > i) continue;",
            "\t\t\tN = i + 1 - N, B = C, b = d, m = 0;",
            "\t\t}",
            "\t\tcoef.resize(N + 1), coef.erase(coef.begin());",
            "\t\tfor(auto &x: coef) x = -x;",
            "\t\treverse(coef.begin(), coef.end());",
            "\t\tinit.resize(N);",
            "\t\tfor(int i = 0; i < N; ++ i) init[i] = s[i];",
            "\t} // O(N n + n log mod)",
            "\tT operator[](long long n) const{",
            "\t\tauto combine = [&](const vector<T> &a, const vector<T> &b){",
            "\t\t\tvector<T> res(2 * N + 1);",
            "\t\t\tfor(int i = 0; i <= N; ++ i) for(int j = 0; j <= N; ++ j) res[i + j] += a[i] * b[j];",
            "\t\t\tfor(int i = N << 1; i > N; -- i) for(int j = 0; j < N; ++ j) res[i - 1 - j] += res[i] * coef[N - 1 - j];",
            "\t\t\tres.resize(N + 1);",
            "\t\t\treturn res;",
            "\t\t};",
            "\t\tvector<T> pol(N + 1), e(pol);",
            "\t\tpol[0] = e[1] = 1;",
            "\t\tfor(++ n; n; n >>= 1, e = combine(e, e)) if(n & 1) pol = combine(pol, e);",
            "\t\tT res = 0;",
            "\t\tfor(int i = 0; i < N; ++ i) res += pol[i + 1] * init[i];",
            "\t\treturn res;",
            "\t} // N^2 log n (or N log N log n with FFT)",
            "};",
            "template<class T> // calculate the minimal polynomial of the sparse matrix, reads dimension and its non-zero elements",
            "vector<T> minimal_polynomial(int N, const vector<tuple<int, int, T>> &a){ // O(N (n + N) + n log mod)",
            "\tint n = (int)a.size();",
            "\tvector<T> v(N), p(N), s;",
            "\tgenerate(v.begin(), v.end(), rng), generate(p.begin(), p.end(), rng);",
            "\tfor(int rep = 0; rep < 2 * N; ++ rep){",
            "\t\tT x  = 0;",
            "\t\tfor(int i = 0; i < N; ++ i) x += v[i] * p[i];",
            "\t\ts.push_back(x);",
            "\t\tvector<T> p_next(N);",
            "\t\tfor(auto [i, j, val]: a) p_next[i] += val * p[j];",
            "\t\tswap(p, p_next);",
            "\t}",
            "\tauto poly = linear_recurrence(s).coef;",
            "\tfor(auto &x: poly) x = -x;",
            "\tpoly.push_back(1);",
            "\treturn poly;",
            "} // Randomized",
            "template<class T> // calculate the determinant of the sparse matrix",
            "T determinant(int N, vector<tuple<int, int, T>> a){",
            "\tT c;",
            "\tdo c = rng(); while(!c);",
            "\tfor(auto &x: a) get<2>(x) *= c;",
            "\tT det = minimal_polynomial(N, a)[0] * (N & 1 ? -1 : 1);",
            "\treturn det / (c ^ N);",
            "} // Randomized"
        ],
        "description": "tranxuanbach"
    }
}