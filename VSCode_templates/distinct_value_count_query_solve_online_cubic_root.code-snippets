{
    "tranxuanbach": {
        "prefix": "distinct_value_count_query_solve_online_cubic_root",
        "body": [
            "template<int BX>",
            "struct distinct_value_count_query_solve_online_cubic_root{",
            "\tint n;",
            "\tvector<int> prev, next;",
            "\tvector<vector<int>> prefix;",
            "\t// O(n + n^2/BX^2) time and memory",
            "\t// O(n + n^2/3 * qn^2/3) for BX = n^2/3 / qn^1/3",
            "\ttemplate<class T, class Compare = less<>>",
            "\tdistinct_value_count_query_solve_online_cubic_root(const vector<T> &a, Compare cmp = less<>()): n((int)a.size()), prev(n), next(n), prefix(n / BX + 2, vector<int>(n / BX + 2)){",
            "\t\tint nB = n / BX;",
            "\t\tvector<T> temp = a;",
            "\t\tsort(temp.begin(), temp.end(), cmp);",
            "\t\tvector<int> b(n), seen(n, -1);",
            "\t\tfor(auto iB = 0; iB <= nB + 1; ++ iB) prefix[iB].resize(iB + 1);",
            "\t\tfor(auto i = 0; i < n; ++ i){",
            "\t\t\tb[i] = lower_bound(temp.begin(), temp.end(), a[i], cmp) - temp.begin();",
            "\t\t\tprev[i] = seen[b[i]];",
            "\t\t\tseen[b[i]] = i;",
            "\t\t\t++ prefix[i / BX + 1][~prev[i] ? prev[i] / BX + 1 : 0];",
            "\t\t}",
            "\t\tfill(seen.begin(), seen.end(), n);",
            "\t\tfor(auto i = n - 1; i >= 0; -- i){",
            "\t\t\tnext[i] = seen[b[i]];",
            "\t\t\tseen[b[i]] = i;",
            "\t\t}",
            "\t\tfor(auto i = 0; i <= nB + 1; ++ i) for(auto j = 1; j <= i; ++ j) prefix[i][j] += prefix[i][j - 1];",
            "\t\tfor(auto i = 1; i <= nB + 1; ++ i) for(auto j = 0; j <= i; ++ j) prefix[i][j] += prefix[i - 1][j];",
            "\t}",
            "\t// O(BX)",
            "\t// O(n^2/3 / qn^1/3) for BX = n^2/3 / qn^1/3",
            "\tint query(int ql, int qr) const{",
            "\t\tassert(0 <= ql && ql <= qr && qr <= n);",
            "\t\tif(ql == qr) return 0;",
            "\t\tint qlB = ql / BX, qrB = (qr - 1) / BX, res = 0;",
            "\t\tif(qlB == qrB){",
            "\t\t\tfor(auto i = ql; i < qr; ++ i) res += prev[i] < ql;",
            "\t\t}",
            "\t\telse{",
            "\t\t\tres = prefix[qrB][qlB + 1] - prefix[qlB + 1][qlB + 1];",
            "\t\t\tint thL = BX * (qlB + 1), thR = BX * qrB;",
            "\t\t\tfor(auto i = ql; i < thL; ++ i) res += next[i] >= thR;",
            "\t\t\tfor(auto i = thR; i < qr; ++ i) res += prev[i] < ql;",
            "\t\t}",
            "\t\treturn res;",
            "\t}",
            "};"
        ],
        "description": "tranxuanbach"
    }
}