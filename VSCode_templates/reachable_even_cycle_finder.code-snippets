{
    "tranxuanbach": {
        "prefix": "reachable_even_cycle_finder",
        "body": [
            "struct reachable_even_cycle_finder{",
            "\tint n;",
            "\treachable_even_cycle_finder(int n): n(n), it(0), was(n), pos(n){ }",
            "\tint it;",
            "\tvector<int> was;",
            "\tvector<int> pos;",
            "\tdeque<int> path;",
            "\t// Find a simple even cycle reachable from s in the simple undirected graph g",
            "\t// Minimum degree of nodes reachable from s must be >= 3",
            "\t// O(length of the maximal)",
            "\ttemplate<class T>",
            "\tpair<T, vector<int>> find(const graph<T> &g, int s){",
            "\t\tassert(n == g.n && 0 <= s && s < n);",
            "\t\t++ it;",
            "\t\tpath.clear();",
            "\t\tint head = -1;",
            "\t\tauto find_maximal_path = [&](int u, bool forward)->void{",
            "\t\t\twhile(true){",
            "\t\t\t\twas[u] = it;",
            "\t\t\t\tint next = -1;",
            "\t\t\t\tif(!forward) head = u;",
            "\t\t\t\tfor(auto id: g.adj[u]){",
            "\t\t\t\t\tif(g.ignore && g.ignore(id)) continue;",
            "\t\t\t\t\tauto &e = g.edge[id];",
            "\t\t\t\t\tint v = u ^ e.from ^ e.to;",
            "\t\t\t\t\tif(was[v] != it){",
            "\t\t\t\t\t\tnext = v;",
            "\t\t\t\t\t\tforward ? path.push_back(id) : path.push_front(id);",
            "\t\t\t\t\t\tbreak;",
            "\t\t\t\t\t}",
            "\t\t\t\t}",
            "\t\t\t\tif(!~next) break;",
            "\t\t\t\tu = next;",
            "\t\t\t}",
            "\t\t};",
            "\t\tfind_maximal_path(s, true);",
            "\t\tfind_maximal_path(s, false);",
            "\t\tpos[head] = 0;",
            "\t\tfor(auto i = 0, u = head; i < (int)path.size(); ++ i){",
            "\t\t\tauto &e = g.edge[path[i]];",
            "\t\t\tu ^= e.from ^ e.to;",
            "\t\t\tpos[u] = i + 1;",
            "\t\t}",
            "\t\tvector<array<int, 2>> adj;",
            "\t\tfor(auto id: g.adj[head]){",
            "\t\t\tif(g.ignore && g.ignore(id)) continue;",
            "\t\t\tauto &e = g.edge[id];",
            "\t\t\tint u = head ^ e.from ^ e.to;",
            "\t\t\tif(pos[u] >= 2){",
            "\t\t\t\tadj.push_back({pos[u], id});",
            "\t\t\t\tif((int)adj.size() == 2) break;",
            "\t\t\t}",
            "\t\t}",
            "\t\tassert((int)adj.size() == 2);",
            "\t\tfor(auto [p, id]: adj){",
            "\t\t\tif(p & 1){",
            "\t\t\t\tvector<int> even_cycle;",
            "\t\t\t\tfor(auto i = 0; i < p; ++ i) even_cycle.push_back(path[i]);",
            "\t\t\t\teven_cycle.push_back(id);",
            "\t\t\t\treturn {head, even_cycle};",
            "\t\t\t}",
            "\t\t}",
            "\t\tif(adj[0][0] > adj[1][0]) swap(adj[0], adj[1]);",
            "\t\tvector<int> even_cycle{adj[0][1]};",
            "\t\tfor(auto i = adj[0][0]; i < adj[1][0]; ++ i) even_cycle.push_back(path[i]);",
            "\t\teven_cycle.push_back(adj[1][1]);",
            "\t\treturn {head, even_cycle};",
            "\t}",
            "};"
        ],
        "description": "tranxuanbach"
    }
}