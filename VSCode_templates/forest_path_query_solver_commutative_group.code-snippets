{
    "tranxuanbach": {
        "prefix": "forest_path_query_solver_commutative_group",
        "body": [
            "// Requires graph",
            "struct forest_path_query_solver_commutative_group{",
            "\tint n;",
            "\tvector<int> pv;",
            "\tvector<int> pos;",
            "\tvector<int> end;",
            "\tvector<int> root_of;",
            "\tvector<int> was;",
            "\tforest_path_query_solver_commutative_group(){ }",
            "\ttemplate<class T>",
            "\tforest_path_query_solver_commutative_group(const graph<T> &g){",
            "\t\tvector<int> src(g.n);",
            "\t\tiota(src.begin(), src.end(), 0);",
            "\t\t*this = forest_path_query_solver_commutative_group(g, src);",
            "\t}",
            "\ttemplate<class T>",
            "\tforest_path_query_solver_commutative_group(const graph<T> &g, const vector<int> &src){",
            "\t\tinit(g.n);",
            "\t\tbuild(g, src);",
            "\t}",
            "\tvoid init(int n){",
            "\t\tthis->n = n;",
            "\t\tpv.assign(n, -1);",
            "\t\tpos.assign(n, -1);",
            "\t\tend.assign(n, -1);",
            "\t\troot_of.assign(n, -1);",
            "\t\twas.assign(n, -2);",
            "\t\tattempt = -1;",
            "\t}",
            "\tint attempt;",
            "\t// Prepare a linear DS of length 2*g.n filled with identity elements of a commutative group",
            "\ttemplate<class T>",
            "\tvoid build(const graph<T> &g, const vector<int> &src){",
            "\t\tassert(g.n <= n);",
            "\t\t++ attempt;",
            "\t\tint it = 0;",
            "\t\tauto dfs = [&](auto self, int u, int pe)->void{",
            "\t\t\tassert(was[u] != attempt);",
            "\t\t\twas[u] = attempt;",
            "\t\t\tpos[u] = it ++;",
            "\t\t\tfor(auto id: g.adj[u]){",
            "\t\t\t\tif(pe == id || g.ignore && g.ignore(id)) continue;",
            "\t\t\t\tint v = g(u, id);",
            "\t\t\t\tpv[v] = u;",
            "\t\t\t\troot_of[v] = root_of[u];",
            "\t\t\t\tself(self, v, id);",
            "\t\t\t}",
            "\t\t\tend[u] = it ++;",
            "\t\t};",
            "\t\tfor(auto r: src){",
            "\t\t\tif(was[r] == attempt) continue;",
            "\t\t\troot_of[r] = r;",
            "\t\t\tdfs(dfs, r, -1);",
            "\t\t}",
            "\t}",
            "\t// Check if u is visited during the last build call",
            "\tbool visited(int u) const{",
            "\t\tassert(0 <= u && u < n);",
            "\t\treturn was[u] == attempt;",
            "\t}",
            "\t// Check if u is an ancestor of v in some spanning tree.",
            "\tbool ancestor_of(int u, int v) const{",
            "\t\tassert(visited(u) && visited(v));",
            "\t\treturn root_of[u] == root_of[v] && pos[u] <= pos[v] && end[v] <= end[u];",
            "\t}",
            "\t// f(p, c): DS[p] += c * x",
            "\t// Represents updating value of node u / parent edge of u by x",
            "\tvoid update(int u, auto f) const{",
            "\t\tassert(0 <= u && u < n);",
            "\t\tf(pos[u], 1), f(end[u], -1);",
            "\t}",
            "\t// Let res = identity",
            "\t// f(r, c): res += c * DS[0, r)",
            "\t// Final value of res represents the sum of values in the u-v path",
            "\t// 'lca' must be the lca of u and v",
            "\t// 3 or 4 f() calls",
            "\ttemplate<int VALS_IN_EDGES = false>",
            "\tvoid query(int u, int v, int lca, auto f) const{",
            "\t\tassert(ancestor_of(lca, u) && ancestor_of(lca, v));",
            "\t\tf(pos[u] + 1, 1), f(pos[v] + 1, 1);",
            "\t\tif constexpr(VALS_IN_EDGES) f(pos[lca] + 1, -2);",
            "\t\telse{",
            "\t\t\tf(pos[lca] + 1, -1);",
            "\t\t\tif(~pv[lca]) f(pos[pv[lca]], -1);",
            "\t\t}",
            "\t}",
            "};"
        ],
        "description": "tranxuanbach"
    }
}