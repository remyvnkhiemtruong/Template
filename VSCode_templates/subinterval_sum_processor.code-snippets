{
    "tranxuanbach": {
        "prefix": "subinterval_sum_processor",
        "body": [
            "template<class T, class F, class I>",
            "struct subinterval_sum_processor{",
            "#ifdef LOCAL",
            "\t#define ASSERT(x) assert(x);",
            "#else",
            "\t#define ASSERT(x) 42",
            "#endif",
            "\tarray<int, 3> size;",
            "#define D1(i) data[(i)]",
            "#define D2(i, j) data[(size[1] + 1) * (i) + (j)]",
            "#define D3(i, j, k) data[(size[2] + 1) * ((size[1] + 1) * (i) + (j)) + (k)]",
            "\tvector<T> data;",
            "\tF TT;",
            "\tT T_id;",
            "\tI Tinv;",
            "\tsubinterval_sum_processor(F TT, T T_id, I Tinv): TT(TT), T_id(T_id), Tinv(Tinv){ }",
            "\tsubinterval_sum_processor &operator=(const subinterval_sum_processor &sum){",
            "\t\tsize = sum.size;",
            "\t\tdata = sum.data;",
            "\t\treturn *this;",
            "\t}",
            "\ttemplate<class U>",
            "\tvoid build(int n, const vector<U> &a){",
            "\t\tASSERT((int)a.size() == n);",
            "\t\tsize = {n};",
            "\t\tdata.assign(n + 1, T_id);",
            "\t\tfor(auto i = 0; i < n; ++ i) D1(i + 1) = TT(D1(i), a[i]);",
            "\t}",
            "\ttemplate<class U>",
            "\tvoid build(int n, int m, const vector<vector<U>> &a){",
            "\t\tASSERT((int)a.size() == n);",
            "\t\tfor(const auto &b: a) ASSERT((int)b.size() == m);",
            "\t\tsize = {n, m};",
            "\t\tdata.assign((n + 1) * (m + 1), T_id);",
            "\t\tfor(auto i = 0; i < n; ++ i) for(auto j = 0; j < m; ++ j) D2(i + 1, j + 1) = a[i][j];",
            "\t\tfor(auto i = 0; i < n; ++ i) for(auto j = 0; j < m; ++ j) D2(i + 1, j + 1) = TT(D2(i, j + 1), D2(i + 1, j + 1));",
            "\t\tfor(auto i = 0; i < n; ++ i) for(auto j = 0; j < m; ++ j) D2(i + 1, j + 1) = TT(D2(i + 1, j), D2(i + 1, j + 1));",
            "\t}",
            "\ttemplate<class U>",
            "\tvoid build(int n, int m, int l, const vector<vector<vector<U>>> &a){",
            "\t\tASSERT((int)a.size() == n);",
            "\t\tfor(const auto &b: a){",
            "\t\t\tASSERT((int)b.size() == m);",
            "\t\t\tfor(const auto &c: b) ASSERT((int)c.size() == l);",
            "\t\t}",
            "\t\tsize = {n, m, l};",
            "\t\tfor(auto i = 0; i < n; ++ i) for(auto j = 0; j < m; ++ j) for(auto k = 0; k < l; ++ k) D3(i + 1, j + 1, k + 1) = a[i][j][k];",
            "\t\tfor(auto i = 0; i < n; ++ i) for(auto j = 0; j < m; ++ j) for(auto k = 0; k < l; ++ k) D3(i + 1, j + 1, k + 1) = TT(D3(i, j + 1, k + 1), D3(i + 1, j + 1, k + 1));",
            "\t\tfor(auto i = 0; i < n; ++ i) for(auto j = 0; j < m; ++ j) for(auto k = 0; k < l; ++ k) D3(i + 1, j + 1, k + 1) = TT(D3(i + 1, j, k + 1), D3(i + 1, j + 1, k + 1));",
            "\t\tfor(auto i = 0; i < n; ++ i) for(auto j = 0; j < m; ++ j) for(auto k = 0; k < l; ++ k) D3(i + 1, j + 1, k + 1) = TT(D3(i + 1, j + 1, k), D3(i + 1, j + 1, k + 1));",
            "\t}",
            "\tT prefix(int xr) const{",
            "\t\tASSERT((int)size.size() == 1);",
            "\t\tASSERT(0 <= xr && xr <= size[0]);",
            "\t\treturn D1(xr);",
            "\t}",
            "\tT query(int xl, int xr) const{",
            "\t\tASSERT((int)size.size() == 1);",
            "\t\tASSERT(0 <= xl && xl <= xr && xr <= size[0]);",
            "\t\treturn TT(Tinv(D1(xl)), D1(xr));",
            "\t}",
            "\tT prefix(int xr, int yr) const{",
            "\t\tASSERT((int)size.size() == 2);",
            "\t\tASSERT(0 <= xr && xr <= size[0]);",
            "\t\tASSERT(0 <= yr && yr <= size[1]);",
            "\t\treturn D2(xr, yr);",
            "\t}",
            "\tT query(int xl, int xr, int yl, int yr) const{",
            "\t\tASSERT((int)size.size() == 2);",
            "\t\tASSERT(0 <= xl && xl <= xr && xr <= size[0]);",
            "\t\treturn TT(TT(D2(xl, yl), Tinv(D2(xl, yr))), TT(Tinv(D2(xr, yl)), D2(xr, yr)));",
            "\t}",
            "\tT prefix(int xr, int yr, int zr) const{",
            "\t\tASSERT((int)size.size() == 3);",
            "\t\tASSERT(0 <= xr && xr <= size[0]);",
            "\t\tASSERT(0 <= yr && yr <= size[1]);",
            "\t\tASSERT(0 <= zr && zr <= size[2]);",
            "\t\treturn D3(xr, yr, zr);",
            "\t}",
            "\tT query(int xl, int xr, int yl, int yr, int zl, int zr) const{",
            "\t\tASSERT((int)size.size() == 3);",
            "\t\tASSERT(0 <= xl && xl <= xr && xr <= size[0]);",
            "\t\tASSERT(0 <= yl && yl <= yr && yr <= size[1]);",
            "\t\tASSERT(0 <= zl && zl <= zr && zr <= size[2]);",
            "\t\treturn TT(TT(TT(Tinv(D3(xl, yl, zl)), D3(xl, yl, zr)), TT(D3(xl, yr, zl), Tinv(D3(xl, yr, zr)))), TT(TT(D3(xr, yl, zl), Tinv(D3(xr, yl, zr))), TT(Tinv(D3(xr, yr, zl)), D3(xr, yr, zr)))",
            "\t\t);",
            "\t}",
            "#undef ASSERT",
            "#undef D1",
            "#undef D2",
            "#undef D3",
            "};",
            "",
            "template<class T, class F = plus<>, class I = negate<>>",
            "auto make_subinterval_sum_processor(F TT = plus<>(), T T_id = T{}, I Tinv = negate<>()){",
            "\treturn subinterval_sum_processor(TT, T_id, Tinv);",
            "}"
        ],
        "description": "tranxuanbach"
    }
}