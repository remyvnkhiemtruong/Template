{
    "tranxuanbach": {
        "prefix": "binary_string",
        "body": [
            "struct binary_string{",
            "\tstring data;",
            "\tbinary_string(){ }",
            "\t// Decode",
            "\tbinary_string(string s, string encoding = \"utf-8\"){",
            "\t\tif(encoding == \"utf-8\"){",
            "\t\t\t// Byte string",
            "\t\t\tfor(auto c: s){",
            "\t\t\t\tint x = c;",
            "\t\t\t\tfor(auto i = 7; i >= 0; -- i) data.push_back('0' + (x >> i & 1));",
            "\t\t\t}",
            "\t\t}",
            "\t\telse if(encoding == \"2\" || encoding == \"4\" || encoding == \"8\"){",
            "\t\t\tint w = __lg(encoding[0] - '0');",
            "\t\t\tfor(auto c: s){",
            "\t\t\t\tassert('0' <= c && c < encoding[0]);",
            "\t\t\t\tint x = c - '0';",
            "\t\t\t\tfor(auto i = w - 1; i >= 0; -- i) data.push_back('0' + (x >> i & 1));",
            "\t\t\t}",
            "\t\t}",
            "\t\telse if(encoding == \"10\"){",
            "\t\t\tfor(auto c: s) assert('0' <= c && c <= '9');",
            "\t\t\twhile(!s.empty()){",
            "\t\t\t\tdata.push_back('0' + (s.back() - '0' & 1));",
            "\t\t\t\tfor(auto i = 0, carry = 0; i < (int)s.size(); ++ i){",
            "\t\t\t\t\tint x = s[i] - '0' + carry;",
            "\t\t\t\t\ts[i] = '0' + x / 2;",
            "\t\t\t\t\tcarry = 10 * (x & 1);",
            "\t\t\t\t}",
            "\t\t\t\ts.erase(s.begin(), find_if(s.begin(), s.end(), [&](auto c){ return c != '0'; }));",
            "\t\t\t}",
            "\t\t\treverse(data.begin(), data.end());",
            "\t\t}",
            "\t\telse if(encoding == \"16\" || encoding == \"hex\" || encoding == \"bigint\" && s.substr(0, 2) == \"0x\"){",
            "\t\t\t// Hexadecimal String",
            "\t\t\t// '0'-'9': [0, 10)",
            "\t\t\t// 'A'-'F': [10, 16)",
            "\t\t\t// 'a'-'f': [10, 16)",
            "\t\t\tif(encoding == \"bigint\") s = s.substr(2);",
            "\t\t\tfor(auto c: s){",
            "\t\t\t\tint x;",
            "\t\t\t\tif(isdigit(c)) x = c - '0';",
            "\t\t\t\telse if(isupper(c)) x = c - 'A' + 10;",
            "\t\t\t\telse if(islower(c)) x = c - 'a' + 10;",
            "\t\t\t\telse assert(false);",
            "\t\t\t\tfor(auto i = 3; i >= 0; -- i) data.push_back('0' + (x >> i & 1));",
            "\t\t\t}",
            "\t\t}",
            "\t\telse if(encoding == \"64\" || encoding == \"base64\"){",
            "\t\t\t// Base64 encoding",
            "\t\t\t// 'A'-'Z': [0, 26)",
            "\t\t\t// 'a'-'z': [26, 52)",
            "\t\t\t// '0'-'9': [52, 62)",
            "\t\t\t// '+'    : 62",
            "\t\t\t// '/'    : 63",
            "\t\t\tfor(auto c: s){",
            "\t\t\t\tint x;",
            "\t\t\t\tif(isupper(c)) x = c - 'A';",
            "\t\t\t\telse if(islower(c)) x = 26 + c - 'a';",
            "\t\t\t\telse if(isdigit(c)) x = 52 + c - '0';",
            "\t\t\t\telse if(c == '+') x = 62;",
            "\t\t\t\telse if(c == '/') x = 63;",
            "\t\t\t\telse if(c == '=') break;",
            "\t\t\t\telse assert(false);",
            "\t\t\t\tfor(auto i = 5; i >= 0; -- i) data.push_back('0' + (x >> i & 1));",
            "\t\t\t}",
            "\t\t\tdata.resize(((int)data.size() + 7) / 8 * 8, '0');",
            "\t\t}",
            "\t\telse if(encoding.substr(0, 3) == \"rot\"){",
            "\t\t\t// Caesar-Cypher encryption",
            "\t\t\tint shift = (26 - stoi(encoding.substr(3)) % 26) % 26;",
            "\t\t\tfor(auto c: s){",
            "\t\t\t\tint x;",
            "\t\t\t\tif(!isalpha(c)) x = c;",
            "\t\t\t\telse if(islower(c)) x = c + shift <= 'z' ? c + shift : c + shift - 26;",
            "\t\t\t\telse x = c + shift <= 'Z' ? c + shift : c + shift - 26;",
            "\t\t\t\tfor(auto i = 7; i >= 0; -- i) data.push_back('0' + (x >> i & 1));",
            "\t\t\t}",
            "\t\t}",
            "\t\telse assert(false);",
            "\t}",
            "\tsize_t size() const{",
            "\t\treturn (int)data.size();",
            "\t}",
            "\tchar &operator[](int i){",
            "\t\treturn data[i];",
            "\t}",
            "\tchar operator[](int i) const{",
            "\t\treturn data[i];",
            "\t}",
            "\tfriend istream &operator>>(istream &in, binary_string &s){",
            "\t\treturn in >> s.data;",
            "\t}",
            "\tfriend ostream &operator<<(ostream &out, const binary_string &s){",
            "\t\treturn out << s.data;",
            "\t}",
            "#define applyop(x) \\",
            "binary_string &operator x(const binary_string &s){\\",
            "\tdata.resize(max(size(), s.size()), '0');\\",
            "\tfor(auto i = 0; i < (int)s.size(); ++ i) if(s[i] == '1') data[size() - (s.size() - i)] ^= '0' ^ '1';\\",
            "\treturn *this;\\",
            "}",
            "#define op(x, y) \\",
            "binary_string operator x(const binary_string &s) const{\\",
            "\treturn binary_string(*this) y s;\\",
            "}",
            "applyop(&=) applyop(^=) applyop(|=)",
            "op(&, &=) op(^, ^=) op(|, |=)",
            "#undef applyop",
            "#undef op",
            "\tstring encode(string encoding = \"utf-8\", bool upper = false) const{",
            "\t\tstring res;",
            "\t\tif(encoding == \"utf-8\"){",
            "\t\t\t// Byte string",
            "\t\t\tint w = 8;",
            "\t\t\tfor(auto i = (int)size(); i > 0; ){",
            "\t\t\t\tint x = 0;",
            "\t\t\t\tfor(auto j = 0; j < w && i > 0; ++ j){",
            "\t\t\t\t\t-- i;",
            "\t\t\t\t\tx |= data[i] - '0' << j;",
            "\t\t\t\t}",
            "\t\t\t\tif(x) res.push_back(x);",
            "\t\t\t}",
            "\t\t\treverse(res.begin(), res.end());",
            "\t\t}",
            "\t\telse if(encoding == \"2\") return data;",
            "\t\telse if(encoding == \"4\" || encoding == \"8\"){",
            "\t\t\tint w = __lg(encoding[0] - '0');",
            "\t\t\tassert((int)size() % w == 0);",
            "\t\t\tfor(auto i = (int)size(); i > 0; ){",
            "\t\t\t\tint x = 0;",
            "\t\t\t\tfor(auto j = 0; j < w && i > 0; ++ j){",
            "\t\t\t\t\t-- i;",
            "\t\t\t\t\tx |= data[i] - '0' << j;",
            "\t\t\t\t}",
            "\t\t\t\tres.push_back('0' + x);",
            "\t\t\t}",
            "\t\t\treverse(res.begin(), res.end());",
            "\t\t}",
            "\t\telse if(encoding == \"10\"){",
            "\t\t\tfor(auto c: data){",
            "\t\t\t\tint carry = 0;",
            "\t\t\t\tfor(auto &c: res){",
            "\t\t\t\t\tint x = c - '0' << 1 | carry;",
            "\t\t\t\t\tif(x >= 10){",
            "\t\t\t\t\t\tx -= 10;",
            "\t\t\t\t\t\tcarry = 1;",
            "\t\t\t\t\t}",
            "\t\t\t\t\telse carry = 0;",
            "\t\t\t\t\tc = '0' + x;",
            "\t\t\t\t}",
            "\t\t\t\tif(carry) res.insert(res.begin(), '1');",
            "\t\t\t\tif(c == '1'){",
            "\t\t\t\t\tif(res.empty()) res.push_back('1');",
            "\t\t\t\t\telse ++ res.back();",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t}",
            "\t\telse if(encoding == \"16\" || encoding == \"hex\"){",
            "\t\t\t// Hexadecimal String",
            "\t\t\t// '0'-'9': [0, 10)",
            "\t\t\t// 'A'-'F': [10, 16)",
            "\t\t\t// 'a'-'f': [10, 16)",
            "\t\t\tint w = 4;",
            "\t\t\tfor(auto i = (int)size(); i > 0; ){",
            "\t\t\t\tint x = 0;",
            "\t\t\t\tfor(auto j = 0; j < w && i > 0; ++ j){",
            "\t\t\t\t\t-- i;",
            "\t\t\t\t\tx |= data[i] - '0' << j;",
            "\t\t\t\t}",
            "\t\t\t\tif(x < 10) res.push_back('0' + x);",
            "\t\t\t\telse if(upper) res.push_back('A' + x - 10);",
            "\t\t\t\telse res.push_back('a' + x - 10);",
            "\t\t\t}",
            "\t\t\treverse(res.begin(), res.end());",
            "\t\t}",
            "\t\telse if(encoding == \"64\" || encoding == \"base64\"){",
            "\t\t\t// Base64 encoding",
            "\t\t\t// 'A'-'Z': [0, 26)",
            "\t\t\t// 'a'-'z': [26, 52)",
            "\t\t\t// '0'-'9': [52, 62)",
            "\t\t\t// '+'    : 62",
            "\t\t\t// '/'    : 63",
            "\t\t\tint w = 6;",
            "\t\t\tfor(auto i = (int)size(); i > 0; ){",
            "\t\t\t\tint x = 0;",
            "\t\t\t\tfor(auto j = 0; j < w && i > 0; ++ j){",
            "\t\t\t\t\t-- i;",
            "\t\t\t\t\tx |= data[i] - '0' << j;",
            "\t\t\t\t}",
            "\t\t\t\tif(x < 26) res.push_back('A' + x);",
            "\t\t\t\telse if(x < 52) res.push_back('a' + x - 26);",
            "\t\t\t\telse if(x < 62) res.push_back('0' + x - 52);",
            "\t\t\t\telse if(x == 62) res.push_back('+');",
            "\t\t\t\telse res.push_back('/');",
            "\t\t\t}",
            "\t\t\treverse(res.begin(), res.end());",
            "\t\t\tint rem = (4 - (int)res.size() % 4) % 4;",
            "\t\t\tres += string(rem, '=');",
            "\t\t}",
            "\t\telse if(encoding.substr(0, 3) == \"rot\"){",
            "\t\t\t// Caesar-Cypher encryption",
            "\t\t\tint w = 8, shift = (26 + stoi(encoding.substr(3)) % 26) % 26;",
            "\t\t\tfor(auto i = (int)size(); i > 0; ){",
            "\t\t\t\tchar c = 0;",
            "\t\t\t\tfor(auto j = 0; j < w && i > 0; ++ j){",
            "\t\t\t\t\t-- i;",
            "\t\t\t\t\tc |= data[i] - '0' << j;",
            "\t\t\t\t}",
            "\t\t\t\tif(!isalpha(c)) res.push_back(c);",
            "\t\t\t\telse if(islower(c)) res.push_back(c + shift <= 'z' ? c + shift : c + shift - 26);",
            "\t\t\t\telse res.push_back(c + shift <= 'Z' ? c + shift : c + shift - 26);",
            "\t\t\t\tres.push_back(c);",
            "\t\t\t}",
            "\t\t\treverse(res.begin(), res.end());",
            "\t\t}",
            "\t\telse assert(false);",
            "\t\treturn res;",
            "\t}",
            "\tbool is_printable_bytestring() const{",
            "\t\tint w = 8;",
            "\t\tfor(auto i = (int)size(); i > 0; ){",
            "\t\t\tint x = 0;",
            "\t\t\tfor(auto j = 0; j < w && i > 0; ++ j){",
            "\t\t\t\t-- i;",
            "\t\t\t\tx |= data[i] - '0' << j;",
            "\t\t\t}",
            "\t\t\tif(x <= 31 || x >= 127) return false;",
            "\t\t}",
            "\t\treturn true;",
            "\t}",
            "};"
        ],
        "description": "tranxuanbach"
    }
}