{
    "tranxuanbach": {
        "prefix": "reduce_quadratic_GF2_polynomial",
        "body": [
            "// Source: \"The Computational Complexity of (XOR, AND)-Counting Problems\"",
            "// Given a GF2-polynomial f over n variables of degree <= 2,",
            "// returns a tuple of",
            "// 1. a non-negative integer m (<= n),",
            "// 2. constant z \\in GF2,",
            "// 3. an m by n matrix mat of rank m, and",
            "// 4. a vector in GF2^m,",
            "// such that for a polynomial g over m variables where",
            "// 1. g(X_0, ..., X_{m-1}) = X_0 * X_1 + ... + X_{m-2} * X_{m-1} + z if m is even, and",
            "// 2. g(X_0, ..., X_{m-1}) = X_0 + X_1 * X_2 + ... + X_{m-2} * X_{m-1} + z otherwise,",
            "// the following holds for all vector v \\in GF2^n.",
            "// g(mat[0] * v + c[0], ..., mat[m-1] * v + c[m-1]) = f(v[0], ..., v[n-1])",
            "// Note that",
            "// (# of solutions of f) = 2^{n-m}*(# of solutions of g)",
            "// (# of solutions of g)",
            "// 1. = 2^{m-1} if m is odd,",
            "// 2. = 2^{m-1} + 2^{m/2-1} if m is even and z = 0, and",
            "// 3. = 2^{m-1} - 2^{m/2-1} if m is even and z = 1.",
            "// O(n^3 / w + (# of terms in f))",
            "template<size_t SZ>",
            "tuple<int, bool, vector<bitset<SZ>>, vector<int>>",
            "reduce_quadratic_GF2_polynomial(int n, vector<vector<int>> f){",
            "\tassert(n + 1 <= SZ);",
            "\tvector<bitset<SZ>> coef(n);",
            "\tbool z = 0;",
            "\tfor(auto &term: f){",
            "\t\tassert((int)term.size() <= 2);",
            "\t\tfor(auto i: term) assert(0 <= i && i < n);",
            "\t\tif(term.empty()){",
            "\t\t\tz ^= 1;",
            "\t\t\tcontinue;",
            "\t\t}",
            "\t\tif(term.front() == term.back()) coef[term[0]][n].flip();",
            "\t\telse coef[min(term[0], term[1])][max(term[0], term[1])].flip();",
            "\t}",
            "\tint m = 0;",
            "\tvector<bitset<SZ>> mat, ref, to_ref;",
            "\tauto mat_fix_column = [&](int j)->void{",
            "\t\tassert(m >= 1);",
            "\t\tassert(0 <= j && j < n);",
            "\t\tint start = 0, end = m - 1;",
            "\t\twhile(start < m && ref[start]._Find_first() < j) ++ start;",
            "\t\twhile(end >= 0 && !ref[end][j]) -- end;",
            "\t\tfor(auto i = start; i < end; ++ i) if(ref[i][j]){",
            "\t\t\tref[i] ^= ref[end];",
            "\t\t\tto_ref[i] ^= to_ref[end];",
            "\t\t}",
            "\t\tif(start + 1 < m) for(auto pivot = ref[start]._Find_first(); start + 1 < m && ref[start + 1]._Find_first() < pivot; ++ start){",
            "\t\t\tswap(ref[start], ref[start + 1]);",
            "\t\t\tswap(to_ref[start], to_ref[start + 1]);",
            "\t\t\tif(start + 1 == end) -- end;",
            "\t\t}",
            "\t\tif(end > 0 && ref[end]._Find_first() == j) for(auto pivot = j; end > 0 && ref[end - 1]._Find_first() > pivot; -- end){",
            "\t\t\tswap(ref[end], ref[end - 1]);",
            "\t\t\tswap(to_ref[end], to_ref[end - 1]);",
            "\t\t}",
            "\t};",
            "\tauto mat_flip = [&](int i, int j)->void{",
            "\t\tassert(0 <= i && i < m);",
            "\t\tassert(0 <= j && j <= n);",
            "\t\tmat[i][j].flip();",
            "\t\tfor(auto k = 0; k < m; ++ k) ref[k][j] = ref[k][j] ^ to_ref[k][i];",
            "\t};",
            "\tauto mat_add_column = [&](const bitset<SZ> &v, int j)->void{",
            "\t\tassert(0 <= j && j < n);",
            "\t\tfor(auto i = 0; i < m; ++ i){",
            "\t\t\tmat[i][j] = mat[i][j] ^ v[i];",
            "\t\t\tref[i][j] = ref[i][j] ^ (to_ref[i] & v).count() & 1;",
            "\t\t}",
            "\t};",
            "\tauto mat_insert_singleton_at_front = [&](int j)->void{",
            "\t\tassert(0 <= j && j < n);",
            "\t\tbitset<SZ> v;",
            "\t\tv.set(j);",
            "\t\tmat.insert(mat.begin(), v);",
            "\t\tref.insert(ref.begin(), v);",
            "\t\tfor(auto i = 0; i < m; ++ i) to_ref[i] <<= 1;",
            "\t\tv.reset(j), v.set(0);",
            "\t\tto_ref.insert(to_ref.begin(), v);",
            "\t\t++ m;",
            "\t};",
            "\tauto mat_insert_singleton_at_back = [&](int j, bool c)->void{",
            "\t\tassert(0 <= j && j < n);",
            "\t\tbitset<SZ> v;",
            "\t\tv.set(j), v[n] = c;",
            "\t\tmat.push_back(v);",
            "\t\tref.insert(ref.begin(), v);",
            "\t\tv.reset(j), v.reset(n), v.set(m);",
            "\t\tto_ref.insert(to_ref.begin(), v);",
            "\t\t++ m;",
            "\t};",
            "\tauto mat_insert_vector_at_back = [&](bitset<SZ> v)->void{",
            "\t\tmat.push_back(v);",
            "\t\tref.push_back(v);",
            "\t\tbitset<SZ> w;",
            "\t\tw.set(m);",
            "\t\tto_ref.push_back(w);",
            "\t\tfor(auto i = 0; i < m; ++ i){",
            "\t\t\tint pivot = ref[i]._Find_first();",
            "\t\t\tassert(pivot < n);",
            "\t\t\tif(ref[m][pivot]){",
            "\t\t\t\tref[m] ^= ref[i];",
            "\t\t\t\tto_ref[m] ^= to_ref[i];",
            "\t\t\t}",
            "\t\t}",
            "\t\tfor(auto i = m, pivot = ref[m]._Find_first(); i >= 1 && pivot < ref[i - 1]._Find_first(); -- i){",
            "\t\t\tswap(ref[i], ref[i - 1]);",
            "\t\t\tswap(to_ref[i], to_ref[i - 1]);",
            "\t\t}",
            "\t\t++ m;",
            "\t};",
            "\tauto mat_rotate = [&]()->void{",
            "\t\trotate(mat.begin(), mat.begin() + 1, mat.end());",
            "\t\tfor(auto i = 0; i < m; ++ i){",
            "\t\t\tbool c = to_ref[i][0];",
            "\t\t\tto_ref[i] >>= 1;",
            "\t\t\tto_ref[i][m - 1] = c;",
            "\t\t}",
            "\t};",
            "\tauto decompose = [&](bitset<SZ> v)->optional<bitset<SZ>>{",
            "\t\tbitset<SZ> in_recipe;",
            "\t\tfor(auto i = 0; i < m; ++ i){",
            "\t\t\tint pivot = ref[i]._Find_first();",
            "\t\t\tif(pivot == n) break;",
            "\t\t\tif(v[pivot]){",
            "\t\t\t\tv ^= ref[i];",
            "\t\t\t\tin_recipe ^= to_ref[i];",
            "\t\t\t}",
            "\t\t}",
            "\t\tif(v.count() == v[n]) return in_recipe;",
            "\t\telse return {};",
            "\t};",
            "\tfor(auto j = n - 1; j >= 0; -- j){",
            "\t\tif(coef[j].count() == coef[j][n]){",
            "\t\t\tif(!coef[j][n]) continue;",
            "\t\t\tif(m & 1){",
            "\t\t\t\tmat_flip(0, j);",
            "\t\t\t\tmat_fix_column(j);",
            "\t\t\t}",
            "\t\t\telse mat_insert_singleton_at_front(j);",
            "\t\t}",
            "\t\telse if(auto recipe_ptr = decompose(coef[j])){",
            "\t\t\tbitset<SZ> in_recipe = *recipe_ptr, delta;",
            "\t\t\tfor(auto i = m - 2; i >= 0; i -= 2){",
            "\t\t\t\tif(in_recipe[i] && in_recipe[i + 1]){",
            "\t\t\t\t\tdelta.set(i), delta.set(i + 1);",
            "\t\t\t\t\tif(mat[i][n] == mat[i + 1][n]) coef[j][n].flip();",
            "\t\t\t\t}",
            "\t\t\t\telse if(in_recipe[i] || in_recipe[i + 1]){",
            "\t\t\t\t\tdelta.set(i + in_recipe[i]);",
            "\t\t\t\t\tif(mat[i + !in_recipe[i]][n]) coef[j][n].flip();",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t\tmat_add_column(delta, j);",
            "\t\t\tmat_fix_column(j);",
            "\t\t\tif(m & 1){",
            "\t\t\t\tif(in_recipe[0]){",
            "\t\t\t\t\tz ^= coef[j][n];",
            "\t\t\t\t\tmat_rotate();",
            "\t\t\t\t\tif(coef[j][n]) mat_flip(m - 1, n);",
            "\t\t\t\t\tmat_insert_singleton_at_back(j, 1);",
            "\t\t\t\t\tmat_fix_column(j);",
            "\t\t\t\t}",
            "\t\t\t\telse if(coef[j][n]){",
            "\t\t\t\t\tmat_flip(0, j);",
            "\t\t\t\t\tmat_fix_column(j);",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t\telse if(coef[j][n]){",
            "\t\t\t\tmat_insert_singleton_at_front(j);",
            "\t\t\t\tmat_fix_column(j);",
            "\t\t\t}",
            "\t\t}",
            "\t\telse{",
            "\t\t\tmat_insert_singleton_at_back(j, 0);",
            "\t\t\tmat_insert_vector_at_back(coef[j]);",
            "\t\t}",
            "\t}",
            "\tvector<int> c(m);",
            "\tfor(auto i = 0; i < m; ++ i){",
            "\t\tc[i] = mat[i][n];",
            "\t\tmat[i].reset(n);",
            "\t}",
            "\treturn {m, z, mat, c};",
            "}"
        ],
        "description": "tranxuanbach"
    }
}