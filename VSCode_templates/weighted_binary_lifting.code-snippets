{
    "tranxuanbach": {
        "prefix": "weighted_binary_lifting",
        "body": [
            "// Requires graph",
            "template<class T, class F, int h = 20>",
            "struct weighted_binary_lifting{",
            "\tint n = 0;",
            "\tvector<int> depth;",
            "\tvector<array<int, h>> lift;",
            "\tvector<array<T, h>> liftval;",
            "\tF TT;",
            "\tT T_id;",
            "\tweighted_binary_lifting(){ }",
            "\t// pv: parent vertex (-1 if root of an arborescence)",
            "\tweighted_binary_lifting(const vector<int> &pv, const vector<T> &weight, F TT, T T_id): TT(TT), T_id(T_id){",
            "\t\tgraph<int> g((int)pv.size());",
            "\t\tvector<int> roots;",
            "\t\tfor(auto u = 0; u < (int)pv.size(); ++ u) if(~pv[u]) g.orient(pv[u], u); else roots.push_back(u);",
            "\t\t*this = weighted_binary_lifting(g, roots, weight, TT, T_id);",
            "\t}",
            "\ttemplate<class U>",
            "\tweighted_binary_lifting(const graph<U> &g, const vector<int> &roots, const vector<T> &weight, F TT, T T_id): TT(TT), T_id(T_id){",
            "\t\tvector<int> pv(g.n, -1), depth(g.n);",
            "\t\tauto dfs = [&](auto self, int u, int pe)->void{",
            "\t\t\tfor(auto id: g.adj[u]){",
            "\t\t\t\tif(id == pe || g.ignore && g.ignore(id)) continue;",
            "\t\t\t\tauto &e = g.edge[id];",
            "\t\t\t\tint v = u ^ e.from ^ e.to;",
            "\t\t\t\tdepth[v] = depth[u] + 1;",
            "\t\t\t\tpv[v] = u;",
            "\t\t\t\tself(self, v, id);",
            "\t\t\t}",
            "\t\t};",
            "\t\tfor(auto u: roots) assert(!depth[u]), pv[u] = u, dfs(dfs, u, -1);",
            "\t\t*this = weighted_binary_lifting(pv, depth, weight, TT, T_id);",
            "\t}",
            "\t// pv: parent vertex (-1 if root of an arborescence)",
            "\tweighted_binary_lifting(const vector<int> &pv, const vector<int> &depth, const vector<T> &weight, F TT, T T_id): n((int)pv.size()), depth(depth), TT(TT), T_id(T_id){",
            "\t\tlift.resize(n);",
            "\t\tliftval.resize(n);",
            "\t\tfor(auto u = 0; u < n; ++ u){",
            "\t\t\tlift[u][0] = ~pv[u] ? pv[u] : u;",
            "\t\t\tliftval[u][0] = weight[u];",
            "\t\t}",
            "\t\tfor(auto d = 1; d < h; ++ d) for(auto u = 0; u < n; ++ u){",
            "\t\t\tint p = lift[u][d - 1];",
            "\t\t\tliftval[u][d] = TT(liftval[u][d - 1], liftval[p][d - 1]);",
            "\t\t\tlift[u][d] = lift[p][d - 1];",
            "\t\t}",
            "\t}",
            "\tweighted_binary_lifting &operator=(const weighted_binary_lifting &otr){",
            "\t\tn = otr.n;",
            "\t\tdepth = otr.depth;",
            "\t\tlift = otr.lift;",
            "\t\tliftval = otr.liftval;",
            "\t\treturn *this;",
            "\t}",
            "\t// Index becomes the current number of nodes",
            "\t// O(log n)",
            "\tint add_root(T w){",
            "\t\tint u = n ++;",
            "\t\tdepth.push_back(0);",
            "\t\tlift.emplace_back();",
            "\t\tfill(lift.back().begin(), lift.back().end(), u);",
            "\t\tliftval.emplace_back();",
            "\t\tfill(liftval.back().begin(), liftval.back().end(), w);",
            "\t\treturn u;",
            "\t}",
            "\t// Index becomes the current number of nodes",
            "\t// O(log n)",
            "\tint add_child(int p, T w){",
            "\t\tassert(0 <= p && p < n);",
            "\t\tint u = n ++;",
            "\t\tdepth.push_back(depth[p] + 1);",
            "\t\tlift.emplace_back();",
            "\t\tlift[u][0] = p;",
            "\t\tliftval.emplace_back();",
            "\t\tliftval[u][0] = w;",
            "\t\tfor(auto d = 1; d < h; ++ d){",
            "\t\t\tint p = lift[u][d - 1];",
            "\t\t\tliftval[u][d] = TT(liftval[u][d - 1], liftval[p][d - 1]);",
            "\t\t\tlift[u][d] = lift[p][d - 1];",
            "\t\t}",
            "\t}",
            "\t// Get the k-th ancestor of u, along with the exclusive sum of weight up to it.",
            "\t// O(log n)",
            "\tpair<int, T> ancestor(int u, int k) const{",
            "\t\tassert(depth[u] >= k);",
            "\t\tT res = T_id;",
            "\t\tfor(auto d = 0; d < h; ++ d) if(k & 1 << d){",
            "\t\t\tres = TT(res, liftval[u][d]);",
            "\t\t\tu = lift[u][d];",
            "\t\t}",
            "\t\treturn {u, res};",
            "\t}",
            "\t// Assumes u and v lies on the same arboresence",
            "\t// O(log n)",
            "\ttuple<int, T, T> lca(int u, int v) const{",
            "\t\tbool swapped = false;",
            "\t\tif(depth[u] < depth[v]){",
            "\t\t\tswapped = true;",
            "\t\t\tswap(u, v);",
            "\t\t}",
            "\t\tT resl = T_id, resr = T_id;",
            "\t\ttie(u, resl) = ancestor(u, depth[u] - depth[v]);",
            "\t\tif(u != v){",
            "\t\t\tfor(auto d = h - 1; d >= 0; -- d) if(lift[u][d] != lift[v][d]){",
            "\t\t\t\tresl = TT(resl, liftval[u][d]);",
            "\t\t\t\tu = lift[u][d];",
            "\t\t\t\tresr = TT(resr, liftval[v][d]);",
            "\t\t\t\tv = lift[v][d];",
            "\t\t\t}",
            "\t\t\tresl = TT(resl, liftval[u][0]);",
            "\t\t\tu = lift[u][0];",
            "\t\t\tresr = TT(resr, liftval[v][0]);",
            "\t\t\tv = lift[v][0];",
            "\t\t\tassert(u == v);",
            "\t\t}",
            "\t\tif(swapped) swap(resl, resr);",
            "\t\treturn {u, resl, resr};",
            "\t}",
            "\t// Get # of edges between u and v",
            "\t// Assumes u and v lies on the same arboresence",
            "\t// O(log n)",
            "\tint steps(int u, int v, int w = -1) const{",
            "\t\treturn depth[u] + depth[v] - 2 * depth[~w ? w : get<0>(lca(u, v))];",
            "\t}",
            "\t// For an ancestor p of u, pred(p, sum) is T, ..., T, F, ..., F in decreasing order of depth. Returns the highest p with T",
            "\t// O(log n)",
            "\tpair<int, T> find_highest(int u, auto pred) const{",
            "\t\tT sum = T_id;",
            "\t\tassert(pred(u, sum));",
            "\t\tfor(auto d = h - 1; d >= 0; -- d) if(pred(lift[u][d], TT(sum, liftval[u][d]))){",
            "\t\t\tsum = TT(sum, liftval[u][d]);",
            "\t\t\tu = lift[d][u];",
            "\t\t}",
            "\t\treturn {u, sum};",
            "\t}",
            "};"
        ],
        "description": "tranxuanbach"
    }
}