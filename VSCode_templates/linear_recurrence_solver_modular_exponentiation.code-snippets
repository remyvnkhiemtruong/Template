{
    "tranxuanbach": {
        "prefix": "linear_recurrence_solver_modular_exponentiation",
        "body": [
            "// Store the linear recurrence relation of form \\sum_{t<=i<t+n} coef[i-t] * init[i] = init[t+n]",
            "// T must be of modular type",
            "// Requires modular, number_theoric_transform, and polynomial",
            "template<class T, class ntt>",
            "struct linear_recurrence_solver_modular_exponentiation{",
            "\tint n, power;",
            "\tvector<T> init, coef, gamma_hat, qinv_hat;",
            "\tlinear_recurrence_solver_modular_exponentiation(const vector<T> &init, const vector<T> &coef): n((int)coef.size()), power(1 << __lg(max(2 * n, 1)) + 1), init(init), coef(coef), gamma_hat(n + 1, 1), qinv_hat(n + 1, 1){",
            "\t\tassert(coef.size() == init.size());",
            "\t\tfor(auto i = 0; i < n; ++ i) gamma_hat[i] = qinv_hat[n - i] = -coef[i];",
            "\t\tgamma_hat.resize(power);",
            "\t\tntt::transform(gamma_hat);",
            "\t\t(qinv_hat = polynomial_base<T, ntt>(qinv_hat).inverse(power)).resize(power << 1);",
            "\t\tntt::transform(qinv_hat);",
            "\t}",
            "\t// Berlekamp Massey Algorithm",
            "\t// Find a minimum linear recurrence relation",
            "\t// T must ba a field",
            "\t// O(len(s) * (n + log(mod)))",
            "\tlinear_recurrence_solver_modular_exponentiation(const vector<T> &s){",
            "\t\tint sz = (int)size(s);",
            "\t\tvector<T> b = {-1};",
            "\t\tcoef = {-1};",
            "\t\tT y = 1;",
            "\t\tfor(auto t = 1; t <= sz; ++ t){",
            "\t\t\tint l = (int)coef.size(), m = (int)b.size();",
            "\t\t\tT x = 0;",
            "\t\t\tfor(auto i = 0; i < l; ++ i) x += coef[i] * s[t - l + i];",
            "\t\t\tb.push_back(0);",
            "\t\t\t++ m;",
            "\t\t\tif(x == 0) continue;",
            "\t\t\tT freq = x / y;",
            "\t\t\tif(l < m){",
            "\t\t\t\tauto tmp = coef;",
            "\t\t\t\tcoef.insert(coef.begin(), m - l, 0);",
            "\t\t\t\tfor(auto i = 0; i < m; ++ i) coef[m - 1 - i] -= freq * b[m - 1 - i];",
            "\t\t\t\tb = tmp;",
            "\t\t\t\ty = x;",
            "\t\t\t}",
            "\t\t\telse for(auto i = 0; i < m; ++ i) coef[l - 1 - i] -= freq * b[m - 1 - i];",
            "\t\t}",
            "\t\tcoef.pop_back();",
            "\t\t*this = {vector<T>(s.begin(), s.begin() + coef.size()), coef};",
            "\t}",
            "\t// O(n * log(n) * log(i))",
            "\ttemplate<class U>",
            "\tT operator[](U i){",
            "\t\tassert(0 <= i);",
            "\t\tif(i < n) return init[i];",
            "\t\tvector<T> p(power, 1), q;",
            "\t\tfor(auto bit = __lg(i); bit >= 0; -- bit){",
            "\t\t\tfor(auto &x: p) x *= x;",
            "\t\t\tif(i & U(1) << bit) for(auto t = 0; t < power; ++ t) p[t] *= t < power >> 1 ? ntt::root[(power >> 1) + t] : -ntt::root[t];",
            "\t\t\tq = p;",
            "\t\t\tfor(auto t = 0; t < power; ++ t) q[t] *= t < power >> 1 ? ntt::root[(power >> 1) + t] : -ntt::root[t];",
            "\t\t\treverse(q.begin() + 1, q.end());",
            "\t\t\tntt::double_up(q);",
            "\t\t\tfor(auto t = 0; t < power << 1; ++ t) q[t] *= qinv_hat[t];",
            "\t\t\tntt::transform(q, true);",
            "\t\t\tq.resize(power - n);",
            "\t\t\treverse(q.begin(), q.end());",
            "\t\t\tq.resize(power);",
            "\t\t\tntt::transform(q);",
            "\t\t\tfor(auto t = 0; t < power; ++ t) p[t] -= q[t] * gamma_hat[t];",
            "\t\t}",
            "\t\tntt::transform(p, true);",
            "\t\tT res = 0;",
            "\t\tfor(auto t = 0; t < n; ++ t) res += init[t] * p[t];",
            "\t\treturn res;",
            "\t}",
            "};"
        ],
        "description": "tranxuanbach"
    }
}