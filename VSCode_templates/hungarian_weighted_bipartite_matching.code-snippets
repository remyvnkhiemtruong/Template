{
    "tranxuanbach": {
        "prefix": "hungarian_weighted_bipartite_matching",
        "body": [
            "// Source: kactl",
            "// Assign 0 to the non-linked and negative pairs for maximum weight matching.",
            "// Assign -infty to the non-linked pairs for maximum weight maximum matching.",
            "// infity should satisfy infity > n * (max_weight - min_weight)",
            "// O(n^2 * m)",
            "template<class T>",
            "tuple<T, vector<int>, vector<int>> hungarian_weighted_bipartite_matching(vector<vector<T>> a){",
            "\tif(a.empty()) return {0, {}, {}};",
            "\tbool swapped = false;",
            "\tint n = (int)a.size() + 1, m = (int)a[0].size() + 1;",
            "\tfor(auto i = 0; i < n - 1; ++ i) for(auto j = 0; j < m - 1; ++ j) a[i][j] = -a[i][j];",
            "\tif(n > m){",
            "\t\tswap(n, m);",
            "\t\tswapped = true;",
            "\t\tvector b(n - 1, vector<T>(m - 1));",
            "\t\tfor(auto i = 0; i < n - 1; ++ i) for(auto j = 0; j < m - 1; ++ j) b[i][j] = a[j][i];",
            "\t\tswap(a, b);",
            "\t}",
            "\tvector<T> u(n), v(m);",
            "\tvector<int> p(m), mu(n - 1);",
            "\tfor(auto i = 1; i < n; ++ i){",
            "\t\tp[0] = i;",
            "\t\tint j0 = 0; // add \"dummy\" worker 0",
            "\t\tvector<T> dist(m, numeric_limits<T>::max());",
            "\t\tvector<int> pv(m, -1), done(m + 1);",
            "\t\tdo{ // dijkstra",
            "\t\t\tdone[j0] = true;",
            "\t\t\tint i0 = p[j0], j1;",
            "\t\t\tT delta = numeric_limits<T>::max();",
            "\t\t\tfor(auto j = 1; j < m; ++ j) if(!done[j]){",
            "\t\t\t\tT cur = a[i0 - 1][j - 1] - u[i0] - v[j];",
            "\t\t\t\tif(cur < dist[j]) dist[j] = cur, pv[j] = j0;",
            "\t\t\t\tif(dist[j] < delta) delta = dist[j], j1 = j;",
            "\t\t\t}",
            "\t\t\tfor(auto j = 0; j < m; ++ j){",
            "\t\t\t\tif(done[j]) u[p[j]] += delta, v[j] -= delta;",
            "\t\t\t\telse dist[j] -= delta;",
            "\t\t\t}",
            "\t\t\tj0 = j1;",
            "\t\t}while(p[j0]);",
            "\t\twhile(j0){ // update alternating path",
            "\t\t\tint j1 = pv[j0];",
            "\t\t\tp[j0] = p[j1], j0 = j1;",
            "\t\t}",
            "\t}",
            "\tvector<int> mv(m - 1, -1);",
            "\tfor(auto j = 1; j < m; ++ j) if(p[j]) mu[p[j] - 1] = j - 1, mv[j - 1] = p[j] - 1;",
            "\tif(swapped) swap(mu, mv);",
            "\treturn {v[0], mu, mv};",
            "}"
        ],
        "description": "tranxuanbach"
    }
}