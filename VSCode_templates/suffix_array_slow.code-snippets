{
    "tranxuanbach": {
        "prefix": "suffix_array_slow",
        "body": [
            "struct suffix_array_slow{",
            "\tint n;",
            "\t// data: sorted sequence of suffices including the empty suffix",
            "\t// pos[i]: position of the suffix i in the suffix array",
            "\t// lcp[i]: longest common prefix of data[i] and data[i + 1]",
            "\tvector<int> data, pos, lcp;",
            "\t// O(n * log(n))",
            "\ttemplate<class T>",
            "\tsuffix_array_slow(vector<T> s){",
            "\t\tauto cmpr = s;",
            "\t\tsort(cmpr.begin(), cmpr.end());",
            "\t\tfor(auto &c: s) c = lower_bound(cmpr.begin(), cmpr.end(), c) - cmpr.begin();",
            "\t\t*this = suffix_array_slow(s, (int)s.size());",
            "\t}",
            "\t// Assumes every element in s lies in [0, sigma)",
            "\t// O(n * log(n) + sigma)",
            "\ttemplate<class T>",
            "\tsuffix_array_slow(vector<T> s, int sigma): n((int)s.size()), lcp(n){",
            "\t\t++ sigma;",
            "\t\tfor(auto &c: s) ++ c;",
            "\t\ts.push_back(0);",
            "\t\ttie(data, pos) = sort_cyclic_shift(s, sigma);",
            "\t\tint k = 0;",
            "\t\tfor(auto i = 0; i <= n; ++ i){",
            "\t\t\tif(pos[i] == n){",
            "\t\t\t\tk = 0;",
            "\t\t\t\tcontinue;",
            "\t\t\t}",
            "\t\t\tint j = data[pos[i] + 1];",
            "\t\t\twhile(i + k <= n && j + k <= n && s[i + k] == s[j + k]){",
            "\t\t\t\t++ k;",
            "\t\t\t}",
            "\t\t\tlcp[pos[i]] = k;",
            "\t\t\tif(k) -- k;",
            "\t\t}",
            "\t}",
            "\t// O(n * log(n))",
            "\tpair<vector<int>, vector<int>> sort_cyclic_shift(const vector<int> &s, int sigma){",
            "\t\tint n = (int)s.size();",
            "\t\tvector<int> sa(n), pos(n), cnt(max(sigma, n));",
            "\t\tfor(auto i = 0; i < n; ++ i) ++ cnt[s[i]];",
            "\t\tfor(auto i = 1; i < sigma; ++ i) cnt[i] += cnt[i - 1];",
            "\t\tfor(auto i = 0; i < n; ++ i) sa[-- cnt[s[i]]] = i;",
            "\t\tpos[sa[0]] = 0;",
            "\t\tint classes = 1;",
            "\t\tfor(auto i = 1; i < n; ++ i){",
            "\t\t\tif(s[sa[i]] != s[sa[i - 1]]) ++ classes;",
            "\t\t\tpos[sa[i]] = classes - 1;",
            "\t\t}",
            "\t\tvector<int> dn(n), rn(n);",
            "\t\tfor(auto h = 0; 1 << h < n; ++ h){",
            "\t\t\tfor(auto i = 0; i < n; ++ i){",
            "\t\t\t\tdn[i] = sa[i] - (1 << h);",
            "\t\t\t\tif(dn[i] < 0) dn[i] += n;",
            "\t\t\t}",
            "\t\t\tfill(cnt.begin(), cnt.begin() + classes, 0);",
            "\t\t\tfor(auto i = 0; i < n; ++ i) ++ cnt[pos[dn[i]]];",
            "\t\t\tfor(auto i = 1; i < classes; ++ i) cnt[i] += cnt[i - 1];",
            "\t\t\tfor(auto i = n - 1; i >= 0; -- i) sa[-- cnt[pos[dn[i]]]] = dn[i];",
            "\t\t\trn[sa[0]] = 0;",
            "\t\t\tclasses = 1;",
            "\t\t\tfor(auto i = 1; i < n; ++ i){",
            "\t\t\t\tif(pos[sa[i - 1]] != pos[sa[i]] || pos[(sa[i - 1] + (1 << h)) % n] != pos[(sa[i] + (1 << h)) % n]) ++ classes;",
            "\t\t\t\trn[sa[i]] = classes - 1;",
            "\t\t\t}",
            "\t\t\tswap(pos, rn);",
            "\t\t}",
            "\t\treturn {sa, pos};",
            "\t}",
            "};"
        ],
        "description": "tranxuanbach"
    }
}