{
    "tranxuanbach": {
        "prefix": "range_mode_query_solver_online",
        "body": [
            "template<int B, class T>",
            "struct range_mode_query_solver_online{",
            "\tint n;",
            "\tvector<T> cmpr;",
            "\tvector<int> a, pos;",
            "\tvector<vector<int>> indices, block_mode, block_mode_freq;",
            "\t// O(n * B) time",
            "\t// O(n + (n/B)^2) space",
            "\trange_mode_query_solver_online(const vector<T> &_a): n((int)_a.size()), cmpr(_a), a(n), pos(n){",
            "\t\tsort(cmpr.begin(), cmpr.end());",
            "\t\tcmpr.erase(unique(cmpr.begin(), cmpr.end()), cmpr.end());",
            "\t\tindices.resize((int)cmpr.size());",
            "\t\tfor(auto i = 0; i < n; ++ i){",
            "\t\t\ta[i] = lower_bound(cmpr.begin(), cmpr.end(), _a[i]) - cmpr.begin();",
            "\t\t\tpos[i] = (int)indices[a[i]].size();",
            "\t\t\tindices[a[i]].push_back(i);",
            "\t\t}",
            "\t\tint C = (n + B - 1) / B;",
            "\t\tblock_mode.resize(C + 1), block_mode_freq.resize(C + 1);",
            "\t\tvector<int> cnt((int)cmpr.size());",
            "\t\tfor(auto l = 0; l <= C; ++ l){",
            "\t\t\tfill(cnt.begin(), cnt.end(), 0);",
            "\t\t\tblock_mode[l].resize(C - l + 1);",
            "\t\t\tblock_mode_freq[l].resize(C - l + 1);",
            "\t\t\tarray<int, 2> mx{-1, -1};",
            "\t\t\tfor(auto len = 1; len <= C - l; ++ len){",
            "\t\t\t\tfor(auto i = (l + len - 1) * B; i < min((l + len) * B, n); ++ i) mx = max(mx, array{++ cnt[a[i]], a[i]});",
            "\t\t\t\tblock_mode[l][len] = mx[1], block_mode_freq[l][len] = mx[0];",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "\t// Returns a pair (mode, frequency)",
            "\t// O(B)",
            "\tpair<T, int> query(int ql, int qr) const{",
            "\t\tassert(0 <= ql && ql <= qr && qr <= n);",
            "\t\tif(ql == qr) return {{}, 0};",
            "\t\tconst int bl = ql / B, br = qr / B;",
            "\t\tint mode = -1, freq = 0;",
            "\t\tif(bl == br){",
            "\t\t\tfor(auto i = ql; i < qr; ++ i){",
            "\t\t\t\tint x = a[i];",
            "\t\t\t\tif(pos[i] && ql <= indices[x][pos[i] - 1]) continue;",
            "\t\t\t\tif(freq && ((int)indices[x].size() <= pos[i] + freq - 1 || qr <= indices[x][pos[i] + freq - 1])) continue;",
            "\t\t\t\tmode = x;",
            "\t\t\t\twhile(pos[i] + freq < (int)indices[x].size() && indices[x][pos[i] + freq] < qr) ++ freq;",
            "\t\t\t}",
            "\t\t}",
            "\t\telse{",
            "\t\t\tmode = block_mode[bl + 1][br - bl - 1], freq = block_mode_freq[bl + 1][br - bl - 1];",
            "\t\t\tfor(auto i = ql; i < (bl + 1) * B; ++ i){",
            "\t\t\t\tint x = a[i];",
            "\t\t\t\tif(pos[i] && ql <= indices[x][pos[i] - 1]) continue;",
            "\t\t\t\tif(freq && ((int)indices[x].size() <= pos[i] + freq - 1 || qr <= indices[x][pos[i] + freq - 1])) continue;",
            "\t\t\t\tmode = x;",
            "\t\t\t\twhile(pos[i] + freq < (int)indices[x].size() && indices[x][pos[i] + freq] < qr) ++ freq;",
            "\t\t\t}",
            "\t\t\tfor(auto i = qr - 1; i >= br * B; -- i){",
            "\t\t\t\tint x = a[i];",
            "\t\t\t\tif(pos[i] + 1 < (int)indices[x].size() && indices[x][pos[i] + 1] < qr) continue;",
            "\t\t\t\tif(freq && (pos[i] - freq + 1 < 0 || indices[x][pos[i] - freq + 1] < ql)) continue;",
            "\t\t\t\tmode = x;",
            "\t\t\t\twhile(0 <= pos[i] - freq && ql <= indices[x][pos[i] - freq]) ++ freq;",
            "\t\t\t}",
            "\t\t}",
            "\t\treturn {cmpr[mode], freq};",
            "\t}",
            "};"
        ],
        "description": "tranxuanbach"
    }
}