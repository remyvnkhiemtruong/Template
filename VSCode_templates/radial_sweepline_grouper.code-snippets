{
    "tranxuanbach": {
        "prefix": "radial_sweepline_grouper",
        "body": [
            "struct radial_sweepline_grouper{",
            "\tvector<int> order;",
            "\tvector<int> group;",
            "\tradial_sweepline_grouper(){ }",
            "\t// Rotate the directed line in counterclockwise order by pi, starting from dir",
            "\t// Whenever there's a new state defined by 4-tuple of {head(0), left(1), tail(2), right(3)} appear, process() gets called",
            "\t// The points overlapping with o are not counted",
            "\t// insert(g, i): insert the i-th point to group g",
            "\t// -> Guaranteed that the i-th point is not assigned",
            "\t// erase(g, i): erase the i-th point from group g",
            "\t// -> Guaranteed that the i-th point is assigned to group g",
            "\t// process(i): report that a new state has been found with the line parallel to o-a[i]",
            "\t// O(n * log(n))",
            "\t// Requires point",
            "\ttemplate<class T>",
            "\tvoid run(const point<T> &o, const vector<point<T>> &a, const point<T> &dir, auto insert, auto erase, auto process){",
            "\t\tassert(dir != point<T>{});",
            "\t\tint n = (int)a.size();",
            "\t\torder.resize(n), group.resize(n);",
            "\t\tiota(order.begin(), order.end(), 0);",
            "\t\torder.erase(remove_if(order.begin(), order.end(), [&](int i){ return o == a[i]; }), order.end());",
            "\t\tfor(auto i: order){",
            "\t\t\tif(colinear(o, o + dir, a[i])){",
            "\t\t\t\tif(dir * (a[i] - o) > 0) insert(group[i] = 0, i);",
            "\t\t\t\telse insert(group[i] = 2, i);",
            "\t\t\t}",
            "\t\t\telse{",
            "\t\t\t\tif(counterclockwise(o, o + dir, a[i])) insert(group[i] = 1, i);",
            "\t\t\t\telse insert(group[i] = 3, i);",
            "\t\t\t}",
            "\t\t}",
            "\t\tauto cmp = [&](int i, int j)->bool{",
            "\t\t\treturn (",
            "\t\t\t\t(group[i] < 2 ? a[i] - o : o - a[i]) ^",
            "\t\t\t\t(group[j] < 2 ? a[j] - o : o - a[j])",
            "\t\t\t) > 0;",
            "\t\t};",
            "\t\tsort(order.begin(), order.end(), cmp);",
            "\t\tfor(auto l = 0, m = (int)(find_if(order.begin(), order.end(), [&](int i){ return group[i] & 1; }) - order.begin()), r = 0; l < (int)order.size(); ){",
            "\t\t\tif(l < m) process(order[l]);",
            "\t\t\tr = m;",
            "\t\t\twhile(r < (int)order.size() && !cmp(order[m], order[r])) ++ r;",
            "\t\t\tfor(auto t = l; t < r; ++ t){",
            "\t\t\t\tint i = order[t];",
            "\t\t\t\terase(group[i], i);",
            "\t\t\t\tinsert(group[i] = group[i] + 3 & 3, i);",
            "\t\t\t}",
            "\t\t\tl = m;",
            "\t\t\tm = r;",
            "\t\t}",
            "\t}",
            "};"
        ],
        "description": "tranxuanbach"
    }
}