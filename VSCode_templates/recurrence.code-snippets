{
    "tranxuanbach": {
        "prefix": "recurrence",
        "body": [
            "template<typename T>",
            "struct recurrence{",
            "\tint N;",
            "\tvector<T> init, coef; // linear recurrence relation of form Sum{t<=i<t+N}( coef[i] * A[i] ) = A[t+N] for all t",
            "\trecurrence(const vector<T> &init, const vector<T> &coef): N((int)coef.size()), init(init), coef(coef){ }",
            "\trecurrence(const vector<T> &s){ // Berlekamp Massey Algorithm / guess the minimal linear recurrence ",
            "\t\tint n = (int)s.size();",
            "\t\tN = 0;",
            "\t\tvector<T> B(n), C;",
            "\t\tcoef.resize(n);",
            "\t\tcoef[0] = B[0] = 1;",
            "\t\tT b = 1;",
            "\t\tfor(int i = 0, m = 0; i < n; ++ i){",
            "\t\t\t++ m;",
            "\t\t\tT d = s[i];",
            "\t\t\tfor(int j = 1; j <= N; ++ j) d += coef[j] * s[i - j];",
            "\t\t\tif(d == T(0)) continue;",
            "\t\t\tC = coef;",
            "\t\t\tT c = d / b;",
            "\t\t\tfor(int j = m; j < n; ++ j) coef[j] -= c * B[j - m];",
            "\t\t\tif(2 * N > i) continue;",
            "\t\t\tN = i + 1 - N, B = C, b = d, m = 0;",
            "\t\t}",
            "\t\tcoef.resize(N + 1), coef.erase(coef.begin());",
            "\t\tfor(auto &x: coef) x = -x;",
            "\t\treverse(coef.begin(), coef.end());",
            "\t\tinit.resize(N);",
            "\t\tfor(int i = 0; i < N; ++ i) init[i] = s[i];",
            "\t}",
            "\tT operator[](long long n) const{",
            "\t\tauto combine = [&](const vector<T> &a, const vector<T> &b){",
            "\t\t\tvector<T> res(2 * N + 1);",
            "\t\t\tfor(int i = 0; i <= N; ++ i) for(int j = 0; j <= N; ++ j) res[i + j] += a[i] * b[j];",
            "\t\t\tfor(int i = N << 1; i > N; -- i) for(int j = 0; j < N; ++ j) res[i - 1 - j] += res[i] * coef[N - 1 - j];",
            "\t\t\tres.resize(N + 1);",
            "\t\t\treturn res;",
            "\t\t};",
            "\t\tvector<T> pol(N + 1), e(pol);",
            "\t\tpol[0] = e[1] = 1;",
            "\t\tfor(++ n; n; n >>= 1, e = combine(e, e)) if(n & 1) pol = combine(pol, e);",
            "\t\tT res = 0;",
            "\t\tfor(int i = 0; i < N; ++ i) res += pol[i + 1] * init[i];",
            "\t\treturn res;",
            "\t} // N^2 log n (or N log N log n with FFT)",
            "};"
        ],
        "description": "tranxuanbach"
    }
}