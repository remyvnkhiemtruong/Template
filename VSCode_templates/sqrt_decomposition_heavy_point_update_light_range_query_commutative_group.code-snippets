{
    "tranxuanbach": {
        "prefix": "sqrt_decomposition_heavy_point_update_light_range_query_commutative_group",
        "body": [
            "template<int B, class T, class F, class I>",
            "struct sqrt_decomposition_heavy_point_update_light_range_query_commutative_group{",
            "\tint n, nB;",
            "\tvector<T> data, dataB;",
            "\tF TT; // commutative group operation",
            "\tT T_id; // commutative group identity",
            "\tI Tinv; // commutative group inverse",
            "\t// O(n)",
            "\tsqrt_decomposition_heavy_point_update_light_range_query_commutative_group(F TT, T T_id, I Tinv): TT(TT), T_id(T_id), Tinv(Tinv){ }",
            "\t// O(n)",
            "\tvoid build(int n){",
            "\t\tbuild(vector<T>(n, T_id));",
            "\t}",
            "\t// O(n)",
            "\tvoid build(int n, T x){",
            "\t\tbuild(vector<T>(n, x));",
            "\t}",
            "\t// O(n)",
            "\ttemplate<class U>",
            "\tvoid build(const vector<U> &a){",
            "\t\tn = (int)a.size();",
            "\t\tnB = (n + B) / B;",
            "\t\tdata.assign((B + 1) * nB, T_id);",
            "\t\tdataB.assign(nB + 1, T_id);",
            "\t\tfor(auto iB = 0; iB < nB; ++ iB){",
            "\t\t\tfor(auto i = B * iB; i < B * (iB + 1); ++ i) data[iB + i + 1] = TT(data[iB + i], i < n ? (T)a[i] : T_id);",
            "\t\t\tdataB[iB + 1] = TT(dataB[iB], data[iB + B * (iB + 1)]);",
            "\t\t}",
            "\t}",
            "\t// O(B + n/B)",
            "\tvoid update(int p, T x){",
            "\t\tassert(0 <= p && p < n);",
            "\t\tint pB = p / B;",
            "\t\tfor(auto i = p; i < B * (pB + 1); ++ i) data[pB + i + 1] = TT(data[pB + i + 1], x);",
            "\t\tfor(auto iB = pB; iB < nB; ++ iB) dataB[iB + 1] = TT(dataB[iB], data[iB + B * (iB + 1)]);",
            "\t}",
            "\t// O(1)",
            "\tT prefix(int r) const{",
            "\t\tassert(0 <= r && r <= n);",
            "\t\tint rB = r / B;",
            "\t\treturn TT(dataB[rB], data[rB + r]);",
            "\t}",
            "\t// O(1)",
            "\tT query(int l, int r) const{",
            "\t\tassert(0 <= l && l <= r && r <= n);",
            "\t\tif(l == r) return T_id;",
            "\t\treturn TT(prefix(r), Tinv(prefix(l)));",
            "\t}",
            "\tfriend ostream &operator<<(ostream &out, const sqrt_decomposition_heavy_point_update_light_range_query_commutative_group<B, T, F, I> &sqrt_decomp){",
            "\t\tout << \"{\";",
            "\t\tfor(auto i = 0; i < sqrt_decomp.n; ++ i){",
            "\t\t\tout << sqrt_decomp.query(i, i + 1);",
            "\t\t\tif(i + 1 < sqrt_decomp.n) out << \", \";",
            "\t\t}",
            "\t\treturn out << \"}\";",
            "\t}",
            "};",
            "",
            "template<int B, class T, class F = plus<>, class I = negate<>>",
            "auto make_sqrt_decomposition_hpu_lrq(F TT = plus<>(), T T_id = 0, I Tinv = negate<>()){",
            "\treturn sqrt_decomposition_heavy_point_update_light_range_query_commutative_group(TT, T_id, Tinv);",
            "}"
        ],
        "description": "tranxuanbach"
    }
}