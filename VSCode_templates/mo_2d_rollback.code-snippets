{
    "tranxuanbach": {
        "prefix": "mo_2d_rollback",
        "body": [
            "template<int BX>",
            "struct mo_2d_rollback{",
            "\tvector<array<int, 3>> query;",
            "\tvoid insert(int qi, int l, int r){",
            "\t\tquery.push_back({l, r, qi});",
            "\t}",
            "\tvoid solve(auto insert_left, auto insert_right, auto time, auto reverse_to, auto answer){",
            "\t\tauto cmp = [&](const auto &p, const auto &q)->bool{",
            "\t\t\treturn p[0] / BX != q[0] / BX ? p < q : p[1] < q[1];",
            "\t\t};",
            "\t\tsort(query.begin(), query.end(), cmp);",
            "\t\tint init = time();",
            "\t\tfor(auto [ql, qr, qi]: query){",
            "\t\t\tif(qr - ql <= BX){",
            "\t\t\t\tfor(auto i = ql; i < qr; ++ i) insert_right(i);",
            "\t\t\t\tanswer(qi);",
            "\t\t\t\treverse_to(init);",
            "\t\t\t}",
            "\t\t}",
            "\t\tint last_block = -1, l, r;",
            "\t\tfor(auto [ql, qr, qi]: query){",
            "\t\t\tif(qr - ql <= BX) continue;",
            "\t\t\tint block = ql / BX;",
            "\t\t\tif(block != last_block){",
            "\t\t\t\treverse_to(init);",
            "\t\t\t\tl = (block + 1) * BX, r = qr;",
            "\t\t\t\tfor(auto i = l; i < r; ++ i) insert_right(i);",
            "\t\t\t\tlast_block = block;",
            "\t\t\t}",
            "\t\t\twhile(r < qr) insert_right(r ++);",
            "\t\t\tint t = time();",
            "\t\t\tfor(auto i = l - 1; i >= ql; -- i) insert_left(i);",
            "\t\t\tanswer(qi);",
            "\t\t\treverse_to(t);",
            "\t\t}",
            "\t}",
            "};"
        ],
        "description": "tranxuanbach"
    }
}