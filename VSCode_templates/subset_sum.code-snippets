{
    "tranxuanbach": {
        "prefix": "subset_sum",
        "body": [
            "// Given a set of items where i-th item has non-negative weight w[i],",
            "// find a subset S such that \\sum_{i \\in S} w[i] <= threshold and \\sum_{i \\in S} w[i] is maximized",
            "struct subset_sum{",
            "\tvector<int> _pref;",
            "\tvector<vector<int>> _dp;",
            "\tvector<vector<array<int, 2>>> _prev;",
            "\t// w[i] < weight_bound",
            "\t// O(n * bound)",
            "\tvoid run_for_bounded_weight(const vector<int> &w, int weight_bound, int threshold){",
            "\t\tassert(weight_bound > 0 && threshold >= 0);",
            "\t\tfor(auto x: w) assert(0 <= x && x < weight_bound);",
            "\t\tint n = (int)w.size();",
            "\t\t_pref = {0};",
            "\t\twhile((int)_pref.size() - 1 < n && _pref.back() + w[(int)_pref.size() - 1] <= threshold) _pref.push_back(_pref.back() + w[(int)_pref.size() - 1]);",
            "\t\tconst int cut = (int)_pref.size() - 1;",
            "\t\tif(n == cut){",
            "\t\t\tsubset_weight = _pref[n];",
            "\t\t\tin_subset.assign(n, true);",
            "\t\t\tsubset.resize(n);",
            "\t\t\tiota(subset.begin(), subset.end(), 0);",
            "\t\t\treturn;",
            "\t\t}",
            "\t\t_dp.assign(n - cut + 1, vector<int>(weight_bound << 1));",
            "\t\t_prev.assign(n - cut + 1, vector<array<int, 2>>(weight_bound << 1, {-1, -1}));",
            "\t\tfill(_dp[0].begin() + weight_bound, _dp[0].end(), 0);",
            "\t\t_dp[0][weight_bound - 1] = cut + 1;",
            "\t\tfor(auto x = weight_bound - 1; x >= 0; -- x) if(_dp[0][x]) for(auto l = _dp[0][x] - 1; l >= 1; -- l){",
            "\t\t\tif(x >= w[l - 1] && _dp[0][x - w[l - 1]] < l){",
            "\t\t\t\t_dp[0][x - w[l - 1]] = l;",
            "\t\t\t\t_prev[0][x - w[l - 1]] = {0, x};",
            "\t\t\t}",
            "\t\t}",
            "\t\tfor(auto r = 1; r <= n - cut; ++ r) for(auto x = 2 * weight_bound - 1; x >= 0; -- x){",
            "\t\t\tif(_dp[r][x] < _dp[r - 1][x]){",
            "\t\t\t\t_dp[r][x] = _dp[r - 1][x];",
            "\t\t\t\t_prev[r][x] = {r - 1, x};",
            "\t\t\t}",
            "\t\t\tif(x >= w[cut + r - 1] && _dp[r][x] < _dp[r - 1][x - w[cut + r - 1]]){",
            "\t\t\t\t_dp[r][x] = _dp[r - 1][x - w[cut + r - 1]];",
            "\t\t\t\t_prev[r][x] = {r - 1, x - w[cut + r - 1]};",
            "\t\t\t}",
            "\t\t\tfor(auto l = _dp[r][x] - 1; l >= max(1, _dp[r - 1][x]); -- l) if(x >= w[l - 1] && _dp[r][x - w[l - 1]] < l){",
            "\t\t\t\t_dp[r][x - w[l - 1]] = l;",
            "\t\t\t\t_prev[r][x - w[l - 1]] = {r, x};",
            "\t\t\t}",
            "\t\t}",
            "\t\tsubset_weight = threshold;",
            "\t\twhile(!_dp[n - cut][subset_weight - _pref.back() + weight_bound - 1]) -- subset_weight;",
            "\t\tin_subset.assign(n, false);",
            "\t\tfill(in_subset.begin(), in_subset.begin() + cut, true);",
            "\t\tfor(auto r = n - cut, weight = subset_weight - _pref.back() + weight_bound - 1; ; ){",
            "\t\t\tauto [nr, nweight] = _prev[r][weight];",
            "\t\t\tif(!~nr) break;",
            "\t\t\tif(r == nr) in_subset[_dp[r][weight] - 1] = false;",
            "\t\t\telse if(weight != nweight) in_subset[cut + r - 1] = true;",
            "\t\t\tr = nr, weight = nweight;",
            "\t\t}",
            "\t\tsubset.clear();",
            "\t\tfor(auto i = 0; i < n; ++ i) if(in_subset[i]) subset.push_back(i);",
            "\t}",
            "\t// O(n * log(\\sum{w}) + SZ * sqrt(\\sum{w}) / bit_width)",
            "\ttemplate<size_t SZ>",
            "\tvoid run_for_small_total_weight(const vector<int> &w, int threshold){",
            "\t\tassert(threshold >= 0 && threshold < SZ);",
            "\t\tint n = (int)w.size();",
            "\t\tmap<int, list<list<int>>> mp;",
            "\t\tfor(auto i = 0; i < (int)w.size(); ++ i) mp[w[i]].push_back({i});",
            "\t\tvector<pair<int, list<int>>> ordered_pool;",
            "\t\twhile(!mp.empty()){",
            "\t\t\tint weight = mp.begin()->first;",
            "\t\t\tauto &from = mp.begin()->second;",
            "\t\t\tif((int)from.size() >= 3){",
            "\t\t\t\tauto &to = mp[weight << 1];",
            "\t\t\t\twhile((int)from.size() >= 3){",
            "\t\t\t\t\tnext(from.begin())->splice(next(from.begin())->begin(), from.front());",
            "\t\t\t\t\tfrom.pop_front();",
            "\t\t\t\t\tto.push_back(move(from.front()));",
            "\t\t\t\t\tfrom.pop_front();",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t\tfor(; !from.empty(); from.pop_front()) ordered_pool.push_back({weight, move(from.front())});",
            "\t\t\tmp.erase(mp.begin());",
            "\t\t}",
            "\t\tvector<int> first_appear(threshold + 1, -1);",
            "\t\tbitset<SZ> dp{};",
            "\t\tdp[0] = true;",
            "\t\tfor(auto i = 0; i < (int)ordered_pool.size(); ++ i){",
            "\t\t\tint weight = ordered_pool[i].first;",
            "\t\t\tauto dp_next = dp | dp << weight;",
            "\t\t\tauto dif = dp ^ dp_next;",
            "\t\t\tfor(auto x = dif._Find_first(); x <= threshold; x = dif._Find_next(x)) first_appear[x] = i;",
            "\t\t\tdp = dp_next;",
            "\t\t}",
            "\t\tsubset_weight = threshold;",
            "\t\twhile(!dp[subset_weight]) -- subset_weight;",
            "\t\tin_subset.assign(n, false);",
            "\t\tsubset.clear();",
            "\t\tfor(auto weight = subset_weight; weight; ){",
            "\t\t\tint i = first_appear[weight];",
            "\t\t\tfor(auto ind: ordered_pool[i].second){",
            "\t\t\t\tin_subset[ind] = true;",
            "\t\t\t\tsubset.push_back(ind);",
            "\t\t\t}",
            "\t\t\tweight -= ordered_pool[i].first;",
            "\t\t}",
            "\t}",
            "\tint subset_weight;",
            "\tvector<int> in_subset, subset;",
            "};"
        ],
        "description": "tranxuanbach"
    }
}