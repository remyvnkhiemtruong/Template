{
    "tranxuanbach": {
        "prefix": "graph",
        "body": [
            "template<class T>",
            "struct graph{",
            "\tusing Weight_t = T;",
            "\tstruct Edge_t{",
            "\t\tint from, to;",
            "\t\tT cost;",
            "\t};",
            "\tint n;",
            "\tvector<Edge_t> edge;",
            "\tvector<vector<int>> adj;",
            "\tfunction<bool(int)> ignore;",
            "\tgraph(int n = 1): n(n), adj(n){",
            "\t\tassert(n >= 1);",
            "\t}",
            "\tgraph(const vector<vector<int>> &adj, bool undirected = true): n((int)adj.size()), adj(n){",
            "\t\tassert(n >= 1);",
            "\t\tif(undirected){",
            "\t\t\tfor(auto u = 0; u < n; ++ u) for(auto v: adj[u]) if(u < v) link(u, v);",
            "\t\t}",
            "\t\telse for(auto u = 0; u < n; ++ u) for(auto v: adj[u]) orient(u, v);",
            "\t}",
            "\tgraph(const vector<vector<pair<int, T>>> &adj, bool undirected = true): n((int)adj.size()), adj(n){",
            "\t\tassert(n >= 1);",
            "\t\tif(undirected){",
            "\t\t\tfor(auto u = 0; u < n; ++ u) for(auto [v, w]: adj[u]) if(u < v) link(u, v, w);",
            "\t\t}",
            "\t\telse for(auto u = 0; u < n; ++ u) for(auto [v, w]: adj[u]) orient(u, v, w);",
            "\t}",
            "\tgraph(int n, vector<array<int, 2>> &edge, bool undirected = true): n(n), adj(n){",
            "\t\tassert(n >= 1);",
            "\t\tfor(auto [u, v]: edge) undirected ? link(u, v) : orient(u, v);",
            "\t}",
            "\tgraph(int n, vector<tuple<int, int, T>> &edge, bool undirected = true): n(n), adj(n){",
            "\t\tassert(n >= 1);",
            "\t\tfor(auto [u, v, w]: edge) undirected ? link(u, v, w) : orient(u, v, w);",
            "\t}",
            "\tint operator()(int u, int id) const{",
            "\t\t#ifdef LOCAL",
            "\t\tassert(0 <= id && id < (int)edge.size());",
            "\t\tassert(edge[id].from == u || edge[id].to == u);",
            "\t\t#endif",
            "\t\treturn u ^ edge[id].from ^ edge[id].to;",
            "\t}",
            "\tint link(int u, int v, T w = {}){ // insert an undirected edge",
            "\t\tint id = (int)edge.size();",
            "\t\tadj[u].push_back(id), adj[v].push_back(id), edge.push_back({u, v, w});",
            "\t\treturn id;",
            "\t}",
            "\tint orient(int u, int v, T w = {}){ // insert a directed edge",
            "\t\tint id = (int)edge.size();",
            "\t\tadj[u].push_back(id), edge.push_back({u, v, w});",
            "\t\treturn id;",
            "\t}",
            "\tvoid clear(){",
            "\t\tfor(auto [u, v, w]: edge){",
            "\t\t\tadj[u].clear();",
            "\t\t\tadj[v].clear();",
            "\t\t}",
            "\t\tedge.clear();",
            "\t\tignore = {};",
            "\t}",
            "\tgraph transpose() const{ // the transpose of the directed graph",
            "\t\tgraph res(n);",
            "\t\tfor(auto id = 0; id < (int)edge.size(); ++ id){",
            "\t\t\tif(ignore && ignore(id)) continue;",
            "\t\t\tres.orient(edge[id].to, edge[id].from, edge[id].cost);",
            "\t\t}",
            "\t\treturn res;",
            "\t}",
            "\tint degree(int u) const{ // the degree (outdegree if directed) of u (without the ignoration rule)",
            "\t\treturn (int)adj[u].size();",
            "\t}",
            "\t// The adjacency list is sorted for each vertex.",
            "\tvector<vector<int>> get_adjacency_list() const{",
            "\t\tvector<vector<int>> res(n);",
            "\t\tfor(auto u = 0; u < n; ++ u) for(auto id: adj[u]){",
            "\t\t\tif(ignore && ignore(id)) continue;",
            "\t\t\tres[(*this)(u, id)].push_back(u);",
            "\t\t}",
            "\t\treturn res;",
            "\t}",
            "\tvoid set_ignoration_rule(const function<bool(int)> &f){",
            "\t\tignore = f;",
            "\t}",
            "\tvoid reset_ignoration_rule(){",
            "\t\tignore = nullptr;",
            "\t}",
            "\tfriend ostream &operator<<(ostream &out, const graph &g){",
            "\t\tfor(auto id = 0; id < (int)g.edge.size(); ++ id){",
            "\t\t\tif(g.ignore && g.ignore(id)) continue;",
            "\t\t\tauto &e = g.edge[id];",
            "\t\t\tout << \"{\" << e.from << \", \" << e.to << \", \" << e.cost << \"}\\n\";",
            "\t\t}",
            "\t\treturn out;",
            "\t}",
            "};"
        ],
        "description": "tranxuanbach"
    }
}