{
    "tranxuanbach": {
        "prefix": "minimum_cost_maximum_flow_push_relabel",
        "body": [
            "// Source: https://github.com/dacin21/dacin21_codebook/blob/master/flow/mincost.cpp",
            "// Requires flow_network_weighted",
            "template<class T, class C>",
            "struct minimum_cost_maximum_flow_push_relabel{",
            "\tflow_network_weighted<T, C> &F;",
            "\tminimum_cost_maximum_flow_push_relabel(flow_network_weighted<T, C> &F): F(F){ }",
            "\tvector<int> in_q, cur;",
            "\tvector<T> ex;",
            "\tvector<C> h;",
            "\tvector<vector<int>> hs;",
            "\tvector<int> co;",
            "\tT _maximum_flow(int source, int sink){",
            "\t\tint n = F.n;",
            "\t\tex.assign(n, 0);",
            "\t\th.assign(n, 0);",
            "\t\ths.assign(n << 1, {});",
            "\t\tco.assign(n << 1, 0);",
            "\t\tcur.assign(n, 0);",
            "\t\th[source] = n;",
            "\t\tex[sink] = 1;",
            "\t\tco[0] = n - 1;",
            "\t\tfor(auto id: F.adj[source]){",
            "\t\t\tauto &e = F.edge[id];",
            "\t\t\tT delta = e.capacity - e.flow;",
            "\t\t\tif(!ex[e.to] && delta > 0) hs[h[e.to]].push_back(e.to);",
            "\t\t\tF.add_flow(id, delta);",
            "\t\t\tex[e.from] -= delta, ex[e.to] += delta;",
            "\t\t}",
            "\t\tif(!hs[0].empty()){",
            "\t\t\tfor(auto hi = 0; hi >= 0; ){",
            "\t\t\t\tint u = hs[hi].back();",
            "\t\t\t\ths[hi].pop_back();",
            "\t\t\t\twhile(ex[u] > 0){",
            "\t\t\t\t\tif(cur[u] == (int)F.adj[u].size()){",
            "\t\t\t\t\t\th[u] = numeric_limits<C>::max();",
            "\t\t\t\t\t\tfor(auto i = 0; i < (int)F.adj[u].size(); ++ i){",
            "\t\t\t\t\t\t\tauto &e = F.edge[F.adj[u][i]];",
            "\t\t\t\t\t\t\tif(e.flow < e.capacity && h[u] > h[e.to] + 1) h[u] = h[e.to] + 1, cur[u] = i;",
            "\t\t\t\t\t\t}",
            "\t\t\t\t\t\tif(++ co[h[u]], !-- co[hi] && hi < n) for(auto i = 0; i < n; ++ i) if(hi < h[i] && h[i] < n){",
            "\t\t\t\t\t\t\t-- co[h[i]];",
            "\t\t\t\t\t\t\th[i] = n + 1;",
            "\t\t\t\t\t\t}",
            "\t\t\t\t\t\thi = h[u];",
            "\t\t\t\t\t}",
            "\t\t\t\t\telse{",
            "\t\t\t\t\t\tint id = F.adj[u][cur[u]];",
            "\t\t\t\t\t\tauto &e = F.edge[id];",
            "\t\t\t\t\t\tif(e.flow < e.capacity && h[u] == h[e.to] + 1){",
            "\t\t\t\t\t\t\tT delta = min(ex[u], e.capacity - e.flow);",
            "\t\t\t\t\t\t\tif(!ex[e.to] && delta > 0) hs[h[e.to]].push_back(e.to);",
            "\t\t\t\t\t\t\tF.add_flow(id, delta);",
            "\t\t\t\t\t\t\tex[e.from] -= delta, ex[e.to] += delta;",
            "\t\t\t\t\t\t}",
            "\t\t\t\t\t\telse ++ cur[u];",
            "\t\t\t\t\t}",
            "\t\t\t\t}",
            "\t\t\t\twhile(hi >= 0 && hs[hi].empty()) -- hi;",
            "\t\t\t}",
            "\t\t}",
            "\t\treturn -ex[source];",
            "\t}",
            "\t// O(flow * log(n * max_edge_cost)) = O(n^3 * log(n * C))",
            "\tpair<T, C> solve(int source, int sink){",
            "\t\tassert(0 <= min(source, sink) && max(source, sink) < F.n && source != sink);",
            "\t\tstatic constexpr int scale = 2;",
            "\t\tF.clear_flow();",
            "\t\tfor(auto &e: F.edge) e.cost *= F.n;",
            "\t\tT flow = _maximum_flow(source, sink);",
            "\t\tint n = F.n;",
            "\t\th.assign(n, 0);",
            "\t\tex.assign(n, 0);",
            "\t\tin_q.assign(n, false);",
            "\t\tcur.assign(n, 0);",
            "\t\tC eps = 0;",
            "\t\tfor(auto &e: F.edge) eps = max(eps, abs(e.cost));",
            "\t\tauto push = [&](int id, T f)->void{",
            "\t\t\tauto &e = F.edge[id];",
            "\t\t\tf = min(f, e.capacity - e.flow);",
            "\t\t\tF.add_flow(id, f);",
            "\t\t\tex[e.from] -= f, ex[e.to] += f;",
            "\t\t};",
            "\t\tauto relabel = [&](int u)->void{",
            "\t\t\tC h_next = numeric_limits<C>::min() / 2;",
            "\t\t\tfor(auto i = 0; i < (int)F.adj[u].size(); ++ i){",
            "\t\t\t\tauto &e = F.edge[F.adj[u][i]];",
            "\t\t\t\tif(e.flow < e.capacity && h_next < h[e.to] - e.cost) h_next = h[e.to] - e.cost, cur[u] = i;",
            "\t\t\t}",
            "\t\t\th[u] = h_next - eps;",
            "\t\t};",
            "\t\tvector<int> q;",
            "\t\tfor(; eps; eps >>= scale){",
            "\t\t\tq.clear();",
            "\t\t\tfill(cur.begin(), cur.end(), 0);",
            "\t\t\tfor(auto u = 0; u < n; ++ u) for(auto id: F.adj[u]){",
            "\t\t\t\tauto &e = F.edge[id];",
            "\t\t\t\tif(h[u] + e.cost - h[e.to] < 0 && e.flow < e.capacity) push(id, e.capacity - e.flow);",
            "\t\t\t}",
            "\t\t\tfor(auto u = 0; u < n; ++ u) if(ex[u] > 0){",
            "\t\t\t\tq.push_back(u);",
            "\t\t\t\tin_q[u] = true;",
            "\t\t\t}",
            "\t\t\tfor(auto beg = 0; beg < (int)q.size(); ++ beg){",
            "\t\t\t\tint u = q[beg];",
            "\t\t\t\tin_q[u] = false;",
            "\t\t\t\twhile(ex[u] > 0){",
            "\t\t\t\t\tif(cur[u] == (int)F.adj[u].size()) relabel(u);",
            "\t\t\t\t\tfor(auto &i = cur[u], deg = (int)F.adj[u].size(); i < deg; ++ i){",
            "\t\t\t\t\t\tint id = F.adj[u][i];",
            "\t\t\t\t\t\tauto &e = F.edge[id];",
            "\t\t\t\t\t\tif(h[u] + e.cost - h[e.to] < 0){",
            "\t\t\t\t\t\t\tpush(id, ex[u]);",
            "\t\t\t\t\t\t\tif(ex[e.to] > 0 && !in_q[e.to]){",
            "\t\t\t\t\t\t\t\tq.push_back(e.to);",
            "\t\t\t\t\t\t\t\tin_q[e.to] = true;",
            "\t\t\t\t\t\t\t}",
            "\t\t\t\t\t\t\tif(ex[u] == 0) break;",
            "\t\t\t\t\t\t}",
            "\t\t\t\t\t}",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t\tif(eps > 1 && eps >> scale == 0) eps = 1 << scale;",
            "\t\t}",
            "\t\tfor(auto &e: F.edge) e.cost /= n;",
            "\t\tF.cost /= n;",
            "\t\treturn {flow, F.cost};",
            "\t}",
            "};"
        ],
        "description": "tranxuanbach"
    }
}