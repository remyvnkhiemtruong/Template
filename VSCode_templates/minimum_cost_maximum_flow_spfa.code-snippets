{
    "tranxuanbach": {
        "prefix": "minimum_cost_maximum_flow_spfa",
        "body": [
            "// Requires flow_network_weighted",
            "template<class T, class C>",
            "struct minimum_cost_maximum_flow_spfa{",
            "\tstatic constexpr T eps = (T) 1e-9;",
            "\tflow_network_weighted<T, C> &F;",
            "\tminimum_cost_maximum_flow_spfa(flow_network_weighted<T, C> &F): F(F), d(F.n), in_queue(F.n), pe(F.n), state(F.n){ }",
            "\t// type 0: augment as long as a path exists",
            "\t// type 1: augment as long as a negative cost path exists",
            "\tvector<C> d;",
            "\tvector<int> in_queue, q, pe;",
            "\ttemplate<bool type>",
            "\tT _expath(int source, int sink, T threshold){",
            "\t\tfill(d.begin(), d.end(), numeric_limits<C>::max());",
            "\t\tq = {source};",
            "\t\td[source] = 0;",
            "\t\tin_queue[source] = true;",
            "\t\tbool found = false;",
            "\t\tfor(auto beg = 0; beg < (int)q.size(); ++ beg){",
            "\t\t\tint u = q[beg];",
            "\t\t\tif(u == sink) found = true;",
            "\t\t\tin_queue[u] = false;",
            "\t\t\tfor(auto id: F.adj[u]){",
            "\t\t\t\tauto &e = F.edge[id];",
            "\t\t\t\tif(e.capacity - e.flow > eps && d[u] + e.cost < d[e.to]){",
            "\t\t\t\t\td[e.to] = d[u] + e.cost;",
            "\t\t\t\t\tpe[e.to] = id;",
            "\t\t\t\t\tif(!in_queue[e.to]){",
            "\t\t\t\t\t\tq.push_back(e.to);",
            "\t\t\t\t\t\tin_queue[e.to] = true;",
            "\t\t\t\t\t}",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t}",
            "\t\tif(found){",
            "\t\t\tT push = threshold;",
            "\t\t\tint u = sink;",
            "\t\t\twhile(u != source){",
            "\t\t\t\tauto &e = F.edge[pe[u]];",
            "\t\t\t\tpush = min(push, e.capacity - e.flow);",
            "\t\t\t\tu = e.from;",
            "\t\t\t}",
            "\t\t\tu = sink;",
            "\t\t\tassert(push >= 0);",
            "\t\t\tif(type && d[sink] >= 0) return false;",
            "\t\t\twhile(u != source){",
            "\t\t\t\tF.add_flow(pe[u], push);",
            "\t\t\t\tu = F.edge[pe[u]].from;",
            "\t\t\t}",
            "\t\t\treturn push;",
            "\t\t}",
            "\t\treturn 0;",
            "\t}",
            "\tvector<int> stack, state;",
            "\tbool try_cycle_cancelling(){",
            "\t\tfill(d.begin(), d.end(), 0);",
            "\t\tq.resize(F.n);",
            "\t\tiota(q.begin(), q.end(), 0);",
            "\t\tfill(in_queue.begin(), in_queue.end(), false);",
            "\t\tfill(pe.begin(), pe.end(), -1);",
            "\t\tint beg = 0, iter = 0;",
            "\t\tauto detect_cycle = [&]()->bool{",
            "\t\t\tstack.clear();",
            "\t\t\tfill(state.begin(), state.end(), 0);",
            "\t\t\tfor(auto s = 0; s < F.n; ++ s){",
            "\t\t\t\tif(state[s]) continue;",
            "\t\t\t\tfor(auto u = s; ; ){",
            "\t\t\t\t\tif(state[u]){",
            "\t\t\t\t\t\tif(state[u] == 1){",
            "\t\t\t\t\t\t\tstack.erase(stack.begin(), find(stack.begin(), stack.end(), u));",
            "\t\t\t\t\t\t\tassert(!stack.empty() && stack[0] == u);",
            "\t\t\t\t\t\t\tT flow = numeric_limits<T>::max();",
            "\t\t\t\t\t\t\tfor(auto u: stack){",
            "\t\t\t\t\t\t\t\tauto &e = F.edge[pe[u]];",
            "\t\t\t\t\t\t\t\tflow = min(flow, e.capacity - e.flow);",
            "\t\t\t\t\t\t\t}",
            "\t\t\t\t\t\t\tfor(auto u: stack) F.add_flow(pe[u], flow);",
            "\t\t\t\t\t\t\treturn true;",
            "\t\t\t\t\t\t}",
            "\t\t\t\t\t\tbreak;",
            "\t\t\t\t\t}",
            "\t\t\t\t\tstack.push_back(u);",
            "\t\t\t\t\tstate[u] = 1;",
            "\t\t\t\t\tif(!~pe[u]) break;",
            "\t\t\t\t\tu = F.edge[pe[u]].from;",
            "\t\t\t\t}",
            "\t\t\t\tfor(auto u: stack) state[u] = 2;",
            "\t\t\t\tstack.clear();",
            "\t\t\t}",
            "\t\t\treturn false;",
            "\t\t};",
            "\t\twhile(beg < (int)q.size()){",
            "\t\t\tint u = q[beg ++];",
            "\t\t\tin_queue[u] = false;",
            "\t\t\tfor(auto id: F.adj[u]){",
            "\t\t\t\tauto &e = F.edge[id];",
            "\t\t\t\tif(e.capacity - e.flow > eps && d[u] + e.cost < d[e.to]){",
            "\t\t\t\t\td[e.to] = d[u] + e.cost;",
            "\t\t\t\t\tpe[e.to] = id;",
            "\t\t\t\t\tif(++ iter == F.n){",
            "\t\t\t\t\t\titer = 0;",
            "\t\t\t\t\t\tif(detect_cycle()) return true;",
            "\t\t\t\t\t}",
            "\t\t\t\t\tif(!in_queue[e.to]){",
            "\t\t\t\t\t\tq.push_back(e.to);",
            "\t\t\t\t\t\tin_queue[e.to] = true;",
            "\t\t\t\t\t}",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t}",
            "\t\treturn detect_cycle();",
            "\t}",
            "\t// type 0: min cost max flow",
            "\t// type 1: min cost flow",
            "\t// O(Augmenting_Paths * SPFA), additional O(SPFA * Cycle_cnt) if negative cycle exists",
            "\ttemplate<bool type = false, bool negative_cycle_presence = false>",
            "\tpair<T, C> solve(int source, int sink, T threshold = numeric_limits<T>::max()){",
            "\t\tassert(0 <= min(source, sink) && max(source, sink) < F.n && source != sink && threshold >= 0);",
            "\t\tF.clear_flow();",
            "\t\tif(negative_cycle_presence) while(try_cycle_cancelling());",
            "\t\tT flow = 0;",
            "\t\tfor(T delta; threshold > 0 && (delta = _expath<type>(source, sink, threshold)); flow += delta, threshold -= delta);",
            "\t\treturn {flow, F.cost};",
            "\t}",
            "};"
        ],
        "description": "tranxuanbach"
    }
}