{
    "tranxuanbach": {
        "prefix": "lca_solver_offline",
        "body": [
            "// Requires graph",
            "struct lca_solver_offline{",
            "\tint n;",
            "\tvector<int> p, dp;",
            "\tvector<vector<array<int, 2>>> q;",
            "\tlca_solver_offline(int n): n(n), p(n), dp(n), q(n), was(n){ }",
            "\tvoid query(int qi, int u, int v){",
            "\t\tassert(0 <= min(u, v) && max(u, v) < n);",
            "\t\tq[u].push_back({v, qi});",
            "\t\tq[v].push_back({u, qi});",
            "\t}",
            "\tint root(int u){",
            "\t\treturn p[u] < 0 ? u : (p[u] = root(p[u]));",
            "\t}",
            "\tvoid merge(int u, int v){",
            "\t\tu = root(u);",
            "\t\tv = root(v);",
            "\t\tif(p[u] > p[v]) swap(u, v);",
            "\t\tp[u] += p[v];",
            "\t\tp[v] = u;",
            "\t}",
            "\tint it = 0;",
            "\tvector<int> was;",
            "\t// O(((# of vertices visited) + alpha(n)) * q)",
            "\tvoid solve(const graph<int> &g, const vector<int> &roots, auto answer){",
            "\t\tint n = g.n;",
            "\t\t++ it;",
            "\t\tfor(auto r: roots){",
            "\t\t\tif(was[r] == it) continue;",
            "\t\t\ty_combinator([&](auto self, int u)->void{",
            "\t\t\t\twas[u] = it;",
            "\t\t\t\tp[u] = -1;",
            "\t\t\t\tdp[u] = u;",
            "\t\t\t\tfor(auto id: g.adj[u]){",
            "\t\t\t\t\tif(g.ignore && g.ignore(id)) continue;",
            "\t\t\t\t\tint v = g(u, id);",
            "\t\t\t\t\tif(was[v] == it) continue;",
            "\t\t\t\t\tself(v);",
            "\t\t\t\t\tmerge(u, v);",
            "\t\t\t\t\tdp[root(u)] = u;",
            "\t\t\t\t}",
            "\t\t\t\tfor(auto [v, qi]: q[u]){",
            "\t\t\t\t\tif(was[v] != it) continue;",
            "\t\t\t\t\tanswer(qi, dp[root(v)]);",
            "\t\t\t\t}",
            "\t\t\t})(r);",
            "\t\t}",
            "\t}",
            "\tvoid solve_all(const graph<int> &g, auto answer){",
            "\t\tvector<int> roots(g.n);",
            "\t\tiota(roots.begin(), roots.end(), 0);",
            "\t\tsolve(g, roots, answer);",
            "\t}",
            "};"
        ],
        "description": "tranxuanbach"
    }
}