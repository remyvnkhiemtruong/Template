{
    "tranxuanbach": {
        "prefix": "bipolar_orientation",
        "body": [
            "// Source: https://en.wikipedia.org/wiki/Bipolar_orientation#Algorithms",
            "// Requires graph",
            "struct bipolar_orientation{",
            "\tint n, attempt;",
            "\tvector<int> pv;",
            "\tvector<int> order;",
            "\tvector<int> pos;",
            "\tvector<int> low;",
            "\tvector<int> was;",
            "\tvector<int> sign;",
            "\tvector<list<int>::iterator> bipolar_pos;",
            "\tvoid init(int n){",
            "\t\tthis->n = n;",
            "\t\tpv.assign(n, -1);",
            "\t\torder.clear();",
            "\t\tpos.assign(n, -1);",
            "\t\tlow.assign(n, -1);",
            "\t\twas.assign(n, -2);",
            "\t\tsign.assign(n, 1);",
            "\t\tbipolar_pos.resize(n);",
            "\t}",
            "\ttemplate<class T>",
            "\toptional<vector<int>> _run(const graph<T> &g, int from, int to){",
            "\t\tint root_deg = 0;",
            "\t\tauto recurse = [&](auto self, int u, int pe)->bool{",
            "\t\t\tpos[u] = low[u] = (int)order.size();",
            "\t\t\torder.push_back(u);",
            "\t\t\twas[u] = attempt;",
            "\t\t\tfor(auto i = -(u == from); i < (int)g.adj[u].size(); ++ i){",
            "\t\t\t\tint id = ~i ? g.adj[u][i] : -1;",
            "\t\t\t\tif(~id && (g.ignore && g.ignore(id) || id == pe)) continue;",
            "\t\t\t\tint v = ~id ? g(u, id) : to;",
            "\t\t\t\tif(was[v] != attempt){",
            "\t\t\t\t\twas[v] = attempt;",
            "\t\t\t\t\tpos[v] = -1;",
            "\t\t\t\t}",
            "\t\t\t\tif(~pos[v]) low[u] = min(low[u], pos[v]);",
            "\t\t\t\telse{",
            "\t\t\t\t\tif(u == from) ++ root_deg;",
            "\t\t\t\t\tpv[v] = u;",
            "\t\t\t\t\tif(!self(self, v, id)) return false;",
            "\t\t\t\t\tlow[u] = min(low[u], low[v]);",
            "\t\t\t\t\tif(pos[u] < low[v] || pos[u] == low[v] && u != from) return false;",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t\treturn true;",
            "\t\t};",
            "\t\tpv[from] = -1;",
            "\t\tif(!recurse(recurse, from, -1) || root_deg != 1) return {};",
            "\t\tsign[from] = -1;",
            "\t\tlist<int> bipolar_ordering{from, to};",
            "\t\tbipolar_pos[from] = bipolar_ordering.begin();",
            "\t\tbipolar_pos[to] = prev(bipolar_ordering.end());",
            "\t\tfor(auto i = 2; i < (int)order.size(); ++ i){",
            "\t\t\tint u = order[i];",
            "\t\t\tauto p = sign[order[low[u]]] == -1 ? bipolar_pos[pv[u]] : next(bipolar_pos[pv[u]]);",
            "\t\t\tbipolar_pos[u] = bipolar_ordering.insert(p, u);",
            "\t\t\tsign[pv[u]] = -sign[order[low[u]]];",
            "\t\t}",
            "\t\treturn vector<int>(bipolar_ordering.begin(), bipolar_ordering.end());",
            "\t}",
            "\t// Returns a bipolar orientation if the connected component of 'from' after adding the edge from-to is 2-vertex-connected",
            "\t// O(n + m) where n and m are the number of reachable vertices and edges respectively",
            "\ttemplate<class T>",
            "\toptional<vector<int>> run(const graph<T> &g, int from, int to){",
            "\t\tassert(g.n <= n && 0 <= min(from, to) && max(from, to) < g.n && from != to);",
            "\t\torder.clear();",
            "\t\t++ attempt;",
            "\t\treturn _run(g, from, to);",
            "\t}",
            "\t// Check if u is visited during the last run-like call.",
            "\tbool visited(int u) const{",
            "\t\tassert(0 <= u && u < n);",
            "\t\treturn was[u] == attempt;",
            "\t}",
            "};"
        ],
        "description": "tranxuanbach"
    }
}