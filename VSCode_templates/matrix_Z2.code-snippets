{
    "tranxuanbach": {
        "prefix": "matrix_Z2",
        "body": [
            "template<size_t SZ>",
            "struct matrix_Z2_base{",
            "\tint n, m;",
            "\tvector<bitset<SZ>> data;",
            "\tbitset<SZ> &operator[](int i){",
            "\t\tassert(0 <= i && i < n);",
            "\t\treturn data[i];",
            "\t}",
            "\tconst bitset<SZ> &operator[](int i) const{",
            "\t\tassert(0 <= i && i < n);",
            "\t\treturn data[i];",
            "\t}",
            "\tmatrix_Z2_base &inplace_slice(int il, int ir, int jl, int jr){",
            "\t\tassert(0 <= il && il <= ir && ir <= n);",
            "\t\tassert(0 <= jl && jl <= jr && jr <= m);",
            "\t\tn = ir - il, m = jr - jl;",
            "\t\tif(il > 0) for(auto i = 0; i < n; ++ i) swap(data[i], data[il + i]);",
            "\t\tdata.resize(n);",
            "\t\tfor(auto &row: data) row = row << SZ - jr >> jl;",
            "\t\treturn *this;",
            "\t}",
            "\tmatrix_Z2_base slice(int il, int ir, int jl, int jr) const{",
            "\t\treturn matrix_Z2_base(*this).inplace_slice(il, ir, jl, jr);",
            "\t}",
            "\tmatrix_Z2_base &inplace_row_slice(int il, int ir){",
            "\t\tassert(0 <= il && il <= ir && ir <= n);",
            "\t\tn = ir - il;",
            "\t\tif(il > 0) for(auto i = 0; i < n; ++ i) swap(data[i], data[il + i]);",
            "\t\tdata.resize(n);",
            "\t\treturn *this;",
            "\t}",
            "\tmatrix_Z2_base row_slice(int il, int ir) const{",
            "\t\treturn matrix_Z2_base(*this).inplace_row_slice(il, ir);",
            "\t}",
            "\tmatrix_Z2_base &inplace_column_slice(int jl, int jr){",
            "\t\tassert(0 <= jl && jl <= jr && jr <= m);",
            "\t\tm = jr - jl;",
            "\t\tfor(auto &row: data) row = row << SZ - jr >> jl;",
            "\t\treturn *this;",
            "\t}",
            "\tmatrix_Z2_base column_slice(int jl, int jr) const{",
            "\t\treturn matrix_Z2_base(*this).inplace_column_slice(jl, jr);",
            "\t}",
            "\tbool operator==(const matrix_Z2_base &a) const{",
            "\t\tassert(n == a.n && m == a.m);",
            "\t\treturn data == a.data;",
            "\t}",
            "\tbool operator!=(const matrix_Z2_base &a) const{",
            "\t\tassert(n == a.n && m == a.m);",
            "\t\treturn data != a.data;",
            "\t}",
            "\tmatrix_Z2_base &operator+=(const matrix_Z2_base &M){",
            "\t\tassert(n == M.n && m == M.m);",
            "\t\tfor(auto i = 0; i < n; ++ i) data[i] ^= M[i];",
            "\t\treturn *this;",
            "\t}",
            "\tmatrix_Z2_base operator+(const matrix_Z2_base &M) const{",
            "\t\treturn matrix_Z2_base(*this) += M;",
            "\t}",
            "\tmatrix_Z2_base &operator-=(const matrix_Z2_base &M){",
            "\t\tassert(n == M.n && m == M.m);",
            "\t\tfor(auto i = 0; i < n; ++ i) data[i] ^= M[i];",
            "\t\treturn *this;",
            "\t}",
            "\tmatrix_Z2_base operator-(const matrix_Z2_base &M) const{",
            "\t\treturn matrix_Z2_base(*this) -= M;",
            "\t}",
            "\tmatrix_Z2_base &operator*=(const matrix_Z2_base &a){",
            "\t\tassert(m == a.n);",
            "\t\tint l = a.m;",
            "\t\tmatrix_Z2_base res(n, l);",
            "\t\tvector<bitset<SZ>> temp(l);",
            "\t\tfor(auto i = 0; i < l; ++ i) for(auto j = 0; j < m; ++ j) temp[i][j] = a[j][i];",
            "\t\tfor(auto i = 0; i < n; ++ i) for(auto j = 0; j < l; ++ j) res[i][j] = (data[i] & temp[j]).count() & 1;",
            "\t\treturn *this = res;",
            "\t}",
            "\tmatrix_Z2_base operator*(const matrix_Z2_base &a) const{",
            "\t\treturn matrix_Z2_base(*this) *= a;",
            "\t}",
            "\tmatrix_Z2_base &operator*=(bool c){",
            "\t\tif(!c) for(auto &v: *this) v.reset();",
            "\t\treturn *this;",
            "\t}",
            "\tmatrix_Z2_base operator*(bool c) const{",
            "\t\treturn matrix_Z2_base(*this) *= c;",
            "\t}",
            "\ttemplate<class T, typename enable_if<is_integral<T>::value>::type* = nullptr>",
            "\tmatrix_Z2_base &inplace_power(T e){",
            "\t\tassert(n == m);",
            "\t\tmatrix_Z2_base res(n, n, true);",
            "\t\tfor(; e; *this *= *this, e >>= 1) if(e & 1) res *= *this;",
            "\t\treturn *this = res;",
            "\t}",
            "\ttemplate<class T>",
            "\tmatrix_Z2_base power(T e) const{",
            "\t\treturn matrix_Z2_base(*this).inplace_power(e);",
            "\t}",
            "\tmatrix_Z2_base &inplace_transpose(){",
            "\t\tassert(n == m);",
            "\t\tfor(auto i = 0; i < n; ++ i) for(auto j = i + 1; j < n; ++ j) swap(data[i][j], data[j][i]);",
            "\t\treturn *this;",
            "\t}",
            "\tmatrix_Z2_base transpose() const{",
            "\t\tif(n == m) return matrix_Z2_base(*this).inplace_transpose();",
            "\t\tmatrix_Z2_base res(m, n);",
            "\t\tfor(auto i = 0; i < n; ++ i) for(auto j = 0; j < m; ++ j) res[j][i] = data[i][j];",
            "\t\treturn res;",
            "\t}",
            "\t// Multiply a row vector v on the left",
            "\tvector<int> operator*(const bitset<SZ> &v) const{",
            "\t\tvector<int> res(n);",
            "\t\tfor(auto i = 0; i < n; ++ i) res[i] = (data[i] & v).count() & 1;",
            "\t\treturn res;",
            "\t}",
            "\t// O(n * m * up_to / w)",
            "\t// Returns {REF matrix, determinant, rank}",
            "\ttuple<matrix_Z2_base &, bool, int> inplace_REF(int up_to = -1){",
            "\t\tif(n == 0) return {*this, true, 0};",
            "\t\tif(!~up_to) up_to = m;",
            "\t\tbool det = true;",
            "\t\tint rank = 0;",
            "\t\tfor(auto j = 0; j < up_to; ++ j){",
            "\t\t\tint pivot = -1;",
            "\t\t\tfor(auto i = rank; i < n; ++ i) if(data[i][j]){",
            "\t\t\t\tpivot = i;",
            "\t\t\t\tbreak;",
            "\t\t\t}",
            "\t\t\tif(!~pivot){",
            "\t\t\t\tdet = false;",
            "\t\t\t\tcontinue;",
            "\t\t\t}",
            "\t\t\tif(rank != pivot) swap(data[rank], data[pivot]);",
            "\t\t\tfor(auto i = rank + 1; i < n; ++ i) if(data[i][j]) data[i] ^= data[rank];",
            "\t\t\t++ rank;",
            "\t\t\tif(rank == n) break;",
            "\t\t}",
            "\t\treturn {*this, det, rank};",
            "\t}",
            "\t// O(n * m * up_to / w)",
            "\t// Returns {REF matrix, determinant, rank}",
            "\ttuple<matrix_Z2_base, bool, int> REF(int up_to = -1) const{",
            "\t\treturn matrix(*this).inplace_REF(up_to);",
            "\t}",
            "\toptional<matrix_Z2_base> inverse() const{",
            "\t\tassert(n == m);",
            "\t\tvector<bitset<SZ>> a(data), res(n);",
            "\t\tfor(auto i = 0; i < n; ++ i) res[i].set(i);",
            "\t\tfor(auto j = 0; j < n; ++ j){",
            "\t\t\tint pivot = -1;",
            "\t\t\tfor(auto i = j; i < n; ++ i) if(a[i][j]){",
            "\t\t\t\tpivot = i;",
            "\t\t\t\tbreak;",
            "\t\t\t}",
            "\t\t\tif(!~pivot) return {};",
            "\t\t\tswap(a[j], a[pivot]), swap(res[j], res[pivot]);",
            "\t\t\tfor(auto i = 0; i < n; ++ i) if(i != j && a[i][j]) a[i] ^= a[j], res[i] ^= res[j];",
            "\t\t}",
            "\t\tswap(*this, res);",
            "\t\treturn true;",
            "\t}",
            "\tbool determinant() const{",
            "\t\tassert(n == m);",
            "\t\tmatrix_Z2_base a(data);",
            "\t\tfor(auto i = 0; i < n; ++ i){",
            "\t\t\tfor(auto j = i + 1; j < n; ++ j) if(a[j][i]){",
            "\t\t\t\tif(a[i][i]) a[j] ^= a[i];",
            "\t\t\t\telse swap(a[i], a[j]);",
            "\t\t\t}",
            "\t\t\tif(!a[i][i]) return false;",
            "\t\t}",
            "\t\treturn true;",
            "\t}",
            "\t// O(n^3 / w)",
            "\tint rank() const{",
            "\t\treturn get<2>(REF());",
            "\t}",
            "\t// Regarding the matrix as a system of linear equations by separating first m-1 columns, find a solution of the linear equation.",
            "\t// O(n * m^2 / w)",
            "\toptional<bitset<SZ>> find_a_solution() const{",
            "\t\tassert(m >= 1);",
            "\t\tauto [ref, _, rank] = REF(m - 1);",
            "\t\tfor(auto i = rank; i < n; ++ i) if(ref[i][m - 1]) return {};",
            "\t\tbitset<SZ> res;",
            "\t\tfor(auto i = rank - 1; i >= 0; -- i){",
            "\t\t\tint pivot = ref[i]._Find_first();",
            "\t\t\tassert(pivot < m - 1);",
            "\t\t\tres[pivot] = ref[i][m - 1] ^ (ref[i] & res).count() & 1;",
            "\t\t}",
            "\t\treturn res;",
            "\t}",
            "\ttemplate<class output_stream>",
            "\tfriend output_stream &operator<<(output_stream &out, const matrix_Z2_base &a){",
            "\t\tout << \"\\n\";",
            "\t\tfor(auto i = 0; i < a.n; ++ i){",
            "\t\t\tfor(auto j = 0; j < a.m; ++ j) out << bool(a[i][j]);",
            "\t\t\tout << \"\\n\";",
            "\t\t}",
            "\t\treturn out;",
            "\t}",
            "\tmatrix_Z2_base(int n, int m, bool init_diagonal = false, bool init_off_diagonal = false): n(n), m(m), data(n){",
            "\t\tassert(m <= SZ);",
            "\t\tfor(auto i = 0; i < n; ++ i) for(auto j = 0; j < m; ++ j) data[i][j] = i == j ? init_diagonal : init_off_diagonal;",
            "\t}",
            "\tmatrix_Z2_base(int n, int m, const vector<bitset<SZ>> &a): n(n), m(m), data(a){ }",
            "};",
            "template<size_t SZ>",
            "matrix_Z2_base<SZ> operator*(bool c, matrix_Z2_base<SZ> M){",
            "\tif(!c) for(auto &v: M) v.reset();",
            "\treturn M;",
            "}",
            "// Multiply a row vector v on the left",
            "template<size_t SZ>",
            "bitset<SZ> operator*(const vector<int> &v, const matrix_Z2_base<SZ> &a){",
            "\tassert(a.n == (int)v.size());",
            "\tbitset<SZ> res;",
            "\tfor(auto i = 0; i < a.n; ++ i) if(v[i]) res ^= a[i];",
            "\treturn res;",
            "}",
            "",
            "using matrix_Z2 = matrix_Z2_base<1000>;"
        ],
        "description": "tranxuanbach"
    }
}