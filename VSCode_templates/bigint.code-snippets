{
    "tranxuanbach": {
        "prefix": "bigint",
        "body": [
            "// Internally, the numbers are stored in binary in little endian order.",
            "// Negative numbers are assumed to have infinite leading ones, represented in two's complement.",
            "// No leading ~0 allowed for negative numbers, and no leading 0 allowed for non-negative numbers. This ensures that each integer has a unique representation.",
            "struct bigint{",
            "\tusing T = unsigned long long;",
            "\tusing T_large = __uint128_t;",
            "\tstatic constexpr signed int width = 8 * sizeof(T);",
            "\tstatic constexpr T pad[2] = {T(0), ~T(0)};",
            "\tbool sign = 0; // 0 (non-negative), 1 (negative)",
            "\tvector<T> data;",
            "\tvoid _trim(){",
            "\t\twhile(!data.empty() && data.back() == pad[sign]) data.pop_back();",
            "\t}",
            "\tbool _is_valid() const{",
            "\t\treturn data.empty() || data.back() != pad[sign];",
            "\t}",
            "\t// Assumes x is non-zero",
            "\tstatic void _negate(vector<T> &x){",
            "\t\tfor(auto &d: x) d = ~d;",
            "\t\tint i = 0;",
            "\t\twhile(i < (int)x.size() && !~x[i]) x[i ++] = 0;",
            "\t\tif(i == (int)x.size()) x.push_back(1);",
            "\t\telse ++ x[i];",
            "\t}",
            "\tstatic void _add_apply(bool &xsign, vector<T> &x, bool ysign, const vector<T> &y){",
            "\t\tif(!ysign && y.empty()) return;",
            "\t\tif(x.size() < y.size()) x.resize(y.size(), pad[xsign]);",
            "\t\tunsigned char carry = 0;",
            "\t\tfor(auto i = 0; i < (int)y.size(); ++ i) carry = _addcarry_u64(carry, x[i], y[i], &x[i]);",
            "\t\tfor(auto i = (int)y.size(); i < (int)x.size() && carry != ysign; ++ i) carry = _addcarry_u64(carry, x[i], pad[ysign], &x[i]);",
            "\t\tif(carry != ysign){",
            "\t\t\tif(xsign == ysign) x.push_back(pad[xsign] << 1 | carry);",
            "\t\t\telse xsign = !xsign;",
            "\t\t}",
            "\t}",
            "\tstatic void _subtract_apply(bool &xsign, vector<T> &x, bool ysign, const vector<T> &y){",
            "\t\tif(!ysign && y.empty()) return;",
            "\t\tif(x.size() < y.size()) x.resize(y.size(), pad[xsign]);",
            "\t\tunsigned char borrow = 0;",
            "\t\tfor(auto i = 0; i < (int)y.size(); ++ i) borrow = _subborrow_u64(borrow, x[i], y[i], &x[i]);",
            "\t\tfor(auto i = (int)y.size(); i < (int)x.size() && borrow != ysign; ++ i) borrow = _subborrow_u64(borrow, x[i], pad[ysign], &x[i]);",
            "\t\tif(borrow != ysign){",
            "\t\t\tif(xsign == ysign) xsign = !xsign;",
            "\t\t\telse x.push_back(pad[xsign] ^ 1);",
            "\t\t}",
            "\t}",
            "\t// Assumes both x and y are positive.",
            "\tstatic vector<T> _naive_multiplication(const vector<T> &x, const vector<T> &y){",
            "\t\tif(x.empty() || y.empty()) return {};",
            "\t\tvector<T> z(x.size() + y.size() - 1);",
            "\t\tfor(auto i = 0; i < (int)x.size(); ++ i) for(auto j = 0; j < (int)y.size(); ++ j){",
            "\t\t\tT_large rem = (T_large)x[i] * y[j];",
            "\t\t\tfor(auto k = i + j; rem; ++ k){",
            "\t\t\t\tif((int)z.size() <= k) z.push_back(0);",
            "\t\t\t\trem += z[k];",
            "\t\t\t\tz[k] = rem & ~T(0);",
            "\t\t\t\trem >>= width;",
            "\t\t\t}",
            "\t\t}",
            "\t\treturn z;",
            "\t}",
            "\ttemplate<int karatsuba_threshold = 90>",
            "\tstatic vector<T> _karatsuba_multiplication(const vector<T> &x, const vector<T> &y){",
            "\t\tint n = (int)x.size(), m = (int)y.size();",
            "\t\tif(min(n, m) <= karatsuba_threshold) return _naive_multiplication(x, y);",
            "\t\tint split = min(max(n, m) >> 1, min(n, m));",
            "\t\tvector<T> x0(x.begin(), x.begin() + split), x1(x.begin() + split, x.end());",
            "\t\tvector<T> y0(y.begin(), y.begin() + split), y1(y.begin() + split, y.end());",
            "\t\tauto z0 = _karatsuba_multiplication(x0, y0);",
            "\t\tauto z2 = _karatsuba_multiplication(x1, y1);",
            "\t\tbool temp = 0;",
            "\t\t_add_apply(temp, x0, temp, x1);",
            "\t\t_add_apply(temp, y0, temp, y1);",
            "\t\tauto z1 = _karatsuba_multiplication(x0, y0);",
            "\t\t_subtract_apply(temp, z1, temp, z0);",
            "\t\t_subtract_apply(temp, z1, temp, z2);",
            "\t\tz1.insert(z1.begin(), split, 0);",
            "\t\tz2.insert(z2.begin(), split << 1, 0);",
            "\t\t_add_apply(temp, z2, temp, z1);",
            "\t\t_add_apply(temp, z2, temp, z0);",
            "\t\treturn z2;",
            "\t}",
            "\t// TODO: implement Toom-Cook, and Schönhage–Strassen",
            "\tstatic vector<T> _multiply(const vector<T> &x, const vector<T> &y){",
            "\t\treturn _karatsuba_multiplication(x, y);",
            "\t}",
            "\tbigint(){ }",
            "\ttemplate<class U, typename enable_if<is_integral_v<U>>::type* = nullptr>",
            "\tbigint(U x){",
            "\t\tif(x < 0){",
            "\t\t\t*this = -bigint(-x);",
            "\t\t\treturn;",
            "\t\t}",
            "\t\twhile(x){",
            "\t\t\tdata.push_back(x & ~T(0));",
            "\t\t\tx /= T_large(1) << width;",
            "\t\t}",
            "\t}",
            "\ttemplate<class U, typename enable_if<is_floating_point_v<U>>::type* = nullptr>",
            "\tbigint(U x): bigint(llround(x)){ }",
            "\t// MSB at a.back()",
            "\ttemplate<class U, typename enable_if<is_integral_v<U>>::type* = nullptr>",
            "\tbigint(bool sign, const vector<U> &a, U base){",
            "\t\tbigint x{};",
            "\t\tfor(auto d: a){",
            "\t\t\tassert(0 <= d && d < base);",
            "\t\t\tx = base * x + d;",
            "\t\t}",
            "\t\t*this = sign ? -x : x;",
            "\t}",
            "\t// MSB at s.front()",
            "\tbigint(const string &s, unsigned int base){",
            "\t\tassert(base >= 2);",
            "\t\tif(base == 2){",
            "\t\t\tint pos = 0;",
            "\t\t\twhile(pos < (int)s.size() && (s[pos] == '-' || s[pos] == '+')){",
            "\t\t\t\tif(s[pos] == '-') sign = !sign;",
            "\t\t\t\t++ pos;",
            "\t\t\t}",
            "\t\t\tfor(auto i = (int)s.size() - 1; i >= pos; i -= width){",
            "\t\t\t\tT x = 0;",
            "\t\t\t\tfor(auto j = max(pos, i - width + 1); j <= i; ++ j){",
            "\t\t\t\t\tassert('0' <= s[j] && s[j] <= '1');",
            "\t\t\t\t\tx = x << 1 | s[j] - '0';",
            "\t\t\t\t}",
            "\t\t\t\tdata.push_back(x);",
            "\t\t\t}",
            "\t\t\twhile(!data.empty() && !data.back()) data.pop_back();",
            "\t\t}",
            "\t\telse if(base <= 10){",
            "\t\t\tint pos = 0;",
            "\t\t\twhile(pos < (int)s.size() && (s[pos] == '-' || s[pos] == '+')){",
            "\t\t\t\tif(s[pos] == '-') sign = !sign;",
            "\t\t\t\t++ pos;",
            "\t\t\t}",
            "\t\t\tbigint x{};",
            "\t\t\tfor(auto d: s){",
            "\t\t\t\tassert(isdigit(d));",
            "\t\t\t\tx = base * x + (d - '0');",
            "\t\t\t}",
            "\t\t\t*this = x;",
            "\t\t}",
            "\t\telse if(base == 16){",
            "\t\t\t// 0, ..., 9, A, B, C, D, E, F",
            "\t\t\tint pos = 0;",
            "\t\t\twhile(pos < (int)s.size() && (s[pos] == '-' || s[pos] == '+')){",
            "\t\t\t\tif(s[pos] == '-') sign = !sign;",
            "\t\t\t\t++ pos;",
            "\t\t\t}",
            "\t\t\tbigint x{};",
            "\t\t\tfor(auto d: s){",
            "\t\t\t\tassert(isdigit(d) || isupper(d) && d <= 'F');",
            "\t\t\t\tx = base * x + (isdigit(d) ? d - '0' : d - 'A' + 10);",
            "\t\t\t}",
            "\t\t\t*this = x;",
            "\t\t}",
            "\t\telse assert(false);",
            "\t\tif(sign){",
            "\t\t\tif(data.empty()) sign = 0;",
            "\t\t\telse _negate(data);",
            "\t\t}",
            "\t\t_trim();",
            "\t\tassert(_is_valid());",
            "\t}",
            "\t// MSB at back()",
            "\ttemplate<class U, typename enable_if<is_integral_v<U>>::type* = nullptr>",
            "\tfriend pair<bool, vector<U>> to_vector(const bigint &x, U base){",
            "\t\tassert(base >= 2);",
            "\t\tif(x < 0) return {1, to_vector(-x, base).second};",
            "\t\tvector<U> v;",
            "\t\tfor(auto y = x; y; y /= base) v.push_back(y % base);",
            "\t\treturn {0, v};",
            "\t}",
            "\t// TODO: Implement Schoenhage",
            "\t// MSB at front()",
            "\tfriend string to_string(const bigint &x, unsigned int base){",
            "\t\tassert(base >= 2);",
            "\t\tif(!x) return \"0\";",
            "\t\tif(x < 0) return '-' + to_string(-x, base);",
            "\t\tif(base == 2){",
            "\t\t\tstring s;",
            "\t\t\tfor(int i = __lg(x.data.back()); i >= 0; -- i) s.push_back('0' + (x.data.back() >> i & 1));",
            "\t\t\tfor(auto i = (int)x.data.size() - 2; i >= 0; -- i) s += bitset<width>(x.data[i]).to_string();",
            "\t\t\treturn s;",
            "\t\t}",
            "\t\telse if(base <= 10){",
            "\t\t\tstring s;",
            "\t\t\tfor(auto y = x; y; y /= base) s.push_back('0' + int(y % base));",
            "\t\t\treverse(s.begin(), s.end());",
            "\t\t\treturn s;",
            "\t\t}",
            "\t\telse if(base == 16){",
            "\t\t\t// 0, ..., 9, A, B, C, D, E, F",
            "\t\t\tstring s;",
            "\t\t\tfor(auto y = x; y; y /= base){",
            "\t\t\t\tint rem = y % base;",
            "\t\t\t\ts.push_back(rem < 10 ? '0' + rem : rem - 10 + 'A');",
            "\t\t\t}",
            "\t\t\treverse(s.begin(), s.end());",
            "\t\t\treturn s;",
            "\t\t}",
            "\t\telse assert(false);",
            "\t}",
            "\tfriend ostream &operator<<(ostream &out, const bigint &x){",
            "\t\treturn out << to_string(x, 10);",
            "\t}",
            "\toperator bool() const{",
            "\t\treturn sign || !data.empty();",
            "\t}",
            "\ttemplate<class U, typename enable_if<is_integral_v<U> && !is_same<U, bool>::value>::type* = nullptr>",
            "\toperator U() const{",
            "\t\tU x = 0;",
            "\t\tif(!sign) for(auto i = (int)data.size() - 1; i >= 0; -- i) x = x << min<int>(width, sizeof(U)) | data[i];",
            "\t\telse x = -U(-*this);",
            "\t\treturn x;",
            "\t}",
            "\ttemplate<class U, typename enable_if<is_floating_point_v<U>>::type* = nullptr>",
            "\toperator U() const{",
            "\t\tU x = 0;",
            "\t\tif(!sign) for(auto i = (int)data.size() - 1; i >= 0; -- i) x = x * (T_large(1) << width) + data[i];",
            "\t\telse x = -U(-*this);",
            "\t\treturn x;",
            "\t}",
            "\tbool operator==(const bigint &x) const{ return sign == x.sign && data == x.data; }",
            "\tbool operator!=(const bigint &x) const{ return !(*this == x); }",
            "\tbool operator<(const bigint &x) const{",
            "\t\tif(sign != x.sign) return sign > x.sign;",
            "\t\tif(!x) return false;",
            "\t\tif(data.size() != x.data.size()) return data.size() < x.data.size() ^ sign;",
            "\t\tfor(auto i = (int)data.size() - 1; i >= 0; -- i) if(data[i] != x.data[i]) return data[i] < x.data[i];",
            "\t\treturn false;",
            "\t}",
            "\tbool operator<=(const bigint &x) const{ return !(x < *this); }",
            "\tbool operator>=(const bigint &x) const{ return !(*this < x); }",
            "\tbool operator>(const bigint &x) const{ return x < *this; }",
            "#define COMPARE_OP(OP)\\",
            "template<class U, typename enable_if<is_integral_v<U>>::type* = nullptr>\\",
            "bool operator OP(U x) const{\\",
            "\treturn *this OP bigint(x);\\",
            "}\\",
            "template<class U, typename enable_if<is_integral_v<U>>::type* = nullptr>\\",
            "friend bool operator OP(U x, const bigint &y){\\",
            "\treturn bigint(x) OP y;\\",
            "}",
            "// TODO: Make this more efficient",
            "COMPARE_OP(==) COMPARE_OP(!=) COMPARE_OP(<) COMPARE_OP(<=) COMPARE_OP(>=) COMPARE_OP(>)",
            "#undef COMPARE_OP",
            "\tbigint &operator&=(const bigint &x){",
            "\t\tif(data.size() < x.data.size()) data.resize(x.data.size(), pad[sign]);",
            "\t\tfor(auto i = 0; i < (int)x.data.size(); ++ i) data[i] &= x.data[i];",
            "\t\tif(!x.sign) data.resize(x.data.size());",
            "\t\tsign &= x.sign;",
            "\t\t_trim();",
            "\t\treturn *this;",
            "\t}",
            "\tbigint operator&(const bigint &x) const{",
            "\t\treturn bigint(*this) &= x;",
            "\t}",
            "\tbigint &operator|=(const bigint &x){",
            "\t\tif(data.size() < x.data.size()) data.resize(x.data.size(), pad[sign]);",
            "\t\tfor(auto i = 0; i < (int)x.data.size(); ++ i) data[i] |= x.data[i];",
            "\t\tif(x.sign) data.resize(x.data.size());",
            "\t\tsign |= x.sign;",
            "\t\t_trim();",
            "\t\treturn *this;",
            "\t}",
            "\tbigint operator|(const bigint &x) const{",
            "\t\treturn bigint(*this) |= x;",
            "\t}",
            "\tbigint &operator^=(const bigint &x){",
            "\t\tif(data.size() < x.data.size()) data.resize(x.data.size(), pad[sign]);",
            "\t\tfor(auto i = 0; i < (int)x.data.size(); ++ i) data[i] ^= x.data[i];",
            "\t\tif(x.sign) for(auto i = (int)x.data.size(); i < (int)data.size(); ++ i) data[i] = ~data[i];",
            "\t\tsign ^= x.sign;",
            "\t\t_trim();",
            "\t\treturn *this;",
            "\t}",
            "\tbigint operator^(const bigint &x) const{",
            "\t\treturn bigint(*this) ^= x;",
            "\t}",
            "\tbigint operator+() const{",
            "\t\treturn *this;",
            "\t}",
            "\tbigint operator-() const{",
            "\t\tif(!*this) return *this;",
            "\t\tbigint x(*this);",
            "\t\tx.sign = !x.sign;",
            "\t\t_negate(x.data);",
            "\t\tx._trim();",
            "\t\treturn x;",
            "\t}",
            "\tfriend bigint abs(bigint x){",
            "\t\treturn x.sign ? -x : x;",
            "\t}",
            "\tbigint &operator+=(const bigint &x){",
            "\t\tif(!x) return *this;",
            "\t\tif(!*this) return *this = x;",
            "\t\t_add_apply(sign, data, x.sign, x.data);",
            "\t\t_trim();",
            "\t\treturn *this;",
            "\t}",
            "\tbigint operator+(const bigint &x) const{",
            "\t\treturn bigint(*this) += x;",
            "\t}",
            "\tbigint &operator-=(const bigint &x){",
            "\t\tif(!x) return *this;",
            "\t\tif(!*this) return *this = -x;",
            "\t\t_subtract_apply(sign, data, x.sign, x.data);",
            "\t\t_trim();",
            "\t\treturn *this;",
            "\t}",
            "\tbigint operator-(const bigint &x) const{",
            "\t\treturn bigint(*this) -= x;",
            "\t}",
            "\tbigint &operator++(){",
            "\t\tunsigned char carry = 1;",
            "\t\tfor(auto i = 0; i < (int)data.size() && carry; ++ i) carry = _addcarry_u64(carry, data[i], 0ULL, &data[i]);",
            "\t\tif(carry){",
            "\t\t\tif(!sign) data.push_back(1);",
            "\t\t\telse sign = !sign;",
            "\t\t}",
            "\t\t_trim();",
            "\t\treturn *this;",
            "\t}",
            "\tbigint operator++(int){",
            "\t\tbigint x = *this;",
            "\t\t++ *this;",
            "\t\treturn x;",
            "\t}",
            "\tbigint &operator--(){",
            "\t\tunsigned char borrow = 1;",
            "\t\tfor(auto i = 0; i < (int)data.size() && borrow; ++ i) borrow = _subborrow_u64(borrow, data[i], 0ULL, &data[i]);",
            "\t\tif(borrow){",
            "\t\t\tif(!sign) sign = !sign;",
            "\t\t\telse data.push_back(pad[sign] ^ 1);",
            "\t\t}",
            "\t\t_trim();",
            "\t\treturn *this;",
            "\t}",
            "\tbigint operator--(int){",
            "\t\tbigint x = *this;",
            "\t\t-- *this;",
            "\t\treturn x;",
            "\t}",
            "\tbigint &operator*=(const bigint &x){",
            "\t\tif(!*this || !x) return *this = bigint();",
            "\t\tdata = _multiply(abs(*this).data, abs(x).data);",
            "\t\tsign ^= x.sign;",
            "\t\tif(sign) _negate(data);",
            "\t\t_trim();",
            "\t\treturn *this;",
            "\t}",
            "\tbigint operator*(const bigint &x) const{",
            "\t\treturn bigint(*this) *= x;",
            "\t}",
            "\ttemplate<class U, typename enable_if<is_integral_v<U>>::type* = nullptr>",
            "\tbigint &inplace_power(U e){",
            "\t\tassert(e >= 0);",
            "\t\tbigint res(1);",
            "\t\tfor(; e; e >>= 1, *this *= *this) if(e & 1) res *= *this;",
            "\t\treturn *this = res;",
            "\t}",
            "\ttemplate<class U, typename enable_if<is_integral_v<U>>::type* = nullptr>",
            "\tbigint power(U e) const{",
            "\t\treturn bigint(*this).inplace_power(e);",
            "\t}",
            "\tstatic pair<vector<T>, T> small_div(const vector<T> &x, T y){",
            "\t\tassert(y);",
            "\t\tT_large rem = 0;",
            "\t\tvector<T> q((int)x.size());",
            "\t\tfor(auto i = (int)x.size() - 1; i >= 0; -- i){",
            "\t\t\trem = rem << width | x[i];",
            "\t\t\tq[i] = rem / y;",
            "\t\t\trem = rem % y;",
            "\t\t}",
            "\t\treturn {q, rem};",
            "\t}",
            "\t// Todo: Implement Burnikel-Ziegler",
            "\t// Assumes x is non-negative and y is positive",
            "\t// Returns {quotient, remainder} pair",
            "\tstatic pair<vector<T>, vector<T>> large_div(const vector<T> &x, const vector<T> &y){",
            "\t\tassert(!y.empty());",
            "\t\tint m = (int)x.size(), n = (int)y.size();",
            "\t\tif(m < n) return {{}, x};",
            "\t\tif(n == 1){",
            "\t\t\tauto [q, r] = small_div(x, y[0]);",
            "\t\t\treturn {q, {r}};",
            "\t\t}",
            "\t\tvector<T> q(m - n + 1), r(n), xn(m + 1), yn(n);",
            "\t\tT_large qhat, rhat, p;",
            "\t\tint s = __builtin_clzll(y[n - 1]);",
            "\t\tfor(auto i = n - 1; i > 0; -- i) yn[i] = y[i] << s | (T_large)y[i - 1] >> width - s;",
            "\t\tyn[0] = y[0] << s;",
            "\t\txn[m] = (T_large)x[m - 1] >> width - s;",
            "\t\tfor(auto i = m - 1; i > 0; -- i) xn[i] = x[i] << s | (T_large)x[i - 1] >> width - s;",
            "\t\txn[0] = x[0] << s;",
            "\t\t__int128_t t, k;",
            "\t\tstatic const T_large base = T_large(1) << width;",
            "\t\tfor(auto j = m - n; j >= 0; -- j){",
            "\t\t\tqhat = (xn[j + n] * base + xn[j + n - 1]) / yn[n - 1];",
            "\t\t\trhat = (xn[j + n] * base + xn[j + n - 1]) % yn[n - 1];",
            "\t\t\tFLAG:",
            "\t\t\tif(qhat >= base || (T)qhat * (T_large)yn[n - 2] > base * rhat + xn[j + n - 2]){",
            "\t\t\t\t-- qhat;",
            "\t\t\t\trhat += yn[n - 1];",
            "\t\t\t\tif(rhat < base) goto FLAG;",
            "\t\t\t}",
            "\t\t\tk = 0;",
            "\t\t\tfor(auto i = 0; i < n; ++ i){",
            "\t\t\t\tp = (T)qhat * (T_large)yn[i];",
            "\t\t\t\tt = xn[i + j] - k - (p & base - 1);",
            "\t\t\t\txn[i + j] = t;",
            "\t\t\t\tk = (p >> width) - (t >> width);",
            "\t\t\t}",
            "\t\t\tt = xn[j + n] - k;",
            "\t\t\txn[j + n] = t;",
            "\t\t\tq[j] = qhat;",
            "\t\t\tif(t < 0){",
            "\t\t\t\t-- q[j];",
            "\t\t\t\tk = 0;",
            "\t\t\t\tfor(auto i = 0; i < n; ++ i){",
            "\t\t\t\t\tt = (T_large)xn[i + j] + yn[i] + k;",
            "\t\t\t\t\txn[i + j] = t;",
            "\t\t\t\t\tk = t >> width;",
            "\t\t\t\t}",
            "\t\t\t\txn[j + n] += k;",
            "\t\t\t}",
            "\t\t}",
            "\t\tif(!r.empty()){",
            "\t\t\tfor(auto i = 0; i < n - 1; ++ i) r[i] = xn[i] >> s | (T_large)xn[i + 1] << width - s;",
            "\t\t\tr[n - 1] = xn[n - 1] >> s;",
            "\t\t}",
            "\t\treturn {q, r};",
            "\t}",
            "\tfriend pair<bigint, bigint> bigint_div(const bigint &x, const bigint &y){",
            "\t\tassert(y);",
            "\t\tbigint q, r;",
            "\t\ttie(q.data, r.data) = large_div(abs(x).data, abs(y).data);",
            "\t\tq.sign = x.sign ^ y.sign;",
            "\t\tr.sign = x.sign;",
            "\t\twhile(!q.data.empty() && !q.data.back()) q.data.pop_back();",
            "\t\tif(q.data.empty()) q.sign = 0;",
            "\t\telse if(q.sign) _negate(q.data);",
            "\t\twhile(!r.data.empty() && !r.data.back()) r.data.pop_back();",
            "\t\tif(r.data.empty()) r.sign = 0;",
            "\t\telse if(r.sign) _negate(r.data);",
            "\t\tq._trim();",
            "\t\tr._trim();",
            "\t\tif(x.sign != y.sign && r){",
            "\t\t\t-- q;",
            "\t\t\tr += y;",
            "\t\t}",
            "\t\treturn {q, r};",
            "\t}",
            "\tbigint &operator/=(const bigint &x){",
            "\t\treturn *this = bigint_div(*this, x).first;",
            "\t}",
            "\tbigint operator/(const bigint &x) const{",
            "\t\treturn bigint(*this) /= x;",
            "\t}",
            "\tbigint &operator%=(const bigint &x){",
            "\t\treturn *this = bigint_div(*this, x).second;",
            "\t}",
            "\tbigint operator%(const bigint &x) const{",
            "\t\treturn bigint(*this) %= x;",
            "\t}",
            "#define BINARY_OP(APPLY_OP, OP)\\",
            "template<class U, typename enable_if<is_integral_v<U>>::type* = nullptr>\\",
            "bigint &operator APPLY_OP(U x){\\",
            "\treturn *this APPLY_OP bigint(x);\\",
            "}\\",
            "template<class U, typename enable_if<is_integral_v<U>>::type* = nullptr>\\",
            "bigint operator OP(U x) const{\\",
            "\treturn bigint(*this) APPLY_OP bigint(x);\\",
            "}\\",
            "template<class U, typename enable_if<is_integral_v<U>>::type* = nullptr>\\",
            "friend bigint operator OP(U x, const bigint &y){\\",
            "\treturn bigint(y) APPLY_OP bigint(x);\\",
            "}",
            "// TODO: Make this more efficient",
            "BINARY_OP(&=, &) BINARY_OP(|=, |) BINARY_OP(^=, ^) BINARY_OP(+=, +) BINARY_OP(-=, -) BINARY_OP(*=, *) BINARY_OP(/=, /) BINARY_OP(%=, %)",
            "#undef BINARY_OP",
            "\tfriend bigint gcd(const bigint &x, const bigint &y){",
            "\t\tif(x.sign || y.sign) return gcd(abs(x), abs(y));",
            "\t\treturn y ? gcd(y, x % y) : x;",
            "\t}",
            "\tfriend bigint lcm(const bigint &x, const bigint &y){",
            "\t\tif(x.sign || y.sign) return lcm(abs(x), abs(y));",
            "\t\treturn x / gcd(x, y) * y;",
            "\t}",
            "\ttemplate<class Iter>",
            "\tstatic bigint sum(Iter begin, Iter end){",
            "\t\tint n = end - begin;",
            "\t\tvector<bigint> temp(n << 1);",
            "\t\tfor(auto i = 0; i < n; ++ i) temp[n + i] = *(begin + i);",
            "\t\tfor(auto i = n - 1; i >= 1; -- i) temp[i] = temp[i << 1] + temp[i << 1 | 1];",
            "\t\tbigint res = 0;",
            "\t\tfor(auto l = n, r = n << 1; l < r; l >>= 1, r >>= 1){",
            "\t\t\tif(l & 1) res += temp[l ++];",
            "\t\t\tif(r & 1) res += temp[-- r];",
            "\t\t}",
            "\t\treturn res;",
            "\t}",
            "\ttemplate<class Iter>",
            "\tstatic bigint product(Iter begin, Iter end){",
            "\t\tint n = end - begin;",
            "\t\tvector<bigint> temp(n << 1);",
            "\t\tfor(auto i = 0; i < n; ++ i) temp[n + i] = *(begin + i);",
            "\t\tfor(auto i = n - 1; i >= 1; -- i) temp[i] = temp[i << 1] * temp[i << 1 | 1];",
            "\t\tbigint res = 1;",
            "\t\tfor(auto l = n, r = n << 1; l < r; l >>= 1, r >>= 1){",
            "\t\t\tif(l & 1) res *= temp[l ++];",
            "\t\t\tif(r & 1) res *= temp[-- r];",
            "\t\t}",
            "\t\treturn res;",
            "\t}",
            "#if __cplusplus > 201703L",
            "\ttemplate<ranges::random_access_range R>",
            "\tstatic bigint sum(R &&r){",
            "\t\treturn sum(r.begin(), r.end());",
            "\t}",
            "\ttemplate<ranges::random_access_range R>",
            "\tstatic bigint product(R &&r){",
            "\t\treturn product(r.begin(), r.end());",
            "\t}",
            "#endif",
            "};"
        ],
        "description": "tranxuanbach"
    }
}