{
    "tranxuanbach": {
        "prefix": "group_generator",
        "body": [
            "struct group_generator{",
            "\tstatic mt19937 _group_rng;",
            "\tstatic vector<vector<int>> shuffle_elements(const vector<vector<int>> &g){",
            "\t\tint n = (int)g.size();",
            "\t\tassert(n >= 1);",
            "\t\tvector<int> map(n);",
            "\t\tiota(map.begin(), map.end(), 0);",
            "\t\tshuffle(map.begin(), map.end(), _group_rng);",
            "\t\tvector<vector<int>> res(n, vector<int>(n));",
            "\t\tfor(auto x = 0; x < n; ++ x) for(auto y = 0; y < n; ++ y) res[map[x]][map[y]] = map[g[x][y]];",
            "\t\treturn res;",
            "\t}",
            "\tstatic vector<vector<int>> direct_product(const vector<vector<int>> &g, const vector<vector<int>> &h, bool shuffle_order = false){",
            "\t\tint n = (int)g.size(), m = (int)h.size();",
            "\t\tassert(0 <= min(n, m));",
            "\t\tvector<int> map(n * m);",
            "\t\tiota(map.begin(), map.end(), 0);",
            "\t\tif(shuffle_order) shuffle(map.begin(), map.end(), _group_rng);",
            "\t\tvector<vector<int>> res(n * m, vector<int>(n * m));",
            "\t\tfor(auto x0 = 0; x0 < n; ++ x0) for(auto y0 = 0; y0 < m; ++ y0) for(auto x1 = 0; x1 < n; ++ x1) for(auto y1 = 0; y1 < m; ++ y1) res[map[x0 * m + y0]][map[x1 * m + y1]] = map[g[x0][x1] * m + h[y0][y1]];",
            "\t\treturn res;",
            "\t}",
            "\t// F:g->Aut(h) must be a homomorphism.",
            "\tstatic vector<vector<int>> semidirect_product(const vector<vector<int>> &g, const vector<vector<int>> &h, auto F, bool shuffle_order = false){",
            "\t\tint n = (int)g.size(), m = (int)h.size();",
            "\t\tassert(min(n, m) >= 0);",
            "\t\tvector<vector<int>> res(n * m, vector<int>(n * m));",
            "\t\tfor(auto x0 = 0; x0 < n; ++ x0) for(auto y0 = 0; y0 < m; ++ y0) for(auto x1 = 0; x1 < n; ++ x1) for(auto y1 = 0; y1 < m; ++ y1) res[x0 * m + y0][x1 * m + y1] = g[x0][F(x1, y0)] * m + h[y0][y1];",
            "\t\treturn res;",
            "\t}",
            "\tstatic vector<vector<int>> generate_cyclic_group(int n){",
            "\t\tassert(n >= 1);",
            "\t\tvector<vector<int>> res(n, vector<int>(n));",
            "\t\tfor(auto i = 0; i < n; ++ i) for(auto j = 0; j < n; ++ j) res[i][j] = (i + j) % n;",
            "\t\treturn res;",
            "\t}",
            "\tstatic vector<vector<int>> generate_commutative_group(int n){",
            "\t\tassert(n >= 1);",
            "\t\tvector<vector<int>> res{{0}};",
            "\t\tfor(auto p = 2; p <= n; ++ p){",
            "\t\t\tif(n % p) continue;",
            "\t\t\tint e = 0;",
            "\t\t\tfor(; n % p == 0; n /= p) ++ e;",
            "\t\t\twhile(e){",
            "\t\t\t\t-- e;",
            "\t\t\t\tint factor = p;",
            "\t\t\t\twhile(e && _group_rng() & 1){",
            "\t\t\t\t\t-- e;",
            "\t\t\t\t\tfactor *= p;",
            "\t\t\t\t}",
            "\t\t\t\tres = direct_product(res, generate_cyclic_group(factor));",
            "\t\t\t}",
            "\t\t}",
            "\t\treturn res;",
            "\t}",
            "\t// The symmetry group of a regular n-gon.",
            "\tstatic vector<vector<int>> generate_dihedral_group(int n){",
            "\t\tassert(n >= 1);",
            "\t\tvector<vector<int>> res(n << 1, vector<int>(n << 1));",
            "\t\tfor(auto x0 = 0; x0 < n; ++ x0) for(auto y0 = 0; y0 < 2; ++ y0) for(auto x1 = 0; x1 < n; ++ x1) for(auto y1 = 0; y1 < 2; ++ y1) res[x0 + n * y0][x1 + n * y1] = (x0 + (y0 ? n - x1 : x1)) % n + n * (y0 ^ y1);",
            "\t\treturn res;",
            "\t}",
            "\t// https://en.wikipedia.org/wiki/Quaternion_group#Generalized_quaternion_group",
            "\t// Note that it has order 4n",
            "\tstatic vector<vector<int>> generate_generalized_quaternion_group(int n = 2){",
            "\t\tassert(n >= 1);",
            "\t\tvector<vector<int>> res(n << 2, vector<int>(n << 2));",
            "\t\tfor(auto x0 = 0; x0 < n << 1; ++ x0) for(auto y0 = 0; y0 < 2; ++ y0) for(auto x1 = 0; x1 < n << 1; ++ x1) for(auto y1 = 0; y1 < 2; ++ y1) res[x0 + n * 2 * y0][x1 + n * 2 * y1] = (x0 + (y0 ? n * 2 - x1 : x1) + n * (y0 && y1)) % (n * 2) + n * 2 * (y0 ^ y1);",
            "\t\treturn res;",
            "\t}",
            "\tstatic vector<vector<int>> generate_dedekind_group(int n, bool force_hamiltonian = false){",
            "\t\tvector<vector<int>> res;",
            "\t\tif(force_hamiltonian || n % 8 == 0 && _group_rng() & 1){",
            "\t\t\tassert(n % 8 == 0);",
            "\t\t\tres = generate_generalized_quaternion_group(2);",
            "\t\t\tn >>= 3;",
            "\t\t\tfor(; ~n & 1; n >>= 1) res = direct_product(res, {{0, 1}, {1, 0}});",
            "\t\t\tres = direct_product(res, generate_commutative_group(n));",
            "\t\t}",
            "\t\telse res = generate_commutative_group(n);",
            "\t\treturn res;",
            "\t}",
            "};",
            "mt19937 group_generator::_group_rng(chrono::high_resolution_clock::now().time_since_epoch().count());",
            "using GG = group_generator;"
        ],
        "description": "tranxuanbach"
    }
}