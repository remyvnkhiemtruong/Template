{
    "tranxuanbach": {
        "prefix": "dfs_bipartite_matching",
        "body": [
            "struct dfs_bipartite_matching{",
            "\tint n, m, flow = 0;",
            "\tvector<vector<int>> adj;",
            "\tvector<int> pu, pv; // u is matched with pu[u] and v with pv[v], -1 if no match",
            "\tdfs_bipartite_matching(int n, int m): n(n), m(m), pu(n, -1), pv(m, -1), cur(n), adj(n){ }",
            "\tint insert(int from, int to){",
            "\t\tadj[from].push_back(to);",
            "\t\treturn (int)adj[from].size() - 1;",
            "\t}",
            "\tint id = 0;",
            "\tvector<int> cur;",
            "\tbool dfs(int u){",
            "\t\tcur[u] = id;",
            "\t\tfor(auto v: adj[u]) if(!~pv[v]){",
            "\t\t\tpu[u] = v, pv[v] = u;",
            "\t\t\treturn true;",
            "\t\t}",
            "\t\tfor(auto v: adj[u]) if(cur[pv[v]] != id && dfs(pv[v])){",
            "\t\t\tpu[u] = v, pv[v] = u;",
            "\t\t\treturn true;",
            "\t\t}",
            "\t\treturn false;",
            "\t}",
            "\tint solve(){ // O(VE)",
            "\t\twhile(true){",
            "\t\t\tint augment = 0;",
            "\t\t\t++ id;",
            "\t\t\tfor(int u = 0; u < n; ++ u) if(pu[u] == -1 && dfs(u)) ++ augment;",
            "\t\t\tif(!augment) break;",
            "\t\t\tflow += augment;",
            "\t\t}",
            "\t\treturn flow;",
            "\t}",
            "\tint run_once(int v){",
            "\t\tif(pu[v] != -1) return 0;",
            "\t\t++ id;",
            "\t\treturn dfs(v);",
            "\t}",
            "\tpair<vector<int>, vector<int>> minimum_vertex_cover(){",
            "\t\tsolve();",
            "\t\tvector<int> L, R, visL(n), visR(m);",
            "\t\tfunction<void(int)> dfs = [&](int u){",
            "\t\t\tvisL[u] = true;",
            "\t\t\tfor(auto v: adj[u]) if(v != pu[u] && !visR[v]){",
            "\t\t\t\tvisR[v] = true, R.push_back(v);",
            "\t\t\t\tif(~pv[v]) dfs(pv[v]);",
            "\t\t\t}",
            "\t\t};",
            "\t\tfor(int u = 0; u < n; ++ u) if(!visL[u] && pu[u] == -1) dfs(u);",
            "\t\tfor(int u = 0; u < n; ++ u) if(!visL[u]) L.push_back(u);",
            "\t\treturn {L, R};",
            "\t}",
            "};"
        ],
        "description": "tranxuanbach"
    }
}