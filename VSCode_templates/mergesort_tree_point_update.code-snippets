{
    "tranxuanbach": {
        "prefix": "mergesort_tree_point_update",
        "body": [
            "// Assumes all elements are distinct",
            "// Requires order_statistics_tree",
            "template<class T, class Compare = less<>>",
            "struct mergesort_tree_point_update{",
            "\tint n;",
            "\tCompare cmp;",
            "\tvector<T> a;",
            "\tvector<order_statistic_set<T, Compare>> data;",
            "\t// O(n * log^2(n))",
            "\tmergesort_tree_point_update(const vector<T> &a, Compare cmp = less<>()): n((int)a.size()), a(a), data(n << 1, order_statistic_set<T, Compare>(cmp)), cmp(cmp){",
            "\t\tfor(auto i = n; i < n << 1; ++ i) data[i].insert(a[i - n]);",
            "\t\tfor(auto i = n - 1; i > 0; -- i){",
            "\t\t\tdata[i] = data[i << 1];",
            "\t\t\tfor(auto x: data[i << 1 | 1]) data[i].insert(x);",
            "\t\t}",
            "\t}",
            "\t// O(log^2(n))",
            "\tvoid set(int p, T x){",
            "\t\tfor(auto q = p + n; q; q >>= 1) data[q].erase(a[p]), data[q].insert(x);",
            "\t\ta[p] = x;",
            "\t}",
            "\t// O(log^2(n))",
            "\tint count_less(int l, int r, T k) const{",
            "\t\tassert(0 <= l && l <= r && r <= n);",
            "\t\tint res = 0;",
            "\t\tfor(l += n, r += n; l < r; l >>= 1, r >>= 1){",
            "\t\t\tif(l & 1) res += data[l].order_of_key(k), ++ l;",
            "\t\t\tif(r & 1) -- r, res += data[r].order_of_key(k);",
            "\t\t}",
            "\t\treturn res;",
            "\t}",
            "\t// O(log^2(n))",
            "\tint count_equal_or_greater(int l, int r, T k) const{",
            "\t\tassert(0 <= l && l <= r && r <= n);",
            "\t\tint res = 0;",
            "\t\tfor(l += n, r += n; l < r; l >>= 1, r >>= 1){",
            "\t\t\tif(l & 1) res += (int)data[l].size() - data[l].order_of_key(k), ++ l;",
            "\t\t\tif(r & 1) -- r, res += (int)data[r].size() - data[r].order_of_key(k);",
            "\t\t}",
            "\t\treturn res;",
            "\t}",
            "\t// O(log^2(n))",
            "\tint count_within(int l, int r, T kl, T kr) const{",
            "\t\tassert(0 <= l && l <= r && r <= n);",
            "\t\tint res = 0;",
            "\t\tfor(l += n, r += n; l < r; l >>= 1, r >>= 1){",
            "\t\t\tif(l & 1) res += data[l].order_of_key(kr) - data[l].order_of_key(kl), ++ l;",
            "\t\t\tif(r & 1) -- r, res += data[r].order_of_key(kr) - data[r].order_of_key(kl);",
            "\t\t}",
            "\t\treturn res;",
            "\t}",
            "\t// O(SZ * log(n)) where SZ is the size of the answer",
            "\tvector<T> get_sorted_list(int l, int r) const{",
            "\t\tassert(0 <= l && l <= r && r <= n);",
            "\t\tvector<T> res;",
            "\t\tfor(l += n, r += n; l < r; l >>= 1, r >>= 1){",
            "\t\t\tif(auto sz = (int)res.size(); l & 1) res.insert(res.end(), data[l].begin(), data[l].end()), inplace_merge(res.begin(), res.begin() + sz, res.end(), cmp), ++ l;",
            "\t\t\tif(auto sz = (int)res.size(); r & 1) -- r, res.insert(res.begin(), data[r].begin(), data[r].end()), inplace_merge(res.begin(), res.end() - sz, res.end(), cmp);",
            "\t\t}",
            "\t\treturn res;",
            "\t}",
            "};"
        ],
        "description": "tranxuanbach"
    }
}