{
    "tranxuanbach": {
        "prefix": "segment_tree_persistent",
        "body": [
            "template<bool HAS_QUERY, bool HAS_UPDATE, class T, class U, class F1, class F2, class F3>",
            "struct segment_tree_persistent_base{",
            "\tstatic_assert(HAS_QUERY || HAS_UPDATE);",
            "#define ifQ if constexpr(HAS_QUERY)",
            "#define ifU if constexpr(HAS_UPDATE)",
            "\tint n;",
            "\tvector<int> left; // left child",
            "\tvector<int> right; // right child",
            "\tvector<T> data;",
            "\tvector<U> data_action;",
            "\tF1 TT; // monoid operation (always adjacent)",
            "\tT T_id; // monoid identity",
            "\tF2 UU; // monoid operation (superset, subset)",
            "\tU U_id; // monoid identity",
            "\tF3 UT; // action of U on T (superset, subset)",
            "\t// O(n)",
            "\tsegment_tree_persistent_base(F1 TT, T T_id, F2 UU, U U_id, F3 UT): TT(TT), T_id(T_id), UU(UU), U_id(U_id), UT(UT){ }",
            "\tsegment_tree_persistent_base &operator=(const segment_tree_persistent_base &seg){",
            "\t\tn = seg.n;",
            "\t\tleft = seg.left;",
            "\t\tright = seg.right;",
            "\t\tdata = seg.data;",
            "\t\tdata_action = seg.data_action;",
            "\t\treturn *this;",
            "\t}",
            "\tint _last_state() const{",
            "\t\treturn (int)left.size() - 1;",
            "\t}",
            "\tint _new_state(int l, int r, T x){",
            "\t\tstatic_assert(HAS_QUERY);",
            "\t\tleft.push_back(l);",
            "\t\tright.push_back(r);",
            "\t\tdata.push_back(x);",
            "\t\tifU data_action.push_back(U_id);",
            "\t\treturn _last_state();",
            "\t}",
            "\tint _new_state(int l, int r, T x, U f){",
            "\t\tstatic_assert(HAS_QUERY && HAS_UPDATE);",
            "\t\tleft.push_back(l);",
            "\t\tright.push_back(r);",
            "\t\tdata.push_back(x);",
            "\t\tdata_action.push_back(f);",
            "\t\treturn _last_state();",
            "\t}",
            "\tint _new_state_action(int l, int r, U f){",
            "\t\tstatic_assert(!HAS_QUERY && HAS_UPDATE);",
            "\t\tleft.push_back(l);",
            "\t\tright.push_back(r);",
            "\t\tifU data_action.push_back(f);",
            "\t\treturn _last_state();",
            "\t}",
            "\tint copy(int u){",
            "\t\tassert(0 <= u && u <= _last_state());",
            "\t\tleft.push_back(left[u]);",
            "\t\tright.push_back(right[u]);",
            "\t\tifQ data.push_back(data[u]);",
            "\t\tifU data_action.push_back(data_action[u]);",
            "\t\treturn _last_state();",
            "\t}",
            "\t// Invalidates all previous roots",
            "\t// O(n)",
            "\tint build(int n){",
            "\t\tstatic_assert(HAS_QUERY);",
            "\t\treturn build(vector<T>(n, T_id));",
            "\t}",
            "\t// Invalidates all previous roots",
            "\t// O(n)",
            "\tint build(int n, T x){",
            "\t\tstatic_assert(HAS_QUERY);",
            "\t\treturn build(vector<T>(n, x));",
            "\t}",
            "\t// Invalidates all previous roots",
            "\t// O(n)",
            "\ttemplate<class V>",
            "\tint build(const vector<V> &a){",
            "\t\tstatic_assert(HAS_QUERY);",
            "\t\tassert(!a.empty());",
            "\t\tn = (int)a.size();",
            "\t\tleft.clear();",
            "\t\tright.clear();",
            "\t\tdata.clear();",
            "\t\tdata_action.clear();",
            "\t\tauto recurse = [&](auto self, int l, int r)->int{",
            "\t\t\tif(r - l == 1) return _new_state(-1, -1, a[l]);",
            "\t\t\tint m = l + (r - l >> 1);",
            "\t\t\tint v = self(self, l, m), w = self(self, m, r);",
            "\t\t\treturn _new_state(v, w, TT(data[v], data[w]));",
            "\t\t};",
            "\t\treturn recurse(recurse, 0, n);",
            "\t}",
            "\tint build_action(int n){",
            "\t\tstatic_assert(!HAS_QUERY && HAS_UPDATE);",
            "\t\treturn build_action(vector<U>(n, U_id));",
            "\t}",
            "\tint build_action(int n, U f){",
            "\t\tstatic_assert(!HAS_QUERY && HAS_UPDATE);",
            "\t\treturn build_action(vector<U>(n, f));",
            "\t}",
            "\ttemplate<class V>",
            "\tint build_action(const vector<V> &a){",
            "\t\tstatic_assert(!HAS_QUERY && HAS_UPDATE);",
            "\t\tassert(!a.empty());",
            "\t\tn = (int)a.size();",
            "\t\tleft.clear();",
            "\t\tright.clear();",
            "\t\tdata.clear();",
            "\t\tdata_action.clear();",
            "\t\tauto recurse = [&](auto self, int l, int r)->int{",
            "\t\t\tif(r - l == 1) return _new_state_action(-1, -1, a[l]);",
            "\t\t\tint m = l + (r - l >> 1);",
            "\t\t\tint v = self(self, l, m), w = self(self, m, r);",
            "\t\t\treturn _new_state_action(v, w, U_id);",
            "\t\t};",
            "\t\treturn recurse(recurse, 0, n);",
            "\t}",
            "\tint _push_copy(int u){",
            "\t\tstatic_assert(HAS_UPDATE);",
            "\t\tif(data_action[u] == U_id) return copy(u);",
            "\t\tint v_new = copy(left[u]), w_new = copy(right[u]);",
            "\t\tifQ data[v_new] = UT(data_action[u], data[v_new]);",
            "\t\tdata_action[v_new] = UU(data_action[u], data_action[v_new]);",
            "\t\tifQ data[w_new] = UT(data_action[u], data[w_new]);",
            "\t\tdata_action[w_new] = UU(data_action[u], data_action[w_new]);",
            "\t\tifQ u = _new_state(v_new, w_new, TT(data[v_new], data[w_new]));",
            "\t\telse u = _new_state_action(v_new, w_new, UU(data_action[v_new], data_action[w_new]));",
            "\t\tdata_action[u] = U_id;",
            "\t\treturn u;",
            "\t}",
            "\t// Assumes u represents an interval of size n",
            "\t// O(log(n))",
            "\tpair<int, T> query(int u, int p){\t",
            "\t\tstatic_assert(HAS_QUERY);",
            "\t\tassert(0 <= u && u <= _last_state());",
            "\t\tassert(0 <= p && p < n);",
            "\t\tifU{",
            "\t\t\tauto recurse = [&](auto self, int u, int l, int r)->pair<int, T>{",
            "\t\t\t\tif(r - l == 1) return {u, data[u]};",
            "\t\t\t\tu = _push_copy(u);",
            "\t\t\t\tint m = l + (r - l >> 1);",
            "\t\t\t\tif(p < m){",
            "\t\t\t\t\tauto [v, x] = self(self, left[u], l, m);",
            "\t\t\t\t\tleft[u] = v;",
            "\t\t\t\t\treturn {u, x};",
            "\t\t\t\t}",
            "\t\t\t\telse{",
            "\t\t\t\t\tauto [w, x] = self(self, right[u], m, r);",
            "\t\t\t\t\tright[u] = w;",
            "\t\t\t\t\treturn {u, x};",
            "\t\t\t\t}",
            "\t\t\t};",
            "\t\t\treturn recurse(recurse, u, 0, n);",
            "\t\t}",
            "\t\telse{",
            "\t\t\tint root = u;",
            "\t\t\tfor(auto l = 0, r = n; ; ){",
            "\t\t\t\tif(r - l == 1) return {root, data[u]};",
            "\t\t\t\tint m = l + (r - l >> 1);",
            "\t\t\t\tif(p < m) u = left[u], r = m;",
            "\t\t\t\telse u = right[u], l = m;",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "\t// Assumes u represents an interval of size n",
            "\t// O(log(n))",
            "\tpair<int, U> query_action(int u, int p){",
            "\t\tstatic_assert(!HAS_QUERY && HAS_UPDATE);",
            "\t\tassert(0 <= u && u <= _last_state());",
            "\t\tassert(0 <= p && p < n);",
            "\t\tauto recurse = [&](auto self, int u, int l, int r)->pair<int, U>{",
            "\t\t\tif(r - l == 1) return {u, data_action[u]};",
            "\t\t\tu = _push_copy(u);",
            "\t\t\tint m = l + (r - l >> 1);",
            "\t\t\tif(p < m){",
            "\t\t\t\tauto [v, f] = self(self, left[u], l, m);",
            "\t\t\t\tleft[u] = v;",
            "\t\t\t\treturn {u, f};",
            "\t\t\t}",
            "\t\t\telse{",
            "\t\t\t\tauto [w, f] = self(self, right[u], m, r);",
            "\t\t\t\tright[u] = w;",
            "\t\t\t\treturn {u, f};",
            "\t\t\t}",
            "\t\t};",
            "\t\treturn recurse(recurse, u, 0, n);",
            "\t}",
            "\t// Assumes u represents an interval of size n",
            "\t// O(log(n))",
            "\tpair<int, T> query(int u, int ql, int qr){",
            "\t\tstatic_assert(HAS_QUERY);",
            "\t\tassert(0 <= u && u <= _last_state());",
            "\t\tassert(0 <= ql && ql <= qr && qr <= n);",
            "\t\tif(ql == qr) return {u, T_id};",
            "\t\tauto recurse = [&](auto self, int u, int l, int r)->pair<int, T>{",
            "\t\t\tif(qr <= l || r <= ql) return {u, T_id};",
            "\t\t\tif(ql <= l && r <= qr) return {u, data[u]};",
            "\t\t\tifU u = _push_copy(u);",
            "\t\t\tint m = l + (r - l >> 1);",
            "\t\t\tauto [v, x] = self(self, left[u], l, m);",
            "\t\t\tauto [w, y] = self(self, right[u], m, r);",
            "\t\t\tleft[u] = v, right[u] = w;",
            "\t\t\treturn pair{u, TT(x, y)};",
            "\t\t};",
            "\t\treturn recurse(recurse, u, 0, n);",
            "\t}",
            "\t// Assumes u represents an interval of size n",
            "\t// O(1)",
            "\tpair<int, T> query_all(int u) const{",
            "\t\tstatic_assert(HAS_QUERY);",
            "\t\tassert(0 <= u && u <= _last_state());",
            "\t\treturn {u, data[u]};",
            "\t}",
            "\t// Assumes u represents an interval of size n",
            "\t// O(n)",
            "\tpair<int, vector<T>> to_array(int u){",
            "\t\tstatic_assert(HAS_QUERY);",
            "\t\tassert(0 <= u && u <= _last_state());",
            "\t\tvector<T> res;",
            "\t\tauto recurse = [&](auto self, int u, int l, int r)->int{",
            "\t\t\tif(r - l == 1){",
            "\t\t\t\tres.push_back(data[u]);",
            "\t\t\t\treturn u;",
            "\t\t\t}",
            "\t\t\tifU u = _push_copy(u);",
            "\t\t\tint m = l + (r - l >> 1);",
            "\t\t\tleft[u] = self(self, left[u], l, m);",
            "\t\t\tright[u] = self(self, right[u], m, r);",
            "\t\t\treturn u;",
            "\t\t};",
            "\t\tu = recurse(recurse, u, 0, n);",
            "\t\treturn {u, res};",
            "\t}",
            "\t// Assumes u represents an interval of size n",
            "\t// O(n)",
            "\tpair<int, vector<U>> to_array_of_updates(int u){",
            "\t\tstatic_assert(!HAS_QUERY && HAS_UPDATE);",
            "\t\tassert(0 <= u && u <= _last_state());",
            "\t\tvector<U> res;",
            "\t\tauto recurse = [&](auto self, int u, int l, int r)->int{",
            "\t\t\tif(r - l == 1){",
            "\t\t\t\tres.push_back(data_action[u]);",
            "\t\t\t\treturn u;",
            "\t\t\t}",
            "\t\t\tu = _push_copy(u);",
            "\t\t\tint m = l + (r - l >> 1);",
            "\t\t\tleft[u] = self(self, left[u], l, m);",
            "\t\t\tright[u] = self(self, right[u], m, r);",
            "\t\t\treturn u;",
            "\t\t};",
            "\t\tu = recurse(recurse, u, 0, n);",
            "\t\treturn {u, res};",
            "\t}",
            "\t// Assumes u represents an interval of size n",
            "\t// O(log(n))",
            "\tint set(int u, int p, T x){",
            "\t\tstatic_assert(HAS_QUERY);",
            "\t\tassert(0 <= u && u <= _last_state());",
            "\t\tassert(0 <= p && p < n);",
            "\t\tauto recurse = [&](auto self, int u, int l, int r)->int{",
            "\t\t\tif(r - l == 1) return _new_state(-1, -1, x);",
            "\t\t\tint m = l + (r - l >> 1);",
            "\t\t\tifU{",
            "\t\t\t\tu = _push_copy(u);",
            "\t\t\t\tif(p < m) left[u] = self(self, left[u], l, m);",
            "\t\t\t\telse right[u] = self(self, right[u], m, r);",
            "\t\t\t\tdata[u] = TT(data[left[u]], data[right[u]]);",
            "\t\t\t\treturn u;",
            "\t\t\t}",
            "\t\t\telse{",
            "\t\t\t\tint v = left[u], w = right[u];",
            "\t\t\t\tif(p < m) v = self(self, v, l, m);",
            "\t\t\t\telse w = self(self, w, m, r);",
            "\t\t\t\treturn _new_state(v, w, TT(data[v], data[w]));",
            "\t\t\t}",
            "\t\t};",
            "\t\treturn recurse(recurse, u, 0, n);",
            "\t}",
            "\t// Assumes u represents an interval of size n",
            "\t// O(log(n))",
            "\tint set_action(int u, int p, U f){",
            "\t\tstatic_assert(!HAS_QUERY && HAS_UPDATE);",
            "\t\tassert(0 <= u && u <= _last_state());",
            "\t\tassert(0 <= p && p < n);",
            "\t\tauto recurse = [&](auto self, int u, int l, int r)->int{",
            "\t\t\tif(r - l == 1) return _new_state_action(-1, -1, f);",
            "\t\t\tu = _push_copy(u);",
            "\t\t\tint m = l + (r - l >> 1);",
            "\t\t\tif(p < m) left[u] = self(self, left[u], l, m);",
            "\t\t\telse right[u] = self(self, right[u], m, r);",
            "\t\t\treturn u;",
            "\t\t};",
            "\t\treturn recurse(recurse, u, 0, n);",
            "\t}",
            "\t// Assumes u represents an interval of size n",
            "\t// O(log(n))",
            "\tint update(int u, int p, U f){",
            "\t\tstatic_assert(HAS_UPDATE);",
            "\t\tassert(0 <= u && u <= _last_state());",
            "\t\tassert(0 <= p && p < n);",
            "\t\tauto recurse = [&](auto self, int u, int l, int r)->int{",
            "\t\t\tif(r - l == 1){",
            "\t\t\t\tifQ return _new_state(-1, -1, UT(f, data[u]));",
            "\t\t\t\telse return _new_state_action(-1, -1, UU(f, data_action[u]));",
            "\t\t\t}",
            "\t\t\tu = _push_copy(u);",
            "\t\t\tint m = l + (r - l >> 1);",
            "\t\t\tif(p < m) left[u] = self(self, left[u], l, m);",
            "\t\t\telse right[u] = self(self, right[u], m, r);",
            "\t\t\tifQ data[u] = TT(data[left[u]], data[right[u]]);",
            "\t\t\treturn u;",
            "\t\t};",
            "\t\t// return recurse(recurse, u, 0, n);",
            "\t\tu = recurse(recurse, u, 0, n);",
            "\t\treturn u;",
            "\t}",
            "\t// Assumes u represents an interval of size n",
            "\t// O(log(n))",
            "\tint update(int u, int ql, int qr, U f){",
            "\t\tstatic_assert(HAS_UPDATE);",
            "\t\tassert(0 <= u && u <= _last_state());",
            "\t\tassert(0 <= ql && ql <= qr && qr <= n);",
            "\t\tif(ql == qr) return u;",
            "\t\tauto recurse = [&](auto self, int u, int l, int r)->int{",
            "\t\t\tif(qr <= l || r <= ql) return u;",
            "\t\t\tif(ql <= l && r <= qr){",
            "\t\t\t\tifQ return _new_state(left[u], right[u], UT(f, data[u]), UU(f, data_action[u]));",
            "\t\t\t\telse return _new_state_action(left[u], right[u], UU(f, data_action[u]));",
            "\t\t\t}",
            "\t\t\tu = _push_copy(u);",
            "\t\t\tint m = l + (r - l >> 1);",
            "\t\t\tleft[u] = self(self, left[u], l, m);",
            "\t\t\tright[u] = self(self, right[u], m, r);",
            "\t\t\tifQ data[u] = TT(data[left[u]], data[right[u]]);",
            "\t\t\treturn u;",
            "\t\t};",
            "\t\treturn recurse(recurse, u, 0, n);",
            "\t}",
            "\t// pred(sum[l, r)) is T, T, ..., T, F, F, ..., F",
            "\t// Returns max r with T",
            "\t// Assumes u represents an interval of size n",
            "\t// O(log(n))",
            "\tpair<int, int> max_pref(int u, int ql, auto pred){",
            "\t\tstatic_assert(HAS_QUERY);",
            "\t\tassert(0 <= u && u <= _last_state());",
            "\t\tassert(0 <= ql && ql <= n && pred(T_id));",
            "\t\tif(ql == n) return {u, ql};",
            "\t\tT pref = T_id;",
            "\t\tauto recurse = [&](auto self, int u, int l, int r)->pair<int, int>{",
            "\t\t\tif(r <= ql) return {u, -1};",
            "\t\t\tif(ql <= l && pred(TT(pref, data[u]))){",
            "\t\t\t\tpref = TT(pref, data[u]);",
            "\t\t\t\treturn {u, -1};",
            "\t\t\t}",
            "\t\t\tif(r - l == 1) return {u, l};",
            "\t\t\tifU u = _push_copy(u);",
            "\t\t\tint m = l + (r - l >> 1);",
            "\t\t\tauto [v, p] = self(self, left[u], l, m);",
            "\t\t\tleft[u] = v;",
            "\t\t\tif(~p) return {u, p};",
            "\t\t\tauto [w, q] = self(self, right[u], m, r);",
            "\t\t\tright[u] = w;",
            "\t\t\treturn {u, q};",
            "\t\t};",
            "\t\tauto [v, qr] = recurse(recurse, u, 0, n);",
            "\t\tif(!~qr) qr = n;",
            "\t\treturn {v, qr};",
            "\t}",
            "\t// pred(sum[l, r)) is F, F, ..., F, T, T, ..., T",
            "\t// Returns min l with T",
            "\t// Assumes u represents an interval of size n",
            "\t// O(log(n))",
            "\tpair<int, int> min_suff(int u, int qr, auto pred){",
            "\t\tstatic_assert(HAS_QUERY);",
            "\t\tassert(0 <= u && u <= _last_state());",
            "\t\tassert(0 <= qr && qr <= n && pred(T_id));",
            "\t\tif(qr == 0) return {u, qr};",
            "\t\tT suff = T_id;",
            "\t\tauto recurse = [&](auto self, int u, int l, int r)->pair<int, int>{",
            "\t\t\tif(qr <= l) return {u, -1};",
            "\t\t\tif(r <= qr && pred(TT(data[u], suff))){",
            "\t\t\t\tsuff = TT(data[u], suff);",
            "\t\t\t\treturn {u, -1};",
            "\t\t\t}",
            "\t\t\tif(r - l == 1) return {u, r};",
            "\t\t\tifU u = _push_copy(u);",
            "\t\t\tint m = l + (r - l >> 1);",
            "\t\t\tauto [w, q] = self(self, right[u], m, r);",
            "\t\t\tright[u] = w;",
            "\t\t\tif(~q) return {u, q};",
            "\t\t\tauto [v, p] = self(self, left[u], l, m);",
            "\t\t\tleft[u] = v;",
            "\t\t\treturn {u, p};",
            "\t\t};",
            "\t\tauto [v, ql] = recurse(recurse, u, 0, n);",
            "\t\tif(!~ql) ql = 0;",
            "\t\treturn {v, ql};",
            "\t}",
            "\t// Assumes u represents an interval of size n",
            "\ttemplate<class ostream_t>",
            "\tint print(ostream_t &out, int u){",
            "\t\tassert(0 <= u && u <= _last_state());",
            "\t\tifQ{",
            "\t\t\tauto [v, arr] = to_array(u);",
            "\t\t\tout << \"{\";",
            "\t\t\tfor(auto i = 0; i < (int)arr.size(); ++ i){",
            "\t\t\t\tout << arr[i];",
            "\t\t\t\tif(i + 1 < (int)arr.size()) out << \", \";",
            "\t\t\t}",
            "\t\t\tout << \"}\";",
            "\t\t\treturn v;",
            "\t\t}",
            "\t\telse{",
            "\t\t\tauto [v, arr] = to_array_of_updates(u);",
            "\t\t\tout << \"{\";",
            "\t\t\tfor(auto i = 0; i < (int)arr.size(); ++ i){",
            "\t\t\t\tout << arr[i];",
            "\t\t\t\tif(i + 1 < (int)arr.size()) out << \", \";",
            "\t\t\t}",
            "\t\t\tout << \"}\";",
            "\t\t\treturn v;",
            "\t\t}",
            "\t}",
            "};",
            "",
            "// Supports query",
            "template<class T, class F>",
            "auto make_Q_segment_tree_persistent(F TT, T T_id){",
            "\tusing U = int;",
            "\tauto _UU = [&](U, U)->U{ return U{}; };",
            "\tauto _UT = [&](U, T)->T{ return T{}; };",
            "\treturn segment_tree_persistent_base<true, false, T, U, F, decltype(_UU), decltype(_UT)>(TT, T_id, _UU, U{}, _UT);",
            "}",
            "// Supports update",
            "template<class U, class F>",
            "auto make_U_segment_tree_persistent(F UU, U U_id){",
            "\tusing T = int;",
            "\tauto _TT = [&](T, T)->T{ return T{}; };",
            "\tauto _UT = [&](U, T)->T{ return T{}; };",
            "\treturn segment_tree_persistent_base<false, true, T, U, decltype(_TT), F, decltype(_UT)>(_TT, T{}, UU, U_id, _UT);",
            "}",
            "// Supports query and update",
            "template<class T, class U, class F1, class F2, class F3>",
            "auto make_QU_segment_tree_persistent(F1 TT, T T_id, F2 UU, U U_id, F3 UT){",
            "\treturn segment_tree_persistent_base<true, true, T, U, F1, F2, F3>(TT, T_id, UU, U_id, UT);",
            "}"
        ],
        "description": "tranxuanbach"
    }
}