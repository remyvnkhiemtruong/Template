{
    "tranxuanbach": {
        "prefix": "factorizer_over_finite_field",
        "body": [
            "// Requires finite_field and power_series_naive",
            "template<class FF>",
            "struct factorizer_over_finite_field{",
            "\tusing P = power_series_naive_base<FF, _quadratic<FF>>;",
            "\tstatic void _reduce_and_monicify(P &p){",
            "\t\tp.inplace_reduce();",
            "\t\tassert(p);",
            "\t\tFF x = p.back();",
            "\t\tif(x != FF{1}){",
            "\t\t\tx = 1 / x;",
            "\t\t\tfor(auto &y: p) y *= x;",
            "\t\t}",
            "\t}",
            "\t// Given p,",
            "\t// find factorization p = \\prod{f^e} where f is square-free",
            "\tstatic vector<pair<P, int>> factorize_square_free(P p){",
            "\t\t_reduce_and_monicify(p);",
            "\t\tif((int)p.size() == 1) return {};",
            "\t\tif(!p.derivative()){",
            "\t\t\tassert(((int)p.size() - 1) % FF::characteristic == 0);",
            "\t\t\tP q(((int)p.size() - 1) / FF::characteristic + 1);",
            "\t\t\tfor(auto i = 0; i < (int)q.size(); ++ i) q[i] = p[FF::characteristic * i];",
            "\t\t\tauto fact = factorize_square_free(q);",
            "\t\t\tfor(auto &[_, e]: fact) e *= FF::characteristic;",
            "\t\t\treturn fact;",
            "\t\t}",
            "\t\tP g = gcd(p, p.derivative());",
            "\t\t_reduce_and_monicify(g);",
            "\t\tif((int)g.size() == 1) return {{p, 1}};",
            "\t\tauto fact_left = factorize_square_free(g);",
            "\t\tauto fact_right = factorize_square_free(p / g);",
            "\t\tfact_left.insert(fact_left.end(), fact_right.begin(), fact_right.end());",
            "\t\treturn fact_left;",
            "\t}",
            "\t// Given square-free p,",
            "\t// find factorization p = \\prod{f} where f is a product of irreducible polynomials of equal degree d",
            "\tstatic vector<pair<P, int>> factorize_distinct_degree(P p){",
            "\t\t_reduce_and_monicify(p);",
            "\t\tvector<pair<P, int>> res;",
            "\t\tfor(auto i = 1; 2 * i <= (int)p.size() - 1; ++ i){",
            "\t\t\tP q{0, 1};",
            "\t\t\tfor(auto j = 1; j <= i; ++ j) q.inplace_power_mod(FF::size, p);",
            "\t\t\tq -= P{0, 1};",
            "\t\t\tP g = gcd(p, q);",
            "\t\t\t_reduce_and_monicify(g);",
            "\t\t\tif((int)g.size() != 1){",
            "\t\t\t\tres.push_back({g, i});",
            "\t\t\t\t(p /= g).inplace_reduce();",
            "\t\t\t}",
            "\t\t}",
            "\t\tif((int)p.size() >= 2) res.push_back({p, (int)p.size() - 1});",
            "\t\treturn res;",
            "\t}",
            "\t// WARNING: Success rate 1/ground_field_size for finite fields of order 2^{2k+1}",
            "\t// For fiels of order 2^{2k}, success rate is 1/3, and for odd characteristics, 1/2",
            "\t// Given square-free p which is a product of irreducible polynomials of equal degree d,",
            "\t// find factorization of it into irreducible polynomials",
            "\tstatic vector<P> factorize_equal_degree(int d, P p){",
            "\t\tassert(d >= 1);",
            "\t\t_reduce_and_monicify(p);",
            "\t\tassert(((int)p.size() - 1) % d == 0);",
            "\t\tif((int)p.size() == 1) return {};",
            "\t\tint obj = ((int)p.size() - 1) / d;",
            "\t\tvector<P> res{p}, res_next;",
            "\t\tfor(mt19937 rng(1564); (int)res.size() < obj; ){",
            "\t\t\tP q((int)p.size());",
            "\t\t\tfor(auto &x: q) x = FF::generate(rng);",
            "\t\t\tP g = gcd(p, q);",
            "\t\t\t_reduce_and_monicify(g);",
            "\t\t\tif((int)g.size() == 1){",
            "\t\t\t\tif(FF::characteristic >= 3){",
            "\t\t\t\t\tP base = q.power_mod((FF::size - 1) / 2, p);",
            "\t\t\t\t\tg = base;",
            "\t\t\t\t\tfor(auto i = 0; i < d - 1; ++ i) (g = g.power_mod(FF::size, p) * base % p).inplace_reduce();",
            "\t\t\t\t\t++ g;",
            "\t\t\t\t}",
            "\t\t\t\telse{",
            "\t\t\t\t\tif(FF::dimension % 2 == 0){",
            "\t\t\t\t\t\tP base = q.power_mod((FF::size - 1) / 3, p);",
            "\t\t\t\t\t\tg = base;",
            "\t\t\t\t\t\tfor(auto i = 0; i < d - 1; ++ i) (g = g.power_mod(FF::size, p) * base % p).inplace_reduce();",
            "\t\t\t\t\t\t++ g;",
            "\t\t\t\t\t}",
            "\t\t\t\t\telse{",
            "\t\t\t\t\t\t// TODO: Success rate for this part is 1/field_size",
            "\t\t\t\t\t\t// Improve it to 1/3 by factorizing over quadratic extension and merging conjugates",
            "\t\t\t\t\t\tg = q;",
            "\t\t\t\t\t\tfor(auto i = 0; i < d - 1; ++ i) g = q + g.power_mod(FF::size, p);",
            "\t\t\t\t\t\t(g %= p).inplace_reduce();",
            "\t\t\t\t\t}",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t\tres_next.clear();",
            "\t\t\tfor(auto p: res){",
            "\t\t\t\t_reduce_and_monicify(p);",
            "\t\t\t\tif((int)p.size() == d + 1){",
            "\t\t\t\t\tres_next.push_back(p);",
            "\t\t\t\t\tcontinue;",
            "\t\t\t\t}",
            "\t\t\t\tP h = gcd(g, p);",
            "\t\t\t\tif((int)h.size() == 1 || (int)h.size() == (int)p.size()){",
            "\t\t\t\t\tres_next.push_back(p);",
            "\t\t\t\t\tcontinue;",
            "\t\t\t\t}",
            "\t\t\t\t_reduce_and_monicify(h);",
            "\t\t\t\tres_next.insert(res_next.end(), {h, p / h});",
            "\t\t\t}",
            "\t\t\tswap(res, res_next);",
            "\t\t}",
            "\t\treturn res;",
            "\t}",
            "\tstatic vector<pair<P, int>> factorize(P p){",
            "\t\t_reduce_and_monicify(p);",
            "\t\tvector<pair<P, int>> res;",
            "\t\tauto fact_square_free = factorize_square_free(p);",
            "\t\tfor(auto [f0, e]: fact_square_free){",
            "\t\t\tauto fact_distinct_degree = factorize_distinct_degree(f0);",
            "\t\t\tfor(auto &[f1, d]: fact_distinct_degree){",
            "\t\t\t\tauto fact_equal_degree = factorize_equal_degree(d, f1);",
            "\t\t\t\tfor(auto &f2: fact_equal_degree) res.push_back({f2, e});",
            "\t\t\t}",
            "\t\t}",
            "\t\tsort(res.begin(), res.end());",
            "\t\tauto temp = res;",
            "\t\tres.clear();",
            "\t\tfor(auto [f, e]: temp){",
            "\t\t\t_reduce_and_monicify(f);",
            "\t\t\tif(res.empty() || res.back().first != f) res.push_back({f, e});",
            "\t\t\telse res.back().second += e;",
            "\t\t}",
            "\t\treturn res;",
            "\t}",
            "};"
        ],
        "description": "tranxuanbach"
    }
}