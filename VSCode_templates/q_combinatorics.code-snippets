{
    "tranxuanbach": {
        "prefix": "q_combinatorics",
        "body": [
            "// q-analog of combinatorics class",
            "// T must be of modular type",
            "template<class T>",
            "struct q_combinatorics{",
            "\tT q, invq, invq1;",
            "\tint SZ = 0;",
            "\tvector<T> q_power;           // q^i",
            "\tvector<T> q_quadratic_power; // q^{i*(i-1)/2}",
            "\tvector<T> q_number;          // 1 + q + ... + q^{i-1}",
            "\tvector<T> q_inv;             // 1 / q_number[i]",
            "\tvector<T> q_fact;            // q_number[1] * ... * q_number[i]",
            "\tvector<T> q_invfact;         // 1 / q_fact[i]",
            "\tq_combinatorics(T q): q(q){ }",
            "\t// O(SZ)",
            "\tq_combinatorics(T q, int SZ): q(q), invq(1 / q), invq1(1 / (1 - q)), SZ(SZ), q_power(SZ + 1, 1), q_quadratic_power(SZ + 1, 1), q_number(SZ + 1), q_inv(SZ + 1, 1), q_fact(SZ + 1, 1), q_invfact(SZ + 1, 1){",
            "\t\tassert(q >= 2);",
            "\t\tfor(auto i = 1; i <= SZ; ++ i){",
            "\t\t\tq_power[i] = q_power[i - 1] * q;",
            "\t\t\tq_quadratic_power[i] = q_quadratic_power[i - 1] * q_power[i - 1];",
            "\t\t\tq_number[i] = q_number[i - 1] + q_power[i - 1];",
            "\t\t\tq_fact[i] = q_fact[i - 1] * q_number[i];",
            "\t\t}",
            "\t\t// Note: even when q_fact[start] = 0, this workaround allows us to correctly compute fixed_rank_sequence_count",
            "\t\tint start = SZ;",
            "\t\twhile(start >= 0 && q_fact[start] == 0) -- start;",
            "\t\tq_invfact[start] = 1 / q_fact[start];",
            "\t\tfor(auto i = start - 1; i >= 0; -- i){",
            "\t\t\tq_invfact[i] = q_invfact[i + 1] * q_number[i + 1];",
            "\t\t\tq_inv[i + 1] = q_invfact[i + 1] * q_fact[i];",
            "\t\t}",
            "\t}",
            "\t// Gaussian Binomial Coefficient (https://en.wikipedia.org/wiki/Gaussian_binomial_coefficient)",
            "\t// C(n, k) =",
            "\t//  ((1-q^n)*...*(1-q^{n-r+1})) / ((1-q)*...*(1-q^r))",
            "\t// Number of subspaces of dimension k of an F_{q}-vector space of dimension n",
            "\t// q-Binomial Theorem:",
            "\t//  \\prod_{i=0}^{n-1} (1+q^{i}X) = \\sum_{i=0}^n q^{k(k-1)/2} * C(n,i) * X^i",
            "\t// O(1)",
            "\tT C(int n, int k) const{",
            "\t\tassert(0 <= min(n, k) && max(n, k) <= SZ);",
            "\t\treturn n >= k ? q_fact[n] * q_invfact[k] * q_invfact[n - k] : T{0};",
            "\t}",
            "\t// P(n, k) = (q^n-1)*...*(q^n-q^{k-1})",
            "\t// Number of k-tuples of independent vectors of an F_{q}-vector space of dimension n",
            "\t// Number of n by k matrices of rank k",
            "\t// O(1)",
            "\tT P(int n, int k) const{",
            "\t\tassert(0 <= min(n, k) && max(n, k) <= SZ);",
            "\t\treturn n >= k ? q_fact[n] * q_invfact[n - k] * q_quadratic_power[k] : T{0};",
            "\t}",
            "\t// q-Binomial Theorem for negative power",
            "\t//  \\prod_{i=0}^{n-1} 1/(1-q^{i}X) = \\sum_{i=0}^\\infty H(n,i) * X^i",
            "\tT H(int n, int k) const{",
            "\t\tassert(0 <= min(n, k));",
            "\t\treturn C(n + k - 1, k);",
            "\t}",
            "\t// O(n * m)",
            "\tvector<vector<T>> precalc_C(int n, int m) const{",
            "\t\tvector<vector<T>> c(n + 1, vector<T>(m + 1));",
            "\t\tfor(auto i = 0; i <= n; ++ i) for(auto j = 0; j <= min(i, m); ++ j) c[i][j] = i && j ? c[i - 1][j - 1] + q_power[j] * c[i - 1][j] : T(1);",
            "\t\treturn c;",
            "\t}",
            "\t// O(min(k, n - k))",
            "\tT naive_C(long long n, long long k) const{",
            "\t\tassert(0 <= min(n, k));",
            "\t\tif(n < k) return 0;",
            "\t\tk = min(k, n - k);",
            "\t\tassert(k <= SZ);",
            "\t\tT res = 1, pow = q.power(n - k);",
            "\t\tfor(auto i = n - k + 1; i <= n; ++ i) res *= (1 - (pow *= q)) * invq1;",
            "\t\treturn res * q_invfact[k];",
            "\t}",
            "\t// O(k)",
            "\tT naive_P(long long n, int k) const{",
            "\t\tassert(0 <= min<long long>(n, k) && k <= SZ);",
            "\t\tif(n < k) return 0;",
            "\t\tT res = 1, pow = q.power(n - k);",
            "\t\tfor(auto i = n - k + 1; i <= n; ++ i) res *= (pow *= q) - 1;",
            "\t\treturn res * q_quadratic_power[k];",
            "\t}",
            "\t// O(k)",
            "\tT naive_H(long long n, int k) const{",
            "\t\tassert(0 <= min<long long>(n, k));",
            "\t\treturn naive_C(n + k - 1, k);",
            "\t}",
            "\t// Number of length len sequences of vectors in F_{q}-vector space of dimension n, where the sequence has rank r",
            "\t// O(1)",
            "\tT fixed_rank_sequence_count(int n, int len, int r) const{",
            "\t\tassert(0 <= min({n, len, r}) && max({n, len, r}) <= SZ);",
            "\t\tif(min(n, len) < r) return 0;",
            "\t\treturn P(n, r) * C(len, r);",
            "\t}",
            "\t// Compute fixed_rank_sequence_count(n, len, r) for all 0 <= r <= th",
            "\t// O(log(n) + log(len) + log(mod) + th)",
            "\tvector<T> precalc_fixed_rank_sequence_count(long long n, long long len, int th) const{",
            "\t\tint actual_th = min<long long>({n, len, th});",
            "\t\tassert(0 <= actual_th && th <= SZ);",
            "\t\tvector<T> res(th + 1);",
            "\t\tres[0] = 1;",
            "\t\tT qn = q.power(n), qlen = q.power(len), qr = 1;",
            "\t\tfor(auto r = 1; r <= actual_th; ++ r){",
            "\t\t\tres[r] = res[r - 1] * (qn - qr) * (qlen - qr);",
            "\t\t\tqr *= q;",
            "\t\t}",
            "\t\tqn = 1;",
            "\t\tfor(auto r = 0; r <= actual_th; ++ r){",
            "\t\t\tres[r] *= q_invfact[r] * qn;",
            "\t\t\tqn *= -invq1;",
            "\t\t}",
            "\t\tqn = 1 / q_quadratic_power[actual_th];",
            "\t\tfor(auto r = actual_th; r >= 2; -- r){",
            "\t\t\tres[r] *= qn;",
            "\t\t\tqn *= q_power[r - 1];",
            "\t\t}",
            "\t\treturn res;",
            "\t}",
            "};"
        ],
        "description": "tranxuanbach"
    }
}