{
    "tranxuanbach": {
        "prefix": "cartesian_tree",
        "body": [
            "// Source: https://en.wikipedia.org/wiki/Cartesian_tree#Efficient_construction",
            "// Tie broken by index (smaller index has lower depth)",
            "template<class T, class Compare = less<>>",
            "struct cartesian_tree{",
            "\tint n = 0, root = -1;",
            "\tvector<T> data;",
            "\tvector<int> pv;",
            "\tvector<array<int, 2>> adj;",
            "\tCompare cmp;",
            "\tcartesian_tree(const vector<T> &data = {}, Compare cmp = less<>()): cmp(cmp){",
            "\t\textend(data);",
            "\t}",
            "\tcartesian_tree &operator=(const cartesian_tree &ct){",
            "\t\tn = ct.n;",
            "\t\troot = ct.root;",
            "\t\tdata = ct.data;",
            "\t\tpv = ct.pv;",
            "\t\tadj = ct.adj;",
            "\t}",
            "\tvoid extend(const vector<T> &a){",
            "\t\tfor(auto x: a) extend(x);",
            "\t}",
            "\t// Amortized O(1)",
            "\tvoid extend(T x){",
            "\t\tdata.push_back(x);",
            "\t\tpv.push_back(-1);",
            "\t\tadj.push_back({-1, -1});",
            "\t\tint u = n - 1;",
            "\t\twhile(~u && cmp(x, data[u])) u = pv[u];",
            "\t\tif(!~u && ~root || ~u && ~adj[u][1]){",
            "\t\t\tint v = ~u ? adj[u][1] : root;",
            "\t\t\tpv[v] = n;",
            "\t\t\tadj[n][0] = v;",
            "\t\t}",
            "\t\tif(~u){",
            "\t\t\tadj[u][1] = n;",
            "\t\t\tpv[n] = u;",
            "\t\t}",
            "\t\tif(!~u) root = n;",
            "\t\t++ n;",
            "\t}",
            "\t// Warning: calling extend() invalidates the bfs states",
            "\tvector<int> order;",
            "\tvector<int> pos;",
            "\tvector<int> size;",
            "\tvector<int> depth;",
            "\tvector<array<int, 2>> range;",
            "\tvector<int> q;",
            "\tvoid traverse(bool dfs = true){",
            "\t\torder.clear();",
            "\t\tpos.assign(n, -1);",
            "\t\tsize.assign(n, 1);",
            "\t\tdepth.assign(n, 0);",
            "\t\trange.assign(n, {});",
            "\t\tq = {root};",
            "\t\tif(dfs){ // dfs",
            "\t\t\twhile(!q.empty()){",
            "\t\t\t\tint u = q.back();",
            "\t\t\t\tq.pop_back();",
            "\t\t\t\tpos.push_back((int)order.size());",
            "\t\t\t\torder.push_back(u);",
            "\t\t\t\tfor(auto i = 1; i >= 0; -- i) if(~adj[u][i]){",
            "\t\t\t\t\tdepth[adj[u][i]] = depth[u] + 1;",
            "\t\t\t\t\tq.push_back(adj[u][i]);",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t}",
            "\t\telse{ // bfs",
            "\t\t\tfor(auto l = 0; l < (int)q.size(); ++ l){",
            "\t\t\t\tint u = q[l];",
            "\t\t\t\tpos.push_back((int)order.size());",
            "\t\t\t\torder.push_back(u);",
            "\t\t\t\tfor(auto v: adj[u]) if(~v){",
            "\t\t\t\t\tdepth[v] = depth[u] + 1;",
            "\t\t\t\t\tq.push_back(v);",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t}",
            "\t\tfor(auto i = (int)order.size() - 1; i >= 0; -- i){",
            "\t\t\tint u = order[i];",
            "\t\t\tfor(auto v: adj[u]) if(~v) size[u] += size[v];",
            "\t\t\trange[u] = {u, u + 1};",
            "\t\t\tif(~adj[u][0]) range[u][0] -= size[adj[u][0]];",
            "\t\t\tif(~adj[u][1]) range[u][1] += size[adj[u][1]];",
            "\t\t\tassert(range[u][1] - range[u][0] == size[u]);",
            "\t\t}",
            "\t}",
            "};"
        ],
        "description": "tranxuanbach"
    }
}