{
    "tranxuanbach": {
        "prefix": "segment_tree",
        "body": [
            "template<bool HAS_QUERY, bool HAS_UPDATE, class T, class U, class F1, class F2, class F3>",
            "struct segment_tree_base{",
            "\tstatic_assert(HAS_QUERY || HAS_UPDATE);",
            "#define ifQ if constexpr(HAS_QUERY)",
            "#define ifU if constexpr(HAS_UPDATE)",
            "\tint n, size, log;",
            "\tvector<T> data;",
            "\tvector<U> data_action;",
            "\tF1 TT; // monoid operation (always adjacent)",
            "\tT T_id; // monoid identity",
            "\tF2 UU; // monoid operation (superset, subset)",
            "\tU U_id; // monoid identity",
            "\tF3 UT; // action of U on T (superset, subset)",
            "\t// O(n)",
            "\tsegment_tree_base(F1 TT, T T_id, F2 UU, U U_id, F3 UT): TT(TT), T_id(T_id), UU(UU), U_id(U_id), UT(UT){ }",
            "\tsegment_tree_base &operator=(const segment_tree_base &seg){",
            "\t\tn = seg.n;",
            "\t\tsize = seg.size;",
            "\t\tlog = seg.log;",
            "\t\tdata = seg.data;",
            "\t\tdata_action = seg.data_action;",
            "\t}",
            "\t// O(1)",
            "\tfriend void swap(segment_tree_base &x, segment_tree_base &y){",
            "\t\tswap(x.n, y.n);",
            "\t\tswap(x.size, y.size);",
            "\t\tswap(x.log, y.log);",
            "\t\tswap(x.data, y.data);",
            "\t\tswap(x.data_action, y.data_action);",
            "\t}",
            "\t// O(n)",
            "\tvoid build(int n){",
            "\t\tassert(n >= 0);",
            "\t\tthis->n = n;",
            "\t\tsize = 1;",
            "\t\twhile(size < n) size <<= 1;",
            "\t\tlog = __lg(size);",
            "\t\tifQ data.assign(size << 1, T_id);",
            "\t\tifU data_action.assign(HAS_QUERY ? size : size << 1, U_id);",
            "\t}",
            "\t// O(n)",
            "\tvoid build(int n, T x){",
            "\t\tstatic_assert(HAS_QUERY);",
            "\t\tassert(n >= 0);",
            "\t\tthis->n = n;",
            "\t\tsize = 1;",
            "\t\twhile(size < n) size <<= 1;",
            "\t\tlog = __lg(size);",
            "\t\tdata.assign(size << 1, T_id);",
            "\t\tfill(data.begin() + size, data.begin() + size + n, x);",
            "\t\tfor(auto i = size - 1; i >= 1; -- i) refresh(i);",
            "\t\tifU data_action.assign(size, U_id);",
            "\t}",
            "\t// O(n)",
            "\ttemplate<class V>",
            "\tvoid build(const vector<V> &a){",
            "\t\tstatic_assert(HAS_QUERY);",
            "\t\tn = (int)a.size();",
            "\t\tsize = 1;",
            "\t\twhile(size < n) size <<= 1;",
            "\t\tlog = __lg(size);",
            "\t\tdata.assign(size << 1, T_id);",
            "\t\tcopy(a.begin(), a.end(), data.begin() + size);",
            "\t\tfor(auto i = size - 1; i >= 1; -- i) refresh(i);",
            "\t\tifU data_action.assign(size, U_id);",
            "\t}",
            "\t// O(n)",
            "\tvoid build_action(int n){",
            "\t\tstatic_assert(!HAS_QUERY && HAS_UPDATE);",
            "\t\tassert(n >= 0);",
            "\t\tbuild(n);",
            "\t}",
            "\t// O(n)",
            "\tvoid build_action(int n, U f){",
            "\t\tstatic_assert(!HAS_QUERY && HAS_UPDATE);",
            "\t\tassert(n >= 0);",
            "\t\tthis->n = n;",
            "\t\tsize = 1;",
            "\t\twhile(size < n) size <<= 1;",
            "\t\tlog = __lg(size);",
            "\t\tdata_action.assign(size << 1, U_id);",
            "\t\tfill(data_action.begin() + size, data_action.begin() + size + n, f);",
            "\t}",
            "\t// O(n)",
            "\ttemplate<class V>",
            "\tvoid build_action(const vector<V> &a){",
            "\t\tstatic_assert(!HAS_QUERY && HAS_UPDATE);",
            "\t\tn = (int)a.size();",
            "\t\tsize = 1;",
            "\t\twhile(size < n) size <<= 1;",
            "\t\tlog = __lg(size);",
            "\t\tdata_action.assign(size << 1, U_id);",
            "\t\tcopy(a.begin(), a.end(), data_action.begin() + size);",
            "\t}",
            "\t// O(1)",
            "\tvoid refresh(int u){",
            "\t\tstatic_assert(HAS_QUERY);",
            "\t\tdata[u] = TT(data[u << 1], data[u << 1 | 1]);",
            "\t}",
            "\t// O(1)",
            "\tvoid apply(int u, U f){",
            "\t\tstatic_assert(HAS_UPDATE);",
            "\t\tifQ data[u] = UT(f, data[u]);",
            "\t\tif(!HAS_QUERY || u < size) data_action[u] = UU(f, data_action[u]);",
            "\t}",
            "\t// O(1)",
            "\tvoid push(int u){",
            "\t\tstatic_assert(HAS_UPDATE);",
            "\t\tapply(u << 1, data_action[u]), apply(u << 1 | 1, data_action[u]);",
            "\t\tdata_action[u] = U_id;",
            "\t}",
            "\t// O(log(n)) if HAS_UPDATE, O(1) otherwise.",
            "\tT query(int p){",
            "\t\tstatic_assert(HAS_QUERY);",
            "\t\tassert(0 <= p && p < n);",
            "\t\tp += size;",
            "\t\tifU for(auto i = log; i >= 1; -- i) push(p >> i);",
            "\t\treturn data[p];",
            "\t}",
            "\t// O(log(n))",
            "\tU query_action(int p){",
            "\t\tstatic_assert(!HAS_QUERY && HAS_UPDATE);",
            "\t\tassert(0 <= p && p < n);",
            "\t\tp += size;",
            "\t\tifU for(auto i = log; i >= 1; -- i) push(p >> i);",
            "\t\treturn data_action[p];",
            "\t}",
            "\t// O(log(n))",
            "\tT query(int ql, int qr){",
            "\t\tstatic_assert(HAS_QUERY);",
            "\t\tassert(0 <= ql && ql <= qr && qr <= n);",
            "\t\tif(ql == qr) return T_id;",
            "\t\tql += size, qr += size;",
            "\t\tifU for(auto i = log; i >= 1; -- i){",
            "\t\t\tif(ql >> i << i != ql) push(ql >> i);",
            "\t\t\tif(qr >> i << i != qr) push(qr >> i);",
            "\t\t}",
            "\t\tT res_left = T_id, res_right = T_id;",
            "\t\tfor(; ql < qr; ql >>= 1, qr >>= 1){",
            "\t\t\tif(ql & 1) res_left = TT(res_left, data[ql ++]);",
            "\t\t\tif(qr & 1) res_right = TT(data[-- qr], res_right);",
            "\t\t}",
            "\t\treturn TT(res_left, res_right);",
            "\t}",
            "\t// O(1)",
            "\tT query_all() const{",
            "\t\tstatic_assert(HAS_QUERY);",
            "\t\treturn data[1];",
            "\t}",
            "\t// O(n)",
            "\tvector<T> to_array(){",
            "\t\tstatic_assert(HAS_QUERY);",
            "\t\tifU for(auto u = 1; u < size; ++ u) push(u);",
            "\t\treturn vector<T>(data.begin() + size, data.begin() + size + n);",
            "\t}",
            "\t// O(n)",
            "\tvector<U> to_array_of_updates(){",
            "\t\tstatic_assert(!HAS_QUERY && HAS_UPDATE);",
            "\t\tfor(auto u = 1; u < size; ++ u) push(u);",
            "\t\treturn vector<U>(data_action.begin() + size, data_action.begin() + size + n);",
            "\t}",
            "\t// O(log(n))",
            "\tvoid set(int p, T x){",
            "\t\tstatic_assert(HAS_QUERY);",
            "\t\tassert(0 <= p && p < n);",
            "\t\tp += size;",
            "\t\tifU for(auto i = log; i >= 1; -- i) push(p >> i);",
            "\t\tdata[p] = x;",
            "\t\tfor(auto i = 1; i <= log; ++ i) refresh(p >> i);",
            "\t}",
            "\t// O(log(n))",
            "\tvoid set_action(int p, U f){",
            "\t\tstatic_assert(!HAS_QUERY && HAS_UPDATE);",
            "\t\tassert(0 <= p && p < n);",
            "\t\tp += size;",
            "\t\tfor(auto i = log; i >= 1; -- i) push(p >> i);",
            "\t\tdata_action[p] = f;",
            "\t}",
            "\t// O(log(n))",
            "\tvoid update(int p, U f){",
            "\t\tstatic_assert(HAS_UPDATE);",
            "\t\tassert(0 <= p && p < n);",
            "\t\tp += size;",
            "\t\tfor(auto i = log; i >= 1; -- i) push(p >> i);",
            "\t\tifQ{",
            "\t\t\tdata[p] = UT(f, data[p]);",
            "\t\t\tfor(auto i = 1; i <= log; ++ i) refresh(p >> i);",
            "\t\t}",
            "\t\telse data_action[p] = UU(f, data_action[p]);",
            "\t}",
            "\t// O(log(n))",
            "\tvoid update(int ql, int qr, U f){",
            "\t\tstatic_assert(HAS_UPDATE);",
            "\t\tassert(0 <= ql && ql <= qr && qr <= n);",
            "\t\tif(ql == qr) return;",
            "\t\tql += size, qr += size;",
            "\t\tfor(auto i = log; i >= 1; -- i){",
            "\t\t\tif(ql >> i << i != ql) push(ql >> i);",
            "\t\t\tif(qr >> i << i != qr) push(qr >> i);",
            "\t\t}",
            "\t\tint _ql = ql, _qr = qr;",
            "\t\tfor(; ql < qr; ql >>= 1, qr >>= 1){",
            "\t\t\tif(ql & 1) apply(ql ++, f);",
            "\t\t\tif(qr & 1) apply(-- qr, f);",
            "\t\t}",
            "\t\tql = _ql, qr = _qr;",
            "\t\tifQ for(auto i = 1; i <= log; ++ i){",
            "\t\t\tif(ql >> i << i != ql) refresh(ql >> i);",
            "\t\t\tif(qr >> i << i != qr) refresh(qr >> i);",
            "\t\t}",
            "\t}",
            "\tvoid update_beats(int ql, int qr, auto exit_rule, auto enter_rule, auto update_rule){",
            "\t\tstatic_assert(HAS_QUERY && HAS_UPDATE);",
            "\t\tassert(0 <= ql && ql <= qr && qr <= n);",
            "\t\tif(ql == qr) return;",
            "\t\tql += size, qr += size;",
            "\t\tfor(auto i = log; i >= 1; -- i){",
            "\t\t\tif(ql >> i << i != ql) push(ql >> i);",
            "\t\t\tif(qr >> i << i != qr) push(qr >> i);",
            "\t\t}",
            "\t\tauto recurse = [&](auto self, int u)->void{",
            "\t\t\tif(exit_rule(data[u])) return;",
            "\t\t\tif(enter_rule(data[u])){",
            "\t\t\t\tapply(u, update_rule(data[u]));",
            "\t\t\t\treturn;",
            "\t\t\t}",
            "\t\t\tpush(u);",
            "\t\t\tself(self, u << 1), self(self, u << 1 | 1);",
            "\t\t\trefresh(u);",
            "\t\t};",
            "\t\tint _ql = ql, _qr = qr;",
            "\t\tfor(; ql < qr; ql >>= 1, qr >>= 1){",
            "\t\t\tif(ql & 1) recurse(recurse, ql ++);",
            "\t\t\tif(qr & 1) recurse(recurse, -- qr);",
            "\t\t}",
            "\t\tql = _ql, qr = _qr;",
            "\t\tfor(auto i = 1; i <= log; ++ i){",
            "\t\t\tif(ql >> i << i != ql) refresh(ql >> i);",
            "\t\t\tif(qr >> i << i != qr) refresh(qr >> i);",
            "\t\t}",
            "\t}",
            "\t// pred(sum[ql, r)) is T, T, ..., T, F, F, ..., F",
            "\t// Returns max r with T",
            "\t// O(log(n))",
            "\tint max_pref(int ql, auto pred){",
            "\t\tstatic_assert(HAS_QUERY);",
            "\t\tassert(0 <= ql && ql <= n && pred(T_id));",
            "\t\tif(ql == n) return n;",
            "\t\tql += size;",
            "\t\tifU for(auto i = log; i >= 1; -- i) push(ql >> i);",
            "\t\tT sum = T_id;",
            "\t\tdo{",
            "\t\t\twhile(~ql & 1) ql >>= 1;",
            "\t\t\tif(!pred(TT(sum, data[ql]))){",
            "\t\t\t\twhile(ql < size){",
            "\t\t\t\t\tifU push(ql);",
            "\t\t\t\t\tql = ql << 1;",
            "\t\t\t\t\tif(pred(TT(sum, data[ql]))) sum = TT(sum, data[ql ++]);",
            "\t\t\t\t}",
            "\t\t\t\treturn ql - size;",
            "\t\t\t}",
            "\t\t\tsum = TT(sum, data[ql]);",
            "\t\t\t++ ql;",
            "\t\t}while((ql & -ql) != ql);",
            "\t\treturn n;",
            "\t}",
            "\t// pred(sum[l, qr)) is F, F, ..., F, T, T, ..., T",
            "\t// Returns min l with T",
            "\t// O(log(n))",
            "\tint min_suff(int qr, auto pred){",
            "\t\tstatic_assert(HAS_QUERY);",
            "\t\tassert(0 <= qr && qr <= n && pred(T_id));",
            "\t\tif(qr == 0) return 0;",
            "\t\tqr += size;",
            "\t\tifU for(auto i = log; i >= 1; -- i) push(qr - 1 >> i);",
            "\t\tT sum = T_id;",
            "\t\tdo{",
            "\t\t\t-- qr;",
            "\t\t\twhile(qr > 1 && qr & 1) qr >>= 1;",
            "\t\t\tif(!pred(TT(data[qr], sum))){",
            "\t\t\t\twhile(qr < size){",
            "\t\t\t\t\tifU push(qr);",
            "\t\t\t\t\tqr = qr << 1 | 1;",
            "\t\t\t\t\tif(pred(TT(data[qr], sum))) sum = TT(data[qr --], sum);",
            "\t\t\t\t}",
            "\t\t\t\treturn qr + 1 - size;",
            "\t\t\t}",
            "\t\t\tsum = TT(data[qr], sum);",
            "\t\t}while((qr & -qr) != qr);",
            "\t\treturn 0;",
            "\t}",
            "\ttemplate<class output_stream>",
            "\tfriend output_stream &operator<<(output_stream &out, segment_tree_base<HAS_QUERY, HAS_UPDATE, T, U, F1, F2, F3> seg){",
            "\t\tout << \"{\";",
            "\t\tfor(auto i = 0; i < seg.n; ++ i){",
            "\t\t\tifQ out << seg.query(i);",
            "\t\t\telse out << seg.query_action(i);",
            "\t\t\tif(i != seg.n - 1) out << \", \";",
            "\t\t}",
            "\t\treturn out << '}';",
            "\t}",
            "#undef ifQ",
            "#undef ifU",
            "};",
            "",
            "// Supports query",
            "template<class T, class F>",
            "auto make_Q_segment_tree(F TT, T T_id){",
            "\tusing U = int;",
            "\tauto _UU = [&](U, U)->U{ return U{}; };",
            "\tauto _UT = [&](U, T)->T{ return T{}; };",
            "\treturn segment_tree_base<true, false, T, U, F, decltype(_UU), decltype(_UT)>(TT, T_id, _UU, U{}, _UT);",
            "}",
            "// Supports update",
            "template<class U, class F>",
            "auto make_U_segment_tree(F UU, U U_id){",
            "\tusing T = int;",
            "\tauto _TT = [&](T, T)->T{ return T{}; };",
            "\tauto _UT = [&](U, T)->T{ return T{}; };",
            "\treturn segment_tree_base<false, true, T, U, decltype(_TT), F, decltype(_UT)>(_TT, T{}, UU, U_id, _UT);",
            "}",
            "// Supports query and update",
            "template<class T, class U, class F1, class F2, class F3>",
            "auto make_QU_segment_tree(F1 TT, T T_id, F2 UU, U U_id, F3 UT){",
            "\treturn segment_tree_base<true, true, T, U, F1, F2, F3>(TT, T_id, UU, U_id, UT);",
            "}"
        ],
        "description": "tranxuanbach"
    }
}