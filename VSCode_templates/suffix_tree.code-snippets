{
    "tranxuanbach": {
        "prefix": "suffix_tree",
        "body": [
            "// Adjacency_Type: array<int, X> or map<Char_Type, int> where X is the size of the alphabet",
            "template<class Char_Type, class Adjacency_Type>",
            "struct suffix_tree{",
            "\tint n = 0; // length of the underlying string",
            "\tvector<Char_Type> s; // underlying string",
            "\t// Begin States",
            "\t// The position of the label of the parent edge in the string, temporary length of the parent edge, suffix link, parent vertex",
            "\tvector<int> pos{0}, len{numeric_limits<int>::max()}, link{0}, pv{0};",
            "\tvector<Adjacency_Type> next{{}};",
            "\t// End States",
            "\tint new_state(int p, int l = numeric_limits<int>::max()){",
            "\t\tpos.push_back(p);",
            "\t\tlen.push_back(l);",
            "\t\tlink.push_back(-1);",
            "\t\tpv.push_back(-1);",
            "\t\tnext.push_back({});",
            "\t\treturn (int)pos.size() - 1;",
            "\t}",
            "\tint u_last = 0, extra = 0;",
            "\tvoid extend(Char_Type c){",
            "\t\ts.push_back(c), ++ n, ++ extra;",
            "\t\tfor(auto last = 0; extra; ){",
            "\t\t\twhile(extra > len[next[u_last][s[n - extra]]]) u_last = next[u_last][s[n - extra]], extra -= len[u_last];",
            "\t\t\tChar_Type edge = s[n - extra];",
            "\t\t\tint u = next[u_last][edge];",
            "\t\t\tChar_Type t = s[pos[u] + extra - 1];",
            "\t\t\tif(!u){",
            "\t\t\t\tu = new_state(n - extra);",
            "\t\t\t\tlink[last] = u_last;",
            "\t\t\t\tlast = 0;",
            "\t\t\t}",
            "\t\t\telse if(t == c){",
            "\t\t\t\tlink[last] = u_last;",
            "\t\t\t\treturn;",
            "\t\t\t}",
            "\t\t\telse{",
            "\t\t\t\tint v = new_state(pos[u], extra - 1);",
            "\t\t\t\tnext[v][c] = new_state(n - 1), pv[next[v][c]] = v;",
            "\t\t\t\tnext[v][t] = u, pv[u] = v;",
            "\t\t\t\tpos[u] += extra - 1, len[u] -= extra - 1;",
            "\t\t\t\tu = last = link[last] = v;",
            "\t\t\t}",
            "\t\t\tnext[u_last][edge] = u, pv[u] = u_last;",
            "\t\t\tif(u_last) u_last = link[u_last];",
            "\t\t\telse -- extra;",
            "\t\t}",
            "\t}",
            "\tvoid extend(const vector<Char_Type> &s){",
            "\t\tfor(auto c: s) extend(c);",
            "\t}",
            "\tint size() const{ // # of states",
            "\t\treturn (int)pos.size();",
            "\t}",
            "\tint length(int u) const{ // actual length of the parent edge",
            "\t\treturn u ? min(len[u], (int)s.size() - pos[u]) : 0;",
            "\t}",
            "};"
        ],
        "description": "tranxuanbach"
    }
}