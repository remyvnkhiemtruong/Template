{
    "tranxuanbach": {
        "prefix": "lazy_segment_tree",
        "body": [
            "template<class Q,",
            "\t\t\t\t\tQ (*merge)(Q, Q),",
            "\t\t\t\t\tQ (*identity)(),",
            "\t\t\t\t\tclass L,",
            "\t\t\t\t\tL (*composite)(L, L),",
            "\t\t\t\t\tL (*identity_action)(int, int),",
            "\t\t\t\t\tQ (*act)(L, Q)>",
            "struct lazy_segment_tree{",
            "\tlazy_segment_tree(): lazy_segment_tree(0){}",
            "\tlazy_segment_tree(int n): lazy_segment_tree(vector<Q>(n)){}",
            "\tlazy_segment_tree(const vector<Q> &v): n((int)v.size()){ // O(n)",
            "\t\tlog = __lg(n + 1) + 1, size = 1 << log;",
            "\t\tval = vector<Q>(size << 1, identity()), lazy = vector<L>(size);",
            "\t\tcopy(v.begin(), v.end(), val.begin() + size);",
            "\t\tfor(int i = 1; i < size; ++ i){",
            "\t\t\tint h = log - __lg(i);",
            "\t\t\tlazy[i] = identity_action((i << h) - size, (i + 1 << h) - size);",
            "\t\t}",
            "\t\tfor(int i = size - 1; i >= 1; -- i) refresh(i);",
            "\t}",
            "\tQ query(int p){ // O(log n)",
            "\t\tassert(0 <= p && p < n);",
            "\t\tp += size;",
            "\t\tfor(int i = log; i >= 1; -- i) push(p >> i);",
            "\t\treturn val[p];",
            "\t}",
            "\tQ query(int l, int r){ // O(log n)",
            "\t\tassert(0 <= l && l <= r && r <= n);",
            "\t\tif(l == r) return {};",
            "\t\tl += size, r += size;",
            "\t\tfor(int i = log; i >= 1; -- i) {",
            "\t\t\tif(((l >> i) << i) != l) push(l >> i);",
            "\t\t\tif(((r >> i) << i) != r) push(r >> i);",
            "\t\t}",
            "\t\tQ sml = identity(), smr = identity();",
            "\t\tfor(; l < r; l >>= 1, r >>= 1){",
            "\t\t\tif(l & 1) sml = merge(sml, val[l ++]);",
            "\t\t\tif(r & 1) smr = merge(val[-- r], smr);",
            "\t\t}",
            "\t\treturn merge(sml, smr);",
            "\t}",
            "\tQ query_all(){ return val[1]; } // O(1)",
            "\tvoid set(int p, Q x){ // O(log n)",
            "\t\tassert(0 <= p && p < n);",
            "\t\tp += size;",
            "\t\tfor(int i = log; i >= 1; -- i) push(p >> i);",
            "\t\tval[p] = x;",
            "\t\tfor(int i = 1; i <= log; ++ i) refresh(p >> i);",
            "\t}",
            "\tvoid update(int p, L f){ // O(log n)",
            "\t\tassert(0 <= p && p < n);",
            "\t\tp += size;",
            "\t\tfor(int i = log; i >= 1; -- i) push(p >> i);",
            "\t\tval[p] = act(f, val[p]);",
            "\t\tfor(int i = 1; i <= log; ++ i) refresh(p >> i);",
            "\t}",
            "\tvoid update(int l, int r, L f){ // O(log n)",
            "\t\tassert(0 <= l && l <= r && r <= n);",
            "\t\tif(l == r) return;",
            "\t\tl += size, r += size;",
            "\t\tfor(int i = log; i >= 1; -- i){",
            "\t\t\tif(((l >> i) << i) != l) push(l >> i);",
            "\t\t\tif (((r >> i) << i) != r) push(r - 1 >> i);",
            "\t\t}",
            "\t\tint l2 = l, r2 = r;",
            "\t\tfor(; l < r; l >>= 1, r >>= 1){",
            "\t\t\tif(l & 1) apply(l ++, f);",
            "\t\t\tif(r & 1) apply(-- r, f);",
            "\t\t}",
            "\t\tl = l2, r = r2;",
            "\t\tfor(int i = 1; i <= log; ++ i){",
            "\t\t\tif(((l >> i) << i) != l) refresh(l >> i);",
            "\t\t\tif(((r >> i) << i) != r) refresh((r - 1) >> i);",
            "\t\t}",
            "\t}",
            "\ttemplate<class G> int partition_point_pref(int l, G g){ // O(log n)",
            "\t\tassert(0 <= l && l <= n), assert(g({}));",
            "\t\tif(l == n) return n;",
            "\t\tl += size;",
            "\t\tfor(int i = log; i >= 1; ++ i) push(l >> i);",
            "\t\tQ sm = identity();",
            "\t\tdo{",
            "\t\t\twhile(~l & 1) l >>= 1;",
            "\t\t\tif(!g(sm + val[l])){",
            "\t\t\t\twhile(l < size){",
            "\t\t\t\t\tpush(l);",
            "\t\t\t\t\tl = l << 1;",
            "\t\t\t\t\tif(g(merge(sm, val[l]))) sm = merge(sm, val[l ++]);",
            "\t\t\t\t}",
            "\t\t\t\treturn l - size;",
            "\t\t\t}",
            "\t\t\tsm = merge(sm, val[l]);",
            "\t\t\t++ l;",
            "\t\t}while((l & -l) != l);",
            "\t\treturn n;",
            "\t} // f(sum[l, r)) is T, T, ..., T, F, F, ..., F, returns max r with T",
            "\ttemplate<class G> int partition_point_suff(int r, G g){ // O(log n)",
            "\t\tassert(0 <= r && r <= n), assert(g({}));",
            "\t\tif(r == 0) return 0;",
            "\t\tr += size;",
            "\t\tfor(int i = log; i >= 1; -- i) push(r - 1 >> i);",
            "\t\tQ sm = identity();",
            "\t\tdo{",
            "\t\t\t-- r;",
            "\t\t\twhile(r > 1 && r & 1) r >>= 1;",
            "\t\t\tif(!g(merge(val[r], sm))){",
            "\t\t\t\twhile(r < size){",
            "\t\t\t\t\tpush(r);",
            "\t\t\t\t\tr = r << 1 | 1;",
            "\t\t\t\t\tif(g(merge(val[r], sm))) sm = merge(val[r --], sm);",
            "\t\t\t\t}",
            "\t\t\t\treturn r + 1 - size;",
            "\t\t\t}",
            "\t\t\tsm = merge(val[r], sm);",
            "\t\t}while((r & -r) != r);",
            "\t\treturn 0;",
            "\t} // f(sum[l, r)) is F, F, ..., F, T, T, ..., T, returns min l with T",
            "\tint n, size, log;",
            "\tvector<Q> val;",
            "\tvector<L> lazy;",
            "\tvoid refresh(int i){ val[i] = merge(val[i << 1], val[i << 1 | 1]); }",
            "\tvoid apply(int i, L f){",
            "\t\tval[i] = act(f, val[i]);",
            "\t\tif(i < size) lazy[i] = composite(f, lazy[i]);",
            "\t}",
            "\tvoid push(int i){",
            "\t\tapply(i << 1, lazy[i]), apply(i << 1 | 1, lazy[i]);",
            "\t\tint h = log - __lg(i);",
            "\t\tlazy[i] = identity_action((i << h) - size, (i + 1 << h) - size);",
            "\t}",
            "};",
            "using Q = long long; // Monoid (Query Type)",
            "Q merge(Q x, Q y){ // merges adjacent intervals",
            "\treturn max(x, y);",
            "}",
            "Q identity(){ // Monoid Identity",
            "\treturn numeric_limits<long long>::min() / 2;",
            "}",
            "using L = long long; // Semigroup (Lazy Type)",
            "L composite(L f, L g){ // composites superset and subset ",
            "\treturn f + g;",
            "}",
            "L identity_action(int l, int r){",
            "\treturn 0;",
            "}",
            "Q act(L f, Q x){ // semigroup action of L on Q, act superset onto subset",
            "\treturn f + x;",
            "}",
            "// lazy_segment_tree<Q, merge, identity, L, composite, identity_action, act> seg(a);"
        ],
        "description": "tranxuanbach"
    }
}