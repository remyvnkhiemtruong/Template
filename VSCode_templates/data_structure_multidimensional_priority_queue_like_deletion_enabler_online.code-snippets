{
    "tranxuanbach": {
        "prefix": "data_structure_multidimensional_priority_queue_like_deletion_enabler_online",
        "body": [
            "// For a commutative data structure supporting update, where each update has d associated priorities,",
            "// support deletion of update with lowest priority in specified dimension online.",
            "// Assumes that no two priorities are equal at any moment in all dimension.",
            "// Source: https://codeforces.com/blog/entry/111117",
            "template<class P, class I, class S, class R, class Compare = less<>>",
            "struct data_structure_multidimensional_priority_queue_like_deletion_enabler_online{",
            "\tint n, d; // Elements should lie in range [0, n).",
            "\tdouble alpha;",
            "\tI insert; // insert(i): insert the i-th update.",
            "\tS state; // state(): return the state of the DS as an integer.",
            "\tR reverse_to; // reverse_to(s): reverse the state of the DS to s.",
            "\tvector<vector<P>> priority;",
            "\tvector<int> stack, log;",
            "\tvector<map<P, int, Compare>> order;",
            "\tdata_structure_multidimensional_priority_queue_like_deletion_enabler_online(int n, int d, P _type_deducer, I insert, S state, R reverse_to, Compare cmp = less<>()): n(n), d(d), was(n), insert(insert), state(state), reverse_to(reverse_to), priority(n), log({state()}), order(d, map<P, int, Compare>(cmp)){",
            "\t\tassert(n >= 0 && d >= 1);",
            "\t\talpha = min(0.5, 1 - sqrt(1 - 1.0 / d));",
            "\t}",
            "\tvoid clear(){",
            "\t\tstack.clear();",
            "\t\tlog.resize(1);",
            "\t\treverse_to(log.back());",
            "\t\tfor(auto &mp: order) mp.clear();",
            "\t}",
            "\tint iter = 0;",
            "\tvector<int> was, cnt, popped;",
            "\tvector<vector<int>> top;",
            "\tvector<typename map<P, int, Compare>::iterator> it;",
            "\t// Amortized O(d * log(qn)) insert() and state() calls, and O(1) reverse_to() calls.",
            "\tint pop(int dpop){",
            "\t\tassert(0 <= dpop && dpop < d);",
            "\t\tassert(!stack.empty());",
            "\t\tcnt.assign(d, 0);",
            "\t\ttop.resize(d);",
            "\t\t++ iter;",
            "\t\tint qn = (int)stack.size(), ipop = -1;",
            "\t\tit.resize(d);",
            "\t\tfor(auto di = 0; di < d; ++ di) it[di] = order[di].begin();",
            "\t\tfor(auto pick = 1; ; ++ pick){",
            "\t\t\tassert(pick <= qn);",
            "\t\t\tint i = stack.back();",
            "\t\t\tstack.pop_back();",
            "\t\t\tpopped.push_back(i);",
            "\t\t\twas[i] = iter;",
            "\t\t\tfor(auto di = 0; di < d; ++ di) while(it[di] != order[di].end() && was[it[di]->second] == iter) ++ it[di], ++ cnt[di];",
            "\t\t\tif(*min_element(cnt.begin(), cnt.end()) < alpha * pick) continue;",
            "\t\t\tlog.resize((int)stack.size() + 1);",
            "\t\t\treverse_to(log.back());",
            "\t\t\t++ iter;",
            "\t\t\tfor(auto _di = 0; _di < d; ++ _di){",
            "\t\t\t\tint di = (dpop + _di) % d;",
            "\t\t\t\tit[di] = order[di].begin();",
            "\t\t\t\tfor(auto rep = cnt[di]; rep; -- rep, ++ it[di]){",
            "\t\t\t\t\tif(it[di] == order[di].end() || was[it[di]->second] == iter) continue;",
            "\t\t\t\t\tint i = it[di]->second;",
            "\t\t\t\t\ttop[di].push_back(i);",
            "\t\t\t\t\twas[i] = iter;",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t\tipop = order[dpop].begin()->second;",
            "\t\t\tfor(auto di = 0; di < d; ++ di) order[di].erase(priority[ipop][di]);",
            "\t\t\tassert(!top[dpop].empty());",
            "\t\t\ttop[dpop].erase(top[dpop].begin());",
            "\t\t\twhile(!popped.empty()){",
            "\t\t\t\tint i = popped.back();",
            "\t\t\t\tpopped.pop_back();",
            "\t\t\t\tif(was[i] == iter) continue;",
            "\t\t\t\tstack.push_back(i);",
            "\t\t\t\tinsert(i);",
            "\t\t\t\tlog.push_back(state());",
            "\t\t\t}",
            "\t\t\twhile(true){",
            "\t\t\t\tbool changed = false;",
            "\t\t\t\tfor(auto di = d - 1; di >= 0; -- di){",
            "\t\t\t\t\tif(top[di].empty()) continue;",
            "\t\t\t\t\tchanged = true;",
            "\t\t\t\t\tint i = top[di].back();",
            "\t\t\t\t\ttop[di].pop_back();",
            "\t\t\t\t\tstack.push_back(i);",
            "\t\t\t\t\tinsert(i);",
            "\t\t\t\t\tlog.push_back(state());",
            "\t\t\t\t}",
            "\t\t\t\tif(!changed) break;",
            "\t\t\t}",
            "\t\t\tbreak;",
            "\t\t}",
            "\t\tassert(~ipop);",
            "\t\treturn ipop;",
            "\t}",
            "\tvoid push(int i, const vector<P> &p){",
            "\t\tassert(0 <= i && i < n);",
            "\t\tassert((int)p.size() == d);",
            "\t\tpriority[i] = p;",
            "\t\tstack.push_back(i);",
            "\t\tfor(auto di = 0; di < d; ++ di) assert(order[di].insert({p[di], i}).second);",
            "\t\tinsert(i);",
            "\t\tlog.push_back(state());",
            "\t}",
            "\tfriend ostream &operator<<(ostream &out, const data_structure_multidimensional_priority_queue_like_deletion_enabler_online &enabler){",
            "\t\tout << \"{\";",
            "\t\tfor(auto i = 0; i < (int)enabler.stack.size(); ++ i){",
            "\t\t\tout << enabler.stack[i];",
            "\t\t\tif(i < (int)enabler.stack.size() - 1) out << \", \";",
            "\t\t}",
            "\t\treturn out << \"}\";",
            "\t}",
            "};"
        ],
        "description": "tranxuanbach"
    }
}