{
    "tranxuanbach": {
        "prefix": "find_maximal_cycles_in_tournament_graphs",
        "body": [
            "// Implementation of https://www.sciencedirect.com/science/article/pii/0166218X9290233Z/pdf?md5=85be43b019b58c7e267ce9c117371cd5&pid=1-s2.0-0166218X9290233Z-main.pdf",
            "// For u != v, adjm[u][v] = 1 and adjm[v][u] = 0 iff the arc u->v exists",
            "// Returns topologically sorted list of hamiltonian cycles for each strongly connected components",
            "// O(n^2)",
            "vector<vector<int>> find_maximal_cycles_in_tournament_graphs(const vector<vector<int>> &adjm){",
            "\tint n = (int)adjm.size();",
            "\tassert(n);",
            "\tfor(auto u = 0; u < n; ++ u) assert((int)adjm[u].size() == n);",
            "\tfor(auto u = 0; u < n; ++ u) for(auto v = u + 1; v < n; ++ v) assert((adjm[u][v] ^ adjm[v][u]) == 1 && 0 <= adjm[u][v] && adjm[u][v] <= 1);",
            "\tvector<int> path(n);",
            "\tiota(path.begin(), path.end(), 0);",
            "\tsort(path.begin(), path.end(), [&](int u, int v){ return adjm[u][v]; });",
            "\tauto solve = [&](auto self, vector<int> subset)->vector<vector<int>>{",
            "\t\tassert(!subset.empty());",
            "\t\tif((int)subset.size() == 1) return {subset};",
            "\t\tif((int)subset.size() == 2){",
            "\t\t\tif(adjm[subset[1]][subset[0]]) swap(subset[0], subset[1]);",
            "\t\t\treturn {{subset[0]}, {subset[1]}};",
            "\t\t}",
            "\t\tint n = (int)subset.size(), j = n - 1;",
            "\t\twhile(j >= 2 && adjm[subset[0]][subset[j]]) -- j;",
            "\t\tif(j < 2){",
            "\t\t\tint u = subset[0];",
            "\t\t\tsubset.erase(subset.begin());",
            "\t\t\tauto res = self(self, subset);",
            "\t\t\tres.insert(res.begin(), {u});",
            "\t\t\treturn move(res);",
            "\t\t}",
            "\t\tvector<int> cycle(subset.begin(), subset.begin() + j + 1);",
            "\t\tvector<int> path(subset.begin() + j + 1, subset.end());",
            "\t\twhile(true){",
            "\t\t\tif(path.empty()) return {cycle};",
            "\t\t\tint i = 0, j = 1;",
            "\t\t\twhile(i < (int)cycle.size() && adjm[cycle[i]][path[0]]) ++ i;",
            "\t\t\tif(i < (int)cycle.size()){",
            "\t\t\t\tcycle.insert(cycle.begin() + i, path[0]);",
            "\t\t\t\tpath.erase(path.begin());",
            "\t\t\t\tcontinue;",
            "\t\t\t}",
            "\t\t\tfor(; j < (int)path.size(); ++ j){",
            "\t\t\t\ti = 1;",
            "\t\t\t\twhile(i < (int)cycle.size() && adjm[cycle[i]][path[j]]) ++ i;",
            "\t\t\t\tif(i < (int)cycle.size()) break;",
            "\t\t\t}",
            "\t\t\tif(j < (int)path.size()){",
            "\t\t\t\tcycle.insert(cycle.begin() + i, path.begin(), path.begin() + j + 1);",
            "\t\t\t\tpath.erase(path.begin(), path.begin() + j + 1);",
            "\t\t\t\tcontinue;",
            "\t\t\t}",
            "\t\t\tauto res = self(self, path);",
            "\t\t\tres.insert(res.begin(), {cycle});",
            "\t\t\treturn move(res);",
            "\t\t}",
            "\t};",
            "\treturn solve(solve, path);",
            "}"
        ],
        "description": "tranxuanbach"
    }
}