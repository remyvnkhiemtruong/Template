{
    "tranxuanbach": {
        "prefix": "edge_coloring_vizing",
        "body": [
            "// Implementation of https://en.wikipedia.org/wiki/Misra_%26_Gries_edge_coloring_algorithm",
            "// Given a simple graph, returns an edge coloring using colors in [0, D] where D is the maximum degree",
            "// O(n * m)",
            "// Requires graph",
            "template<class T>",
            "vector<int> edge_coloring_vizing(const graph<T> &g){",
            "\tint n = g.n, m = (int)g.edge.size();",
            "\tvector<int> color(m, -1), missing(n);",
            "\tvector<vector<int>> has(n);",
            "\tauto get = [&](int u, int c)->int &{",
            "\t\tif((int)has[u].size() <= c) has[u].resize(c + 1, -1);",
            "\t\treturn has[u][c];",
            "\t};",
            "\tfor(auto i = 0; i < m; ++ i){",
            "\t\tif(g.ignore && g.ignore(i)) continue;",
            "\t\tauto [u, v, ignore] = g.edge[i];",
            "\t\tstatic vector<int> pseudo_forest;",
            "\t\tauto generate_forest = [&]()->int{",
            "\t\t\tpseudo_forest.clear();",
            "\t\t\tstatic vector<int> was;",
            "\t\t\tstatic int attempt = 0;",
            "\t\t\twas.resize(n);",
            "\t\t\t++ attempt;",
            "\t\t\tint it = i;",
            "\t\t\tfor(auto w = v; was[w] != attempt; w = g(u, it)){",
            "\t\t\t\tpseudo_forest.push_back(it);",
            "\t\t\t\twas[w] = attempt;",
            "\t\t\t\tit = get(u, missing[w]);",
            "\t\t\t\tif(!~it) return -1;",
            "\t\t\t}",
            "\t\t\treturn it;",
            "\t\t};",
            "\t\tif(auto it = generate_forest(); ~it){",
            "\t\t\tstatic vector<int> kempe_chain;",
            "\t\t\tint c = color[it], d = missing[u], w = u, e = c;",
            "\t\t\tfor(; ; e ^= c ^ d, w = g(w, it)){",
            "\t\t\t\tit = get(w, e);",
            "\t\t\t\tif(!~it) break;",
            "\t\t\t\tkempe_chain.push_back(it);",
            "\t\t\t}",
            "\t\t\tget(u, c) = get(w, e ^ c ^ d) = -1;",
            "\t\t\tfor(auto it: kempe_chain){",
            "\t\t\t\tauto [u, v, ignore] = g.edge[it];",
            "\t\t\t\tcolor[it] ^= c ^ d;",
            "\t\t\t\tget(u, color[it]) = get(v, color[it]) = it;",
            "\t\t\t}",
            "\t\t\tmissing[u] = missing[w] = 0;",
            "\t\t\twhile(~get(u, missing[u])) ++ missing[u];",
            "\t\t\twhile(~get(w, missing[w])) ++ missing[w];",
            "\t\t\tkempe_chain.clear();",
            "\t\t\tassert(!~generate_forest());",
            "\t\t}",
            "\t\tint c = missing[g(u, pseudo_forest.back())];",
            "\t\tfor(auto i = 0; i < (int)pseudo_forest.size() - 1; ++ i){",
            "\t\t\tint p = pseudo_forest[i], v = g(u, p), q = pseudo_forest[i + 1];",
            "\t\t\tget(g(u, q), color[q]) = -1;",
            "\t\t\tif(color[q] < missing[g(u, q)]) missing[g(u, q)] = color[q];",
            "\t\t\tcolor[p] = color[q];",
            "\t\t\tget(u, color[p]) = get(v, color[p]) = p;",
            "\t\t\twhile(~get(v, missing[v])) ++ missing[v];",
            "\t\t}",
            "\t\tcolor[pseudo_forest.back()] = c;",
            "\t\tv = g(u, pseudo_forest.back());",
            "\t\tget(u, c) = get(v, c) = pseudo_forest.back();",
            "\t\twhile(~get(u, missing[u])) ++ missing[u];",
            "\t\twhile(~get(v, missing[v])) ++ missing[v];",
            "\t\tpseudo_forest.clear();",
            "\t}",
            "\treturn color;",
            "}"
        ],
        "description": "tranxuanbach"
    }
}