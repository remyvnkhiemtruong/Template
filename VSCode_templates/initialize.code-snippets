{
    "tranxuanbach": {
        "prefix": "initialize",
        "body": [
            "from qiskit import QuantumCircuit, QuantumRegister",
            "from qiskit.circuit.library import XGate, ZGate, HGate, RYGate",
            "from math import sqrt, acos, pi",
            "",
            "def append_control_gate(qc: QuantumCircuit, gate, target_qubits, ctrl_state: int, controlled_qubits)->QuantumCircuit:",
            "\tfor target_qubit in target_qubits:",
            "\t\tif len(controlled_qubits) == 0:",
            "\t\t\t\tqc.append(gate, [target_qubit])",
            "\t\telse:",
            "\t\t\tqc.append(gate.control(len(controlled_qubits), ctrl_state = ctrl_state), controlled_qubits + [target_qubit])",
            "\treturn qc",
            "",
            "def solve(n: int, L: int)->QuantumCircuit:",
            "\tqc = QuantumCircuit(n)",
            "\tif L == (1 << n):",
            "\t\tfor i in range(n):",
            "\t\t\tqc.h(i)",
            "\t\treturn qc",
            "\tmask = (1 << n) - 1",
            "\tctrl_state = 0",
            "\tcontrolled_qubits = []",
            "\tfor bit in range(n - 1, -1, -1):",
            "\t\tif L >> bit & 1:",
            "\t\t\tleft, right = 1 << bit, L - (1 << bit)",
            "\t\t\ttheta = acos(sqrt(left) / sqrt(left + right)) * 2",
            "\t\t\tappend_control_gate(qc, RYGate(theta), [bit], ctrl_state, controlled_qubits)",
            "\t\t\tappend_control_gate(qc, HGate(), range(bit - 1, -1, -1), ctrl_state, controlled_qubits + [bit])",
            "\t\t\tL ^= 1 << bit",
            "\t\t\tctrl_state |= 1 << len(controlled_qubits)",
            "\t\tcontrolled_qubits += [bit]",
            "\treturn qc",
            "",
            "def _check(n: int, L: int, qc: QuantumCircuit)->bool:",
            "\teps = 1e-12",
            "\tmat = _qc_to_matrix(qc)",
            "\tfor i in range(1, L):",
            "\t\tif abs(mat[0][0] - mat[i][0]) > 1e-9:",
            "\t\t\treturn False",
            "\treturn abs(1 - sum(abs(mat[i][0]) * abs(mat[i][0]) for i in range(L))) <= 1e-3",
            "",
            "def _qc_to_matrix(qc: QuantumCircuit):",
            "\timport qiskit.quantum_info as qi",
            "\timport numpy as np",
            "\tnp.set_printoptions(linewidth=np.inf)",
            "\treturn np.array(qi.Operator(qc))",
            "",
            "def _simulate(qc: QuantumCircuit):",
            "\tfrom qiskit import Aer, execute",
            "\tsimulator = Aer.get_backend(\"statevector_simulator\")",
            "\tstatevector = execute(qc, simulator).result().get_statevector(qc)",
            "\tprint(statevector)",
            "",
            "def _print_circuit_info(qc: QuantumCircuit):",
            "\tmat = _qc_to_matrix(qc)",
            "\tprint(qc.draw(\"text\"))",
            "\tprint(mat)",
            "\tprint(\"depth = \", qc.depth())",
            "\t#_simulate(qc)",
            "",
            "def keep_running():",
            "\timport sys",
            "\tinput = sys.stdin.readline",
            "\twhile True:",
            "\t\tn, L = map(int,input().split())",
            "\t\tqc = solve(n, L)",
            "\t\t_print_circuit_info(qc)",
            "",
            "def stress_test():",
            "\tfor n in range(1, 11):",
            "\t\tfor L in range(1, 1 << n | 1):",
            "\t\t\tqc = solve(n, L)",
            "\t\t\tif not _check(n, L, qc):",
            "\t\t\t\tprint(f\"WA, n = {n}, L = {L}\")",
            "\t\t\t\t_print_circuit_info(qc)",
            "\t\t\t\texit(0)",
            "\t\t\tprint(f\"AC, n = {n}, L = {L}\")",
            "\tprint(\"AC\")",
            "",
            "#keep_running()",
            "stress_test()"
        ],
        "description": "tranxuanbach"
    }
}