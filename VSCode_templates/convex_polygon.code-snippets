{
    "tranxuanbach": {
        "prefix": "convex_polygon",
        "body": [
            "// Requires point",
            "template<class T>",
            "struct convex_polygon{",
            "\tvector<point<T>> data;",
            "\t// Construct the convex polygon as the convex hull of a",
            "\t// O(n * log(n)) if is_sorted = false, O(n) otherwise",
            "\tconvex_polygon(vector<point<T>> a = {}, bool is_sorted = false){",
            "\t\tif(!is_sorted) sort(a.begin(), a.end()), a.erase(unique(a.begin(), a.end()), a.end());;",
            "\t\tvector<point<T>> upper;",
            "#define ADDP(C, cmp) while((int)C.size() > 1 && doubled_signed_area(C[(int)C.size() - 2], p, C.back()) cmp 0) C.pop_back(); C.push_back(p);",
            "\t\tfor(auto &p: a){",
            "\t\t\tADDP(data, >=)",
            "\t\t\tADDP(upper, <=)",
            "\t\t}",
            "#undef ADDP",
            "\t\tif((int)upper.size() >= 3) data.insert(data.end(), ++ upper.rbegin(), -- upper.rend());",
            "\t}",
            "\tfriend ostream &operator<<(ostream &out, const convex_polygon &c){",
            "\t\tout << \"{\";",
            "\t\tfor(auto p: c.data) out << p << \", \";",
            "\t\treturn out << (c.empty() ? \"\" : \"\\b\\b\") << \"}\";",
            "\t}",
            "\tint size() const{",
            "\t\treturn (int)data.size();",
            "\t}",
            "\tbool empty() const{",
            "\t\treturn data.empty();",
            "\t}",
            "\tpoint<T> &operator[](int i){",
            "\t\treturn data[i];",
            "\t}",
            "\tconst point<T> &operator[](int i) const{",
            "\t\treturn data[i];",
            "\t}",
            "\tpoint<T> &front(){",
            "\t\treturn data.front();",
            "\t}",
            "\tconst point<T> &front() const{",
            "\t\treturn data.front();",
            "\t}",
            "\tpoint<T> &back(){",
            "\t\treturn data.back();",
            "\t}",
            "\tconst point<T> &back() const{",
            "\t\treturn data.back();",
            "\t}",
            "\t// Returns the sorted list of points",
            "\t// O(n)",
            "\tvector<point<T>> linearize() const{",
            "\t\tif(data.empty()) return {};",
            "\t\tauto res = data;",
            "\t\tint p = max_element(res.begin(), res.end()) - res.begin();",
            "\t\treverse(res.begin() + p + 1, res.end());",
            "\t\tinplace_merge(res.begin(), res.begin() + p + 1, res.end());",
            "\t\treturn res;",
            "\t}",
            "\t// Merge two convex polygons",
            "\t// O(n + m)",
            "\tconvex_polygon operator^(const convex_polygon &c) const{",
            "\t\tvector<point<T>> A = linearize(), B = c.linearize(), C((int)A.size() + (int)B.size());",
            "\t\tmerge(A.begin(), A.end(), B.begin(), B.end(), C.begin());",
            "\t\treturn {C, true};",
            "\t}",
            "\tconvex_polygon &operator^=(const convex_polygon &c){",
            "\t\treturn *this = *this ^ c;",
            "\t}",
            "\tconvex_polygon &operator+=(const point<T> &p){",
            "\t\tfor(auto &q: data) q += p;",
            "\t\treturn *this;",
            "\t}",
            "\tconvex_polygon operator+(const point<T> &p) const{",
            "\t\treturn convex_polygon(*this) += p;",
            "\t}",
            "\tfriend convex_polygon operator+(const point<T> &p, const convex_polygon &c){",
            "\t\treturn c + p;",
            "\t}",
            "\t// O(n)",
            "\tvector<point<T>> boundary() const{",
            "\t\tassert((int)size() >= 2);",
            "\t\tauto res = data;",
            "\t\tres.push_back(res[0]);",
            "\t\tfor(auto i = (int)res.size() - 1; i > 0; -- i) res[i] -= res[i - 1];",
            "\t\treturn res;",
            "\t}",
            "\t// Minkowski addition",
            "\t// O(n + m)",
            "\tconvex_polygon operator+(const convex_polygon &c) const{",
            "\t\tif(empty() || c.empty()) return {};",
            "\t\tif((int)size() == 1) return c + data[0];",
            "\t\tif((int)c.size() == 1) return *this + c[0];",
            "\t\tauto A = boundary(), B = c.boundary();",
            "\t\tconvex_polygon res;",
            "\t\tres.data.resize(A.size() + B.size() - 1);",
            "\t\tres[0] = A[0] + B[0];",
            "\t\tmerge(A.begin() + 1, A.end(), B.begin() + 1, B.end(), res.data.begin() + 1, [&](auto p, auto q){",
            "\t\t\tbool sign_p = p.x < 0 || p.x == 0 && p.y < 0;",
            "\t\t\tbool sign_q = q.x < 0 || q.x == 0 && q.y < 0;",
            "\t\t\tif(sign_p != sign_q) return sign_p < sign_q;",
            "\t\t\telse return (p ^ q) > 0;",
            "\t\t});",
            "\t\tfor(auto i = 1; i < (int)res.size(); ++ i) res[i] += res[i - 1];",
            "\t\tassert(res.front() == res.back());",
            "\t\tint size = 1;",
            "\t\tfor(auto i = 1; i < (int)res.size() - 1; ){",
            "\t\t\twhile(i < (int)res.size() - 1 && colinear(res[i - 1], res[i], res[i + 1]) && (res[i] - res[i - 1]) * (res[i + 1] - res[i]) > 0) ++ i;",
            "\t\t\tif(i < (int)res.size() - 1) res[size ++] = res[i ++];",
            "\t\t}",
            "\t\tres.data.resize(size);",
            "\t\treturn res;",
            "\t}",
            "\tconvex_polygon &operator+=(const convex_polygon &c){",
            "\t\treturn *this = *this + c;",
            "\t}",
            "\t// O(n)",
            "\tconvex_polygon operator-() const{",
            "\t\tconvex_polygon res = *this;",
            "\t\tfor(auto &p: res.data) p = -p;",
            "\t\trotate(res.data.begin(), min_element(res.data.begin(), res.data.end()), res.data.end());",
            "\t\treturn res;",
            "\t}",
            "\t// O(n)",
            "\tconvex_polygon operator-(const convex_polygon &c) const{",
            "\t\treturn *this + -c;",
            "\t}",
            "\tconvex_polygon &operator-=(const convex_polygon &c) const{",
            "\t\treturn *this = *this + -c;",
            "\t}",
            "};"
        ],
        "description": "tranxuanbach"
    }
}