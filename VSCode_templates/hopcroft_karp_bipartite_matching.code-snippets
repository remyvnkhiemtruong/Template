{
    "tranxuanbach": {
        "prefix": "hopcroft_karp",
        "body": [
            "struct hopcroft_karp{",
            "\tint n, m, flow = 0;",
            "\tvector<vector<int>> adj;",
            "\tvector<int> pu, pv; // u is matched with pu[u] and v with pv[v], -1 if no match",
            "\thopcroft_karp(int n, int m): n(n), m(m), adj(n), pu(n, -1), pv(m, -1), layer(n){ }",
            "\tint insert(int from, int to){",
            "\t\tadj[from].push_back(to);",
            "\t\treturn (int)adj[from].size() - 1;",
            "\t}",
            "\tvector<int> layer;",
            "\tvoid bfs(){",
            "\t\tqueue<int> q;",
            "\t\tfor(int u = 0; u < n; ++ u){",
            "\t\t\tif(!~pu[u]) q.push(u), layer[u] = 0;",
            "\t\t\telse layer[u] = -1;",
            "\t\t}",
            "\t\twhile(!q.empty()){",
            "\t\t\tint u = q.front(); q.pop();",
            "\t\t\tfor(auto v: adj[u]) if(~pv[v] && !~layer[pv[v]]){",
            "\t\t\t\tlayer[pv[v]] = layer[u] + 1;",
            "\t\t\t\tq.push(pv[v]);",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "\tbool dfs(int u){",
            "\t\tfor(auto v: adj[u]) if(!~pv[v]){",
            "\t\t\tpu[u] = v, pv[v] = u;",
            "\t\t\treturn true;",
            "\t\t}",
            "\t\tfor(auto v: adj[u]) if(layer[pv[v]] == layer[u] + 1 && dfs(pv[v])){",
            "\t\t\tpu[u] = v, pv[v] = u;",
            "\t\t\treturn true;",
            "\t\t}",
            "\t\treturn false;",
            "\t}",
            "\tint solve(){ // O( sqrt(V) * E )",
            "\t\twhile(true){",
            "\t\t\tbfs();",
            "\t\t\tint augment = 0;",
            "\t\t\tfor(int u = 0; u < n; ++ u) if(!~pu[u]) augment += dfs(u);",
            "\t\t\tif(!augment) break;",
            "\t\t\tflow += augment;",
            "\t\t}",
            "\t\treturn flow;",
            "\t}",
            "\tpair<vector<int>, vector<int>> minimum_vertex_cover(){",
            "\t\tsolve();",
            "\t\tvector<int> L, R;",
            "\t\tfor(int u = 0; u < n; ++ u){",
            "\t\t\tif(!~layer[u]) L.push_back(u);",
            "\t\t\telse if(~pu[u]) R.push_back(pu[u]);",
            "\t\t}",
            "\t\treturn {L, R};",
            "\t}",
            "};"
        ],
        "description": "tranxuanbach"
    }
}