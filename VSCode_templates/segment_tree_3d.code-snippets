{
    "tranxuanbach": {
        "prefix": "segment_tree_3d",
        "body": [
            "template<class T, class F>",
            "struct segment_tree_3d{",
            "\tint n, m, l;",
            "\tvector<vector<vector<T>>> data;",
            "\tF TT; // commutative monoid operation",
            "\tT T_id; // commutative monoid identity",
            "\t// O(n * m * l)",
            "\tsegment_tree_3d(int n, int m, int l, F TT, T T_id): n(n), m(m), l(l), TT(TT), T_id(T_id), data(n << 1, vector<vector<T>>(m << 1, vector<T>(l << 1, T_id))){ }",
            "\t// O(n * m * l)",
            "\tsegment_tree_3d(int n, int m, int l, T x, F TT, T T_id): segment_tree_3d(vector<vector<vector<T>>>(n, vector<vector<T>>(m, vector<T>(l, x)))){ }",
            "\t// O(n * m * l)",
            "\tsegment_tree_3d(const vector<vector<vector<T>>> &a, F TT, T T_id): n((int)a.size()), m((int)a[0].size()), l((int)a[0][0].size()), TT(TT), T_id(T_id), data(n << 1, vector<vector<T>>(m << 1, vector<T>(l << 1, T_id))){",
            "\t\tfor(auto i = 0; i < n; ++ i) for(auto j = 0; j < m; ++ j) for(auto k = 0; k < l; ++ k) data[i + n][j + m][k + l] = a[i][j][k];",
            "\t\tfor(auto i = n - 1; i > 0; -- i) for(auto j = 0; j < m; ++ j) for(auto k = 0; k < l; ++ k) data[i][j + m][k + l] = TT(data[i << 1][j + m][k + l], data[i << 1 | 1][j + m][k + l]);",
            "\t\tfor(auto i = 1; i < n << 1; ++ i) for(auto j = m - 1; j > 0; -- j) for(auto k = 0; k < l; ++ k) data[i][j][k + l] = TT(data[i][j << 1][k + l], data[i][j << 1 | 1][k + l]);",
            "\t\tfor(auto i = 1; i < n << 1; ++ i) for(auto j = 1; j < m << 1; ++ j) for(auto k = l - 1; k > 0; -- k) data[i][j][k] = TT(data[i][j][k << 1], data[i][j][k << 1 | 1]);",
            "\t}",
            "\t// a[p][q][r] := x",
            "\t// O(log n * log m * log l)",
            "\tvoid set(int p, int q, int r, T x){",
            "\t\tdata[p += n][q += m][r += l] = x;",
            "\t\tfor(auto k = r; k >>= 1; ) data[p][q][k] = TT(data[p][q][k << 1], data[p][q][k << 1 | 1]);",
            "\t\tfor(auto j = q; j >>= 1; ){",
            "\t\t\tdata[p][j][r] = TT(data[p][j << 1][r], data[p][j << 1 | 1][r]);",
            "\t\t\tfor(auto k = r; k >>= 1; ) data[p][j][k] = TT(data[p][j][k << 1], data[p][j][k << 1 | 1]);",
            "\t\t}",
            "\t\tfor(auto i = p; i >>= 1; ){",
            "\t\t\tdata[i][q][r] = TT(data[i << 1][q][r], data[i << 1 | 1][q][r]);",
            "\t\t\tfor(auto k = r; k >>= 1; ) data[i][q][k] = TT(data[i][q][k << 1], data[i][q][k << 1 | 1]);",
            "\t\t\tfor(auto j = q; j >>= 1; ){",
            "\t\t\t\tdata[i][j][r] = TT(data[i][j << 1][r], data[i][j << 1 | 1][r]);",
            "\t\t\t\tfor(auto k = r; k >>= 1; ) data[i][j][k] = TT(data[i][j][k << 1], data[i][j][k << 1 | 1]);",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "\t// Returns a[p][q][r]",
            "\t// O(1)",
            "\tT query(int p, int q, int r){",
            "\t\treturn data[p + n][q + m][r + l];",
            "\t}",
            "\t// Returns the sum of a[i][j][k] on [xl, xr) X [yl, yr) X [zl, zr)",
            "\t// O(log n * log m * log l)",
            "\tT query(int xl, int xr, int yl, int yr, int zl, int zr){",
            "\t\tif(xl >= xr || yl >= yr || zl >= zr) return T_id;",
            "\t\tT res = T_id;",
            "\t\txl += n, xr += n, yl += m, yr += m, zl += l, zr += l;",
            "\t\tfor(auto il = xl, ir = xr; il < ir; il >>= 1, ir >>= 1){",
            "\t\t\tif(il & 1){",
            "\t\t\t\tfor(auto jl = yl, jr = yr; jl < jr; jl >>= 1, jr >>= 1){",
            "\t\t\t\t\tif(jl & 1){",
            "\t\t\t\t\t\tfor(auto kl = zl, kr = zr; kl < kr; kl >>= 1, kr >>= 1){",
            "\t\t\t\t\t\t\tif(kl & 1) res = TT(res, data[il][jl][kl ++]);",
            "\t\t\t\t\t\t\tif(kr & 1) res = TT(res, data[il][jl][-- kr]);",
            "\t\t\t\t\t\t}",
            "\t\t\t\t\t\t++ jl;",
            "\t\t\t\t\t}",
            "\t\t\t\t\tif(jr & 1){",
            "\t\t\t\t\t\t-- jr;",
            "\t\t\t\t\t\tfor(auto kl = zl, kr = zr; kl < kr; kl >>= 1, kr >>= 1){",
            "\t\t\t\t\t\t\tif(kl & 1) res = TT(res, data[il][jr][kl ++]);",
            "\t\t\t\t\t\t\tif(kr & 1) res = TT(res, data[il][jr][-- kr]);",
            "\t\t\t\t\t\t}",
            "\t\t\t\t\t}",
            "\t\t\t\t}",
            "\t\t\t\t++ il;",
            "\t\t\t}",
            "\t\t\tif(ir & 1){",
            "\t\t\t\t-- ir;",
            "\t\t\t\tfor(auto jl = yl, jr = yr; jl < jr; jl >>= 1, jr >>= 1){",
            "\t\t\t\t\tif(jl & 1){",
            "\t\t\t\t\t\tfor(auto kl = zl, kr = zr; kl < kr; kl >>= 1, kr >>= 1){",
            "\t\t\t\t\t\t\tif(kl & 1) res = TT(res, data[ir][jl][kl ++]);",
            "\t\t\t\t\t\t\tif(kr & 1) res = TT(res, data[ir][jl][-- kr]);",
            "\t\t\t\t\t\t}",
            "\t\t\t\t\t\t++ jl;",
            "\t\t\t\t\t}",
            "\t\t\t\t\tif(jr & 1){",
            "\t\t\t\t\t\t-- jr;",
            "\t\t\t\t\t\tfor(auto kl = zl, kr = zr; kl < kr; kl >>= 1, kr >>= 1){",
            "\t\t\t\t\t\t\tif(kl & 1) res = TT(res, data[ir][jr][kl ++]);",
            "\t\t\t\t\t\t\tif(kr & 1) res = TT(res, data[ir][jr][-- kr]);",
            "\t\t\t\t\t\t}",
            "\t\t\t\t\t}",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t}",
            "\t\treturn res;",
            "\t}",
            "\ttemplate<class output_stream>",
            "\tfriend output_stream &operator<<(output_stream &out, const segment_tree_3d<T, F> &seg){",
            "\t\tfor(auto i = 0; i < seg.n; ++ i){",
            "\t\t\tout << \"\\n[\";",
            "\t\t\tfor(auto j = 0; j < seg.m; ++ j){",
            "\t\t\t\tfor(auto k = 0; k < seg.l; ++ k){",
            "\t\t\t\t\tout << seg.query(i, j, k);",
            "\t\t\t\t\tif(k != seg.l - 1) out << \", \";",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t\tout << \"]\";",
            "\t\t}",
            "\t\treturn out << \"\\n\";",
            "\t}",
            "};"
        ],
        "description": "tranxuanbach"
    }
}