{
    "tranxuanbach": {
        "prefix": "modular_unfixed",
        "body": [
            "template<int id, class data_t, class wider_data_t>",
            "struct modular_unfixed_base{",
            "#define IS_INTEGRAL(T) (is_integral_v<T> || is_same_v<T, __int128_t> || is_same_v<T, __uint128_t>)",
            "#define IS_UNSIGNED(T) (is_unsigned_v<T> || is_same_v<T, __uint128_t>)",
            "\tstatic_assert(IS_UNSIGNED(data_t) && IS_UNSIGNED(wider_data_t));",
            "\tstatic constexpr bool VARIATE_MOD_FLAG = true;",
            "\tstatic data_t _mod;",
            "\tstatic wider_data_t _inverse_mod;",
            "\tstatic data_t &mod(){",
            "\t\treturn _mod;",
            "\t}",
            "\tstatic void precalc_barrett(){",
            "\t\t_inverse_mod = (wider_data_t)-1 / _mod + 1;",
            "\t}",
            "\tstatic void setup(data_t mod = 0){",
            "\t\tif(!mod) cin >> mod;",
            "\t\t_mod = mod;",
            "\t\tassert(_mod >= 1);",
            "\t\tprecalc_barrett();",
            "\t}",
            "\ttemplate<class T>",
            "\tstatic vector<modular_unfixed_base> precalc_power(T base, int SZ){",
            "\t\tvector<modular_unfixed_base> res(SZ + 1, 1);",
            "\t\tfor(auto i = 1; i <= SZ; ++ i) res[i] = res[i - 1] * base;",
            "\t\treturn res;",
            "\t}",
            "\tstatic vector<modular_unfixed_base> _INV;",
            "\tstatic void precalc_inverse(int SZ){",
            "\t\tif(_INV.empty()) _INV.assign(2, 1);",
            "\t\tfor(auto x = _INV.size(); x <= SZ; ++ x) _INV.push_back(_mod / x * -_INV[_mod % x]);",
            "\t}",
            "\t// _mod must be a prime",
            "\tstatic modular_unfixed_base _primitive_root;",
            "\tstatic modular_unfixed_base primitive_root(){",
            "\t\tif(_primitive_root) return _primitive_root;",
            "\t\tif(_mod == 2) return _primitive_root = 1;",
            "\t\tif(_mod == 998244353) return _primitive_root = 3;",
            "\t\tdata_t divs[20] = {};",
            "\t\tdivs[0] = 2;",
            "\t\tint cnt = 1;",
            "\t\tdata_t x = (_mod - 1) / 2;",
            "\t\twhile(x % 2 == 0) x /= 2;",
            "\t\tfor(auto i = 3; 1LL * i * i <= x; i += 2){",
            "\t\t\tif(x % i == 0){",
            "\t\t\t\tdivs[cnt ++] = i;",
            "\t\t\t\twhile(x % i == 0) x /= i;",
            "\t\t\t}",
            "\t\t}",
            "\t\tif(x > 1) divs[cnt ++] = x;",
            "\t\tfor(auto g = 2; ; ++ g){",
            "\t\t\tbool ok = true;",
            "\t\t\tfor(auto i = 0; i < cnt; ++ i){",
            "\t\t\t\tif(modular_unfixed_base(g).power((_mod - 1) / divs[i]) == 1){",
            "\t\t\t\t\tok = false;",
            "\t\t\t\t\tbreak;",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t\tif(ok) return _primitive_root = g;",
            "\t\t}",
            "\t}",
            "\tconstexpr modular_unfixed_base(){ }",
            "\tmodular_unfixed_base(const double &x){ data = _normalize(llround(x)); }",
            "\tmodular_unfixed_base(const long double &x){ data = _normalize(llround(x)); }",
            "\ttemplate<class T, typename enable_if<IS_INTEGRAL(T)>::type* = nullptr> modular_unfixed_base(const T &x){ data = _normalize(x); }",
            "\ttemplate<class T, typename enable_if<IS_INTEGRAL(T)>::type* = nullptr> static data_t _normalize(const T &x){",
            "\t\tif(_mod == 1) return 0;",
            "\t\tif constexpr(is_same_v<data_t, unsigned int>){",
            "\t\t\tassert(_inverse_mod);",
            "\t\t\tint sign = x >= 0 ? 1 : -1;",
            "\t\t\tdata_t v = _mod <= sign * x ? sign * x - ((__uint128_t)(sign * x) * _inverse_mod >> 64) * _mod : sign * x;",
            "\t\t\tif(v >= _mod) v += _mod;",
            "\t\t\tif(sign == -1 && v) v = _mod - v;",
            "\t\t\treturn v;",
            "\t\t}",
            "\t\telse{",
            "\t\t\tint sign = x >= 0 ? 1 : -1;",
            "\t\t\tdata_t v =  _mod <= sign * x ? sign * x % _mod : sign * x;",
            "\t\t\tif(sign == -1 && v) v = _mod - v;",
            "\t\t\treturn v;",
            "\t\t}",
            "\t}",
            "\tconst data_t &operator()() const{ return data; }",
            "\ttemplate<class T, typename enable_if<IS_INTEGRAL(T)>::type* = nullptr> operator T() const{ return data; }",
            "\tmodular_unfixed_base &operator+=(const modular_unfixed_base &otr){ if((data += otr.data) >= _mod) data -= _mod; return *this; }",
            "\tmodular_unfixed_base &operator-=(const modular_unfixed_base &otr){ if((data += _mod - otr.data) >= _mod) data -= _mod; return *this; }",
            "\ttemplate<class T, typename enable_if<IS_INTEGRAL(T)>::type* = nullptr> modular_unfixed_base &operator+=(const T &otr){ return *this += modular_unfixed_base(otr); }",
            "\ttemplate<class T, typename enable_if<IS_INTEGRAL(T)>::type* = nullptr> modular_unfixed_base &operator-=(const T &otr){ return *this -= modular_unfixed_base(otr); }",
            "\tmodular_unfixed_base &operator++(){ return *this += 1; }",
            "\tmodular_unfixed_base &operator--(){ return *this += _mod - 1; }",
            "\tmodular_unfixed_base operator++(int){ modular_unfixed_base result(*this); *this += 1; return result; }",
            "\tmodular_unfixed_base operator--(int){ modular_unfixed_base result(*this); *this += _mod - 1; return result; }",
            "\tmodular_unfixed_base operator-() const{ return modular_unfixed_base(_mod - data); }",
            "\tmodular_unfixed_base &operator*=(const modular_unfixed_base &rhs){",
            "\t\tif constexpr(is_same_v<data_t, unsigned long long>){",
            "\t\t\tlong long res = data * rhs.data - _mod * (unsigned long long)(1.L / _mod * data * rhs.data);",
            "\t\t\tdata = res + _mod * (res < 0) - _mod * (res >= (long long)_mod);",
            "\t\t}",
            "\t\telse data = _normalize((wider_data_t)data * rhs.data);",
            "\t\treturn *this;",
            "\t}",
            "\ttemplate<class T, typename enable_if<IS_INTEGRAL(T)>::type* = nullptr>",
            "\tmodular_unfixed_base &inplace_power(T e){",
            "\t\tif(e == 0) return *this = 1;",
            "\t\tif(data == 0) return *this = {};",
            "\t\tif(data == 1 || e == 1) return *this;",
            "\t\tif(data == mod() - 1) return e % 2 ? *this : *this = -*this;",
            "\t\tif(e < 0) *this = 1 / *this, e = -e;",
            "\t\tif(e == 1) return *this;",
            "\t\tmodular_unfixed_base res = 1;",
            "\t\tfor(; e; *this *= *this, e >>= 1) if(e & 1) res *= *this;",
            "\t\treturn *this = res;",
            "\t}",
            "\ttemplate<class T, typename enable_if<IS_INTEGRAL(T)>::type* = nullptr>",
            "\tmodular_unfixed_base power(T e) const{",
            "\t\treturn modular_unfixed_base(*this).inplace_power(e);",
            "\t}",
            "\tmodular_unfixed_base &operator/=(const modular_unfixed_base &otr){",
            "\t\tmake_signed_t<data_t> a = otr.data, m = _mod, u = 0, v = 1;",
            "\t\tif(a < _INV.size()) return *this *= _INV[a];",
            "\t\twhile(a){",
            "\t\t\tmake_signed_t<data_t> t = m / a;",
            "\t\t\tm -= t * a; swap(a, m);",
            "\t\t\tu -= t * v; swap(u, v);",
            "\t\t}",
            "\t\tassert(m == 1);",
            "\t\treturn *this *= u;",
            "\t}",
            "#define ARITHMETIC_OP(op, apply_op)\\",
            "modular_unfixed_base operator op(const modular_unfixed_base &x) const{ return modular_unfixed_base(*this) apply_op x; }\\",
            "template<class T, typename enable_if<IS_INTEGRAL(T)>::type* = nullptr>\\",
            "modular_unfixed_base operator op(const T &x) const{ return modular_unfixed_base(*this) apply_op modular_unfixed_base(x); }\\",
            "template<class T, typename enable_if<IS_INTEGRAL(T)>::type* = nullptr>\\",
            "friend modular_unfixed_base operator op(const T &x, const modular_unfixed_base &y){ return modular_unfixed_base(x) apply_op y; }",
            "\tARITHMETIC_OP(+, +=) ARITHMETIC_OP(-, -=) ARITHMETIC_OP(*, *=) ARITHMETIC_OP(/, /=)",
            "#undef ARITHMETIC_OP",
            "#define COMPARE_OP(op)\\",
            "bool operator op(const modular_unfixed_base &x) const{ return data op x.data; }\\",
            "template<class T, typename enable_if<IS_INTEGRAL(T)>::type* = nullptr>\\",
            "bool operator op(const T &x) const{ return data op modular_unfixed_base(x).data; }\\",
            "template<class T, typename enable_if<IS_INTEGRAL(T)>::type* = nullptr>\\",
            "friend bool operator op(const T &x, const modular_unfixed_base &y){ return modular_unfixed_base(x).data op y.data; }",
            "\tCOMPARE_OP(==) COMPARE_OP(!=) COMPARE_OP(<) COMPARE_OP(<=) COMPARE_OP(>) COMPARE_OP(>=)",
            "#undef COMPARE_OP",
            "\tfriend istream &operator>>(istream &in, modular_unfixed_base &number){",
            "\t\tlong long x;",
            "\t\tin >> x;",
            "\t\tnumber.data = modular_unfixed_base::_normalize(x);",
            "\t\treturn in;",
            "\t}",
            "//#define _SHOW_FRACTION",
            "\tfriend ostream &operator<<(ostream &out, const modular_unfixed_base &number){",
            "\t\tout << number.data;",
            "\t#if defined(LOCAL) && defined(_SHOW_FRACTION)",
            "\t\tcerr << \"(\";",
            "\t\tfor(auto d = 1; ; ++ d){",
            "\t\t\tif((number * d).data <= 1000000){",
            "\t\t\t\tcerr << (number * d).data;",
            "\t\t\t\tif(d != 1) cerr << \"/\" << d;",
            "\t\t\t\tbreak;",
            "\t\t\t}",
            "\t\t\telse if((-number * d).data <= 1000000){",
            "\t\t\t\tcerr << \"-\" << (-number * d).data;",
            "\t\t\t\tif(d != 1) cerr << \"/\" << d;",
            "\t\t\t\tbreak;",
            "\t\t\t}",
            "\t\t}",
            "\t\tcerr << \")\";",
            "\t#endif",
            "\t\treturn out;",
            "\t}",
            "\tdata_t data = 0;",
            "#undef _SHOW_FRACTION",
            "#undef IS_INTEGRAL",
            "#undef IS_UNSIGNED",
            "};",
            "template<int id, class data_t, class wider_data_t> data_t modular_unfixed_base<id, data_t, wider_data_t>::_mod;",
            "template<int id, class data_t, class wider_data_t> wider_data_t modular_unfixed_base<id, data_t, wider_data_t>::_inverse_mod;",
            "template<int id, class data_t, class wider_data_t> vector<modular_unfixed_base<id, data_t, wider_data_t>> modular_unfixed_base<id, data_t, wider_data_t>::_INV;",
            "template<int id, class data_t, class wider_data_t> modular_unfixed_base<id, data_t, wider_data_t> modular_unfixed_base<id, data_t, wider_data_t>::_primitive_root;",
            "",
            "using modular = modular_unfixed_base<0, unsigned int, unsigned long long>;",
            "// using modular = modular_unfixed_base<0, unsigned long long, __uint128_t>;"
        ],
        "description": "tranxuanbach"
    }
}