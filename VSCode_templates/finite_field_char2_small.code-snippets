{
    "tranxuanbach": {
        "prefix": "finite_field_char2_small",
        "body": [
            "// Unique finite field of size 2^D",
            "template<size_t D, class T, class T_large>",
            "struct finite_field_char2_small_base{",
            "#define IS_INTEGRAL(T) (is_integral_v<T> || is_same_v<T, __int128_t> || is_same_v<T, __uint128_t>)",
            "#define IS_UNSIGNED(T) (is_unsigned_v<T> || is_same_v<T, __uint128_t>)",
            "\tstatic_assert(IS_UNSIGNED(T) && IS_UNSIGNED(T_large));",
            "\tstatic_assert(1 <= D && D <= sizeof(T) * 8);",
            "\tstatic_assert(2 * D <= sizeof(T_large) * 8);",
            "\tstatic constexpr size_t characteristic = 2;",
            "\tstatic constexpr size_t dimension = D;",
            "\tstatic constexpr T_large size = T_large(1) << D;",
            "\tstatic constexpr unsigned int irreducible[] = {0, 0, 3, 3, 3, 5, 3, 3, 27, 3, 9, 5, 9, 27, 33, 3, 43, 9, 9, 39, 9, 5, 3, 33, 27, 9, 27, 39, 3, 5, 3, 9, 141, 75, 27, 5, 53, 63, 99, 17, 57, 9, 39, 89, 33, 27, 3, 33, 45, 113, 29, 75, 9, 71, 125, 71, 149, 17, 99, 123, 3, 39, 105, 3, 27, 27, 9, 39, 163, 101, 43};",
            "\tstatic constexpr T _full_mask = size - 1;",
            "\tstatic finite_field_char2_small_base _primitive_root;",
            "\tstatic finite_field_char2_small_base primitive_root(){",
            "\t\tif(_primitive_root) return _primitive_root;",
            "\t\tif(D == 1) return _primitive_root = 1;",
            "\t\tT divs[20] = {};",
            "\t\tint cnt = 0;",
            "\t\tT x = _full_mask;",
            "\t\tfor(auto i = 3; 1LL * i * i <= x; i += 2) if(x % i == 0){",
            "\t\t\tdivs[cnt ++] = i;",
            "\t\t\twhile(x % i == 0) x /= i;",
            "\t\t}",
            "\t\tif(x > 1) divs[cnt ++] = x;",
            "\t\tfor(auto g = 2; ; ++ g){",
            "\t\t\tbool ok = true;",
            "\t\t\tfor(auto i = 0; i < cnt; ++ i) if(finite_field_char2_small_base{g}.power(_full_mask / divs[i]) == 1){",
            "\t\t\t\tok = false;",
            "\t\t\t\tbreak;",
            "\t\t\t}",
            "\t\t\tif(ok) return _primitive_root = g;",
            "\t\t}",
            "\t}",
            "\tstatic finite_field_char2_small_base generate(auto &&rng){",
            "\t\tT res = 0;",
            "\t\tfor(auto rem = D; rem; ){",
            "\t\t\tauto w = min<size_t>(32, rem);",
            "\t\t\tres = res << w | rng() & _full_mask;",
            "\t\t\trem -= w;",
            "\t\t}",
            "\t\treturn res;",
            "\t}",
            "\tfinite_field_char2_small_base(){ }",
            "\ttemplate<class U, typename enable_if<IS_INTEGRAL(U)>::type* = nullptr>",
            "\tfinite_field_char2_small_base(U x): data(x & _full_mask){ }",
            "\ttemplate<class U, typename enable_if<IS_INTEGRAL(U)>::type* = nullptr> operator U() const{ return data; }",
            "\tfinite_field_char2_small_base &operator+=(const finite_field_char2_small_base &otr){ data ^= otr.data; return *this; }",
            "\tfinite_field_char2_small_base &operator-=(const finite_field_char2_small_base &otr){ data ^= otr.data; return *this; }",
            "\ttemplate<class U, typename enable_if<IS_INTEGRAL(U)>::type* = nullptr> finite_field_char2_small_base &operator+=(const U &otr){ return *this += finite_field_char2_small_base(otr); }",
            "\ttemplate<class U, typename enable_if<IS_INTEGRAL(U)>::type* = nullptr> finite_field_char2_small_base &operator-=(const U &otr){ return *this -= finite_field_char2_small_base(otr); }",
            "\tfinite_field_char2_small_base &operator++(){ data ^= 1; return *this; }",
            "\tfinite_field_char2_small_base &operator--(){ data ^= 1; return *this; }",
            "\tfinite_field_char2_small_base operator-() const{ return *this; }",
            "\tfinite_field_char2_small_base &operator*=(const finite_field_char2_small_base &rhs){",
            "\t\tT_large res = 0;",
            "\t\tfor(auto i = 0; i < D; ++ i) if(rhs.data >> i & 1) res ^= (T_large)data << i;",
            "\t\tfor(auto i = 2 * D - 1; i >= D; -- i) if(res >> i & 1) res ^= (T_large)irreducible[D] << i - D;",
            "\t\tdata = res & _full_mask;",
            "\t\treturn *this;",
            "\t}",
            "\ttemplate<class U, typename enable_if<IS_INTEGRAL(U)>::type* = nullptr>",
            "\tfinite_field_char2_small_base &inplace_power(U e){",
            "\t\tif(e == 0) return *this = 1;",
            "\t\tif(data == 0) return *this = {};",
            "\t\tif(data == 1 || e == 1) return *this;",
            "\t\te %= _full_mask;",
            "\t\tif(e < 0) e += _full_mask;",
            "\t\tfinite_field_char2_small_base res = 1;",
            "\t\tfor(; e; *this *= *this, e >>= 1) if(e & 1) res *= *this;",
            "\t\treturn *this = res;",
            "\t}",
            "\ttemplate<class U, typename enable_if<IS_INTEGRAL(U)>::type* = nullptr>",
            "\tfinite_field_char2_small_base power(U e) const{",
            "\t\treturn finite_field_char2_small_base(*this).inplace_power(e);",
            "\t}",
            "\tfinite_field_char2_small_base &operator/=(const finite_field_char2_small_base &otr){",
            "\t\tassert(otr);",
            "\t\treturn *this *= otr.power(_full_mask - 1);",
            "\t}",
            "#define ARITHMETIC_OP(op, apply_op)\\",
            "finite_field_char2_small_base operator op(const finite_field_char2_small_base &x) const{ return finite_field_char2_small_base(*this) apply_op x; }\\",
            "template<class U, typename enable_if<IS_INTEGRAL(U)>::type* = nullptr>\\",
            "finite_field_char2_small_base operator op(const U &x) const{ return finite_field_char2_small_base(*this) apply_op finite_field_char2_small_base(x); }\\",
            "template<class U, typename enable_if<IS_INTEGRAL(U)>::type* = nullptr>\\",
            "friend finite_field_char2_small_base operator op(const U &x, const finite_field_char2_small_base &y){ return finite_field_char2_small_base(x) apply_op y; }",
            "\tARITHMETIC_OP(+, +=) ARITHMETIC_OP(-, -=) ARITHMETIC_OP(*, *=) ARITHMETIC_OP(/, /=)",
            "#undef ARITHMETIC_OP",
            "#define COMPARE_OP(op)\\",
            "bool operator op(const finite_field_char2_small_base &x) const{ return data op x.data; }\\",
            "template<class U, typename enable_if<IS_INTEGRAL(U)>::type* = nullptr>\\",
            "bool operator op(const U &x) const{ return data op finite_field_char2_small_base(x).data; }\\",
            "template<class U, typename enable_if<IS_INTEGRAL(U)>::type* = nullptr>\\",
            "friend bool operator op(const U &x, const finite_field_char2_small_base &y){ return finite_field_char2_small_base(x).data op y.data; }",
            "\tCOMPARE_OP(==) COMPARE_OP(!=) COMPARE_OP(<) COMPARE_OP(<=) COMPARE_OP(>) COMPARE_OP(>=)",
            "#undef COMPARE_OP",
            "\tfriend istream &operator>>(istream &in, finite_field_char2_small_base &number){",
            "\t\treturn in >> number.data;",
            "\t}",
            "\tfriend ostream &operator<<(ostream &out, const finite_field_char2_small_base &x){",
            "\t\treturn out << x.data;",
            "\t}",
            "\tT data = 0;",
            "#undef IS_INTEGRAL",
            "#undef IS_UNSIGNED",
            "};",
            "",
            "template<size_t D>",
            "using FF2 = finite_field_char2_small_base<D, unsigned int, unsigned long long>;",
            "template<size_t D>",
            "using FF2L = finite_field_char2_small_base<D, unsigned long long, __uint128_t>;"
        ],
        "description": "tranxuanbach"
    }
}