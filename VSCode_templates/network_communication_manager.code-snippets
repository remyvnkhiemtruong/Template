{
    "tranxuanbach": {
        "prefix": "network_communication_manager",
        "body": [
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "struct network_communication_manager{",
            "\tstring host, port;",
            "\tstruct addrinfo hints, *serverinfo;",
            "\tint sockfd;",
            "\tvoid init(){",
            "\t\tmemset(&hints, 0, sizeof hints); // make sure the struct is empty",
            "\t\thints.ai_family = AF_UNSPEC;     // don't care IPv4 or IPv6",
            "\t\thints.ai_socktype = SOCK_STREAM; // TCP stream sockets",
            "\t\thints.ai_flags = AI_PASSIVE;     // fill in my IP for me",
            "\t}",
            "\t// get sockaddr, IPv4 or IPv6:",
            "\tvoid *get_in_addr(struct sockaddr *sa){",
            "\t\tif(sa->sa_family == AF_INET) return &(((struct sockaddr_in*)sa)->sin_addr);",
            "\t\treturn &(((struct sockaddr_in6*)sa)->sin6_addr);",
            "\t}",
            "\tnetwork_communication_manager(string host, string port): host(host), port(port){",
            "\t\tinit();",
            "\t\tif(auto status = getaddrinfo(host.c_str(), port.c_str(), &hints, &serverinfo)){",
            "\t\t\tcerr << \"getaddrinfo error: \" << gai_strerror(status) << endl;",
            "\t\t\texit(1);",
            "\t\t}",
            "\t\t// loop through all the results and connect to the first we can",
            "\t\tstruct addrinfo *p;",
            "\t\tfor(p = serverinfo; p; p = p->ai_next){",
            "\t\t\tif(!~(sockfd = socket(p->ai_family, p->ai_socktype, p->ai_protocol))){",
            "\t\t\t\tperror(\"client: socket\");",
            "\t\t\t\tcontinue;",
            "\t\t\t}",
            "\t\t\tif(!~connect(sockfd, p->ai_addr, p->ai_addrlen)){",
            "\t\t\t\tclose(sockfd);",
            "\t\t\t\tperror(\"client: connect\");",
            "\t\t\t\tcontinue;",
            "\t\t\t}",
            "\t\t\tbreak;",
            "\t\t}",
            "\t\tif(!p){",
            "\t\t\tcerr << \"client: failed to connect\" << endl;",
            "\t\t\texit(2);",
            "\t\t}",
            "\t\tchar s[INET6_ADDRSTRLEN];",
            "\t\tinet_ntop(p->ai_family, get_in_addr((struct sockaddr *)p->ai_addr), s, sizeof s);",
            "\t\tcerr << \"client: connecting to \" << s << endl;",
            "\t}",
            "\t~network_communication_manager(){",
            "\t\tfreeaddrinfo(serverinfo);",
            "\t\tclose(sockfd);",
            "\t}",
            "\tvoid send(string message) const{",
            "\t\t::send(sockfd, message.c_str(), (int)message.size(), 0);",
            "\t}",
            "\tstring receive(char delim = '\\n') const{",
            "\t\tstring message;",
            "\t\twhile(true){",
            "\t\t\tchar s[2];",
            "\t\t\tif(!~(recv(sockfd, s, 1, 0))){",
            "\t\t\t\tperror(\"receive\");",
            "\t\t\t\texit(1);",
            "\t\t\t}",
            "\t\t\tif(s[0] == delim) break;",
            "\t\t\tmessage.push_back(s[0]);",
            "\t\t}",
            "\t\treturn message;",
            "\t}",
            "};"
        ],
        "description": "tranxuanbach"
    }
}