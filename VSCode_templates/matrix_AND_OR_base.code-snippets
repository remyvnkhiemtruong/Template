{
    "tranxuanbach": {
        "prefix": "matrix_AND_OR_base",
        "body": [
            "template<size_t SZ>",
            "struct matrix_AND_OR_base{",
            "\tint n, m;",
            "\tvector<bitset<SZ>> data;",
            "\tbitset<SZ> &operator[](int i){",
            "\t\tassert(0 <= i && i < n);",
            "\t\treturn data[i];",
            "\t}",
            "\tconst bitset<SZ> &operator[](int i) const{",
            "\t\tassert(0 <= i && i < n);",
            "\t\treturn data[i];",
            "\t}",
            "\tmatrix_AND_OR_base &inplace_slice(int il, int ir, int jl, int jr){",
            "\t\tassert(0 <= il && il <= ir && ir <= n);",
            "\t\tassert(0 <= jl && jl <= jr && jr <= m);",
            "\t\tn = ir - il, m = jr - jl;",
            "\t\tif(il > 0) for(auto i = 0; i < n; ++ i) swap(data[i], data[il + i]);",
            "\t\tdata.resize(n);",
            "\t\tfor(auto &row: data) row = row << SZ - jr >> jl;",
            "\t\treturn *this;",
            "\t}",
            "\tmatrix_AND_OR_base slice(int il, int ir, int jl, int jr) const{",
            "\t\treturn matrix_AND_OR_base(*this).inplace_slice(il, ir, jl, jr);",
            "\t}",
            "\tmatrix_AND_OR_base &inplace_row_slice(int il, int ir){",
            "\t\tassert(0 <= il && il <= ir && ir <= n);",
            "\t\tn = ir - il;",
            "\t\tif(il > 0) for(auto i = 0; i < n; ++ i) swap(data[i], data[il + i]);",
            "\t\tdata.resize(n);",
            "\t\treturn *this;",
            "\t}",
            "\tmatrix_AND_OR_base row_slice(int il, int ir) const{",
            "\t\treturn matrix_AND_OR_base(*this).inplace_row_slice(il, ir);",
            "\t}",
            "\tmatrix_AND_OR_base &inplace_column_slice(int jl, int jr){",
            "\t\tassert(0 <= jl && jl <= jr && jr <= m);",
            "\t\tm = jr - jl;",
            "\t\tfor(auto &row: data) row = row << SZ - jr >> jl;",
            "\t\treturn *this;",
            "\t}",
            "\tmatrix_AND_OR_base column_slice(int jl, int jr) const{",
            "\t\treturn matrix_AND_OR_base(*this).inplace_column_slice(jl, jr);",
            "\t}",
            "\tbool operator==(const matrix_AND_OR_base &a) const{",
            "\t\tassert(n == a.n && m == a.m);",
            "\t\treturn data == a.data;",
            "\t}",
            "\tbool operator!=(const matrix_AND_OR_base &a) const{",
            "\t\tassert(n == a.n && m == a.m);",
            "\t\treturn data != a.data;",
            "\t}",
            "\tmatrix_AND_OR_base &operator+=(const matrix_AND_OR_base &a){",
            "\t\tassert(n == a.n && m == a.m);",
            "\t\tfor(auto i = 0; i < n; ++ i) data[i] &= a[i];",
            "\t\treturn *this;",
            "\t}",
            "\tmatrix_AND_OR_base operator+(const matrix_AND_OR_base &a) const{",
            "\t\treturn matrix_AND_OR_base(*this) += a;",
            "\t}",
            "\tmatrix_AND_OR_base &operator*=(const matrix_AND_OR_base &a){",
            "\t\tassert(m == a.n);",
            "\t\tint l = a.m;",
            "\t\tmatrix_AND_OR_base res(n, l);",
            "\t\tvector<bitset<SZ>> temp(l);",
            "\t\tfor(auto i = 0; i < l; ++ i) for(auto j = 0; j < m; ++ j) temp[i][j] = a[j][i];",
            "\t\tfor(auto i = 0; i < n; ++ i) for(auto j = 0; j < l; ++ j) res[i][j] = (data[i] | temp[j]).all();",
            "\t\treturn *this = res;",
            "\t}",
            "\tmatrix_AND_OR_base operator*=(const matrix_AND_OR_base &a) const{",
            "\t\treturn matrix_AND_OR_base(*this) *= a;",
            "\t}",
            "\tmatrix_AND_OR_base &operator*=(bool c){",
            "\t\tif(c) for(auto &v: *this) v.set();",
            "\t\treturn *this;",
            "\t}",
            "\tmatrix_AND_OR_base operator*(bool c) const{",
            "\t\treturn matrix_AND_OR_base(*this) *= c;",
            "\t}",
            "\ttemplate<class T, typename enable_if<is_integral<T>::value>::type* = nullptr>",
            "\tmatrix_AND_OR_base &inplace_power(T e){",
            "\t\tassert(n == m);",
            "\t\tmatrix_AND_OR_base res(n, n, true);",
            "\t\tfor(; e; *this *= *this, e >>= 1) if(e & 1) res *= *this;",
            "\t\treturn *this = res;",
            "\t}",
            "\ttemplate<class T>",
            "\tmatrix_AND_OR_base power(T e) const{",
            "\t\treturn matrix_AND_OR_base(*this).inplace_power(e);",
            "\t}",
            "\tmatrix_AND_OR_base &inplace_transpose(){",
            "\t\tassert(n == m);",
            "\t\tfor(auto i = 0; i < n; ++ i) for(auto j = i + 1; j < n; ++ j) swap(data[i][j], data[j][i]);",
            "\t\treturn *this;",
            "\t}",
            "\tmatrix_AND_OR_base transpose() const{",
            "\t\tif(n == m) return matrix_AND_OR_base(*this).inplace_transpose();",
            "\t\tmatrix_AND_OR_base res(m, n);",
            "\t\tfor(auto i = 0; i < n; ++ i) for(auto j = 0; j < m; ++ j) res[j][i] = data[i][j];",
            "\t\treturn res;",
            "\t}",
            "\t// Multiply a column vector v on the right",
            "\tvector<int> operator*(const bitset<SZ> &v) const{",
            "\t\tvector<int> res(n);",
            "\t\tfor(auto i = 0; i < n; ++ i) res[i] = (data[i] | v).all();",
            "\t\treturn res;",
            "\t}",
            "\ttemplate<class output_stream>",
            "\tfriend output_stream &operator<<(output_stream &out, const matrix_AND_OR_base &a){",
            "\t\tout << \"\\n\";",
            "\t\tfor(auto i = 0; i < a.n; ++ i){",
            "\t\t\tfor(auto j = 0; j < a.m; ++ j) out << bool(a[i][j]);",
            "\t\t\tout << \"\\n\";",
            "\t\t}",
            "\t\treturn out;",
            "\t}",
            "\tmatrix_AND_OR_base(int n, int m, bool init_diagonal = false, bool init_off_diagonal = false): n(n), m(m), data(n){",
            "\t\tfor(auto i = 0; i < n; ++ i) for(auto j = 0; j < m; ++ j) data[i][j] = i == j ? init_diagonal : init_off_diagonal;",
            "\t}",
            "\tmatrix_AND_OR_base(int n, int m, const vector<bitset<SZ>> &a): n(n), m(m), data(a){ }",
            "};",
            "template<size_t SZ>",
            "matrix_AND_OR_base<SZ> operator*(bool c, matrix_AND_OR_base<SZ> a){",
            "\tif(c) for(auto &v: a) v.set();",
            "\treturn a;",
            "}",
            "// Multiply a row vector v on the left",
            "template<size_t SZ>",
            "bitset<SZ> operator*(const vector<int> &v, const matrix_AND_OR_base<SZ> &a){",
            "\tassert(a.n == (int)v.size());",
            "\tbitset<SZ> res;",
            "\tres.set();",
            "\tfor(auto i = 0; i < a.n; ++ i) if(!v[i]) res &= a[i];",
            "\treturn res;",
            "}",
            "",
            "using matrix_AND_OR = matrix_AND_OR_base<1000>;"
        ],
        "description": "tranxuanbach"
    }
}