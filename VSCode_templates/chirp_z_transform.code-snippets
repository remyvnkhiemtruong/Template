{
    "tranxuanbach": {
        "prefix": "chirp_z_transform",
        "body": [
            "// Returns {p[base^0], p[base^2], ..., p[base^2(n-1)]}",
            "// O(max(deg(p), n) * log(max(deg(p), n)))",
            "// Requires modular",
            "template<class T>",
            "vector<T> chirp_z_transform_even(const vector<T> &p, T base, int n){",
            "\tif(p.empty() || all_of(p.begin(), p.end(), [&](auto x){ return !x; })) return vector<T>(n, 0);",
            "\tauto augment_sq = [&](const vector<T> &p, T base)->vector<T>{",
            "\t\tT cur = base, tot = 1, sqbase = base * base;",
            "\t\tauto res = p;",
            "\t\tfor(auto i = 0; i < (int)p.size(); ++ i) res[i] *= tot, tot *= cur, cur *= sqbase;",
            "\t\treturn res;",
            "\t};",
            "\tint m = (int)p.size();",
            "\tvector<T> vv(m + n);",
            "\tT inv = T(1) / base, sqinv = inv * inv, cur = inv, tot = 1;",
            "\tfor(auto i = 0; i <= max(n - 1, m); ++ i){",
            "\t\tif(i <= m) vv[m - i] = tot;",
            "\t\tif(i < n) vv[m + i] = tot;",
            "\t\ttot *= cur, cur *= sqinv;",
            "\t}",
            "\tauto res = augment_sq(p, base) * vv;",
            "\tres = augment_sq(vector<T>(res.begin() + min((int)res.size(), m), res.begin() + min((int)res.size(), m + n)), base);",
            "\tres.resize(n);",
            "\treturn res;",
            "}",
            "// Returns {p[base^0], p[base^1], ..., p[base^(n-1)]}",
            "// O(max(deg(p), n) * log(max(deg(p), n)))",
            "// Requires modular",
            "template<class T>",
            "vector<T> chirp_z_transform(const vector<T> &p, T base, int n){",
            "\tauto augment = [&](const vector<T> &p, T base)->vector<T>{",
            "\t\tT tot = 1;",
            "\t\tauto res = p;",
            "\t\tfor(auto i = 0; i < (int)p.size(); ++ i) res[i] *= tot, tot *= base;",
            "\t\treturn res;",
            "\t};",
            "\tauto even = chirp_z_transform_even(p, base, n + 1 >> 1);",
            "\tauto odd = chirp_z_transform_even(augment(p, base), base, n >> 1);",
            "\tvector<T> res(n);",
            "\tfor(auto i = 0; i < n >> 1; ++ i) res[i << 1] = even[i], res[i << 1 | 1] = odd[i];",
            "\tif(n & 1) res.back() = even.back();",
            "\treturn res;",
            "}"
        ],
        "description": "tranxuanbach"
    }
}