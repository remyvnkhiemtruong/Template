{
    "tranxuanbach": {
        "prefix": "segment_tree_2d_sparse",
        "body": [
            "template<class B, class T, class F>",
            "struct segment_tree_2d_sparse{",
            "\tvector<B> X;",
            "\tvector<vector<array<B, 2>>> Y;",
            "\tvector<vector<T>> data;",
            "\tF TT; // Commutative monoid operation (always adjacent)",
            "\tT T_id; // Commutative monoid identity",
            "\t// Every point holds T_id except for base points",
            "\t// O(n * log^2(n))",
            "\tsegment_tree_2d_sparse(vector<pair<array<B, 2>, T>> init, F TT, T T_id): X(init.size()), TT(TT), T_id(T_id){",
            "\t\tint n = (int)init.size();",
            "\t\tsort(init.begin(), init.end());",
            "\t\tfor(auto i = 0; i < n; ++ i) X[i] = init[i].first[0];",
            "\t\tX.erase(unique(X.begin(), X.end()), X.end());",
            "\t\tY.resize(X.size() << 1);",
            "\t\tdata.resize(X.size() << 1);",
            "\t\tvector<vector<pair<array<B, 2>, T>>> hold(X.size() << 1);",
            "\t\tfor(auto i = 0, x = 0; i < n; ++ i){",
            "\t\t\tauto [pos, val] = init[i];",
            "\t\t\twhile(X[x] < pos[0]) ++ x;",
            "\t\t\thold[x + (int)X.size()].push_back({{pos[1], pos[0]}, val});",
            "\t\t}",
            "\t\tfor(auto x = 2 * (int)X.size() - 1; x >= 1; -- x){",
            "\t\t\tif(x < (int)X.size()) merge(hold[x << 1].begin(), hold[x << 1].end(), hold[x << 1 | 1].begin(), hold[x << 1 | 1].end(), back_inserter(hold[x]));",
            "\t\t\tauto &Y0 = Y[x];",
            "\t\t\tauto &hold0 = hold[x];",
            "\t\t\tsort(hold0.begin(), hold0.end());",
            "\t\t\tY0.resize(hold0.size());",
            "\t\t\tfor(auto j = 0; j < (int)hold0.size(); ++ j) Y0[j] = hold0[j].first;",
            "\t\t\tY0.erase(unique(Y0.begin(), Y0.end()), Y0.end());",
            "\t\t\tdata[x].resize(Y0.size() << 1, T_id);",
            "\t\t\tfor(auto j = 0, y = 0; j < (int)hold0.size(); ++ j){",
            "\t\t\t\twhile(Y0[y] < hold0[j].first) ++ y;",
            "\t\t\t\tdata[x][y + (int)Y0.size()] = TT(data[x][y + (int)Y0.size()], hold0[j].second);",
            "\t\t\t}",
            "\t\t\tfor(auto y = (int)Y0.size() - 1; y >= 1; -- y) data[x][y] = TT(data[x][y << 1], data[x][y << 1 | 1]);",
            "\t\t}",
            "\t}",
            "\t// O(n * log^2(n))",
            "\tsegment_tree_2d_sparse(vector<array<B, 2>> base, F TT, T T_id): TT(TT), T_id(T_id){",
            "\t\tvector<pair<array<B, 2>, T>> init(base.size());",
            "\t\tfor(auto i = 0; i < (int)base.size(); ++ i) init[i] = {base[i], T_id};",
            "\t\t*this = segment_tree_2d_sparse(init, TT, T_id);",
            "\t}",
            "\tsegment_tree_2d_sparse &operator=(const segment_tree_2d_sparse &otr){",
            "\t\tX = otr.X;",
            "\t\tY = otr.Y;",
            "\t\tdata = otr.data;",
            "\t\treturn *this;",
            "\t}",
            "\t// O(log^2(n))",
            "\tvoid set(B _p, B _q, const T &x){",
            "\t\tint p = lower_bound(X.begin(), X.end(), _p) - X.begin();",
            "\t\tassert(p < (int)X.size() && X[p] == _p);",
            "\t\tfor(p += (int)X.size(); p; p >>= 1){",
            "\t\t\tauto &Y0 = Y[p];",
            "\t\t\tauto &data0 = data[p];",
            "\t\t\tint q = lower_bound(Y0.begin(), Y0.end(), array{_q, _p}) - Y0.begin();",
            "\t\t\tassert(q < (int)Y0.size() && Y0[q][0] == _q && Y0[q][1] == _p);",
            "\t\t\tq += (int)Y0.size();",
            "\t\t\tdata0[q] = x;",
            "\t\t\twhile(q >>= 1) data0[q] = TT(data0[q << 1], data0[q << 1 | 1]);",
            "\t\t}",
            "\t}",
            "\t// O(log^2(n))",
            "\tvoid update(B _p, B _q, const T &x){",
            "\t\tint p = lower_bound(X.begin(), X.end(), _p) - X.begin();",
            "\t\tassert(p < (int)X.size() && X[p] == _p);",
            "\t\tfor(p += (int)X.size(); p; p >>= 1){",
            "\t\t\tauto &Y0 = Y[p];",
            "\t\t\tauto &data0 = data[p];",
            "\t\t\tint q = lower_bound(Y0.begin(), Y0.end(), array{_q, _p}) - Y0.begin();",
            "\t\t\tassert(q < (int)Y0.size() && Y0[q][0] == _q && Y0[q][1] == _p);",
            "\t\t\tq += (int)Y0.size();",
            "\t\t\tdata0[q] = TT(data0[q], x);",
            "\t\t\twhile(q >>= 1) data0[q] = TT(data0[q << 1], data0[q << 1 | 1]);",
            "\t\t}",
            "\t}",
            "\t// O(log(n))",
            "\tT query(B _p, B _q){",
            "\t\tint p = lower_bound(X.begin(), X.end(), _p) - X.begin();",
            "\t\tif(p == (int)X.size() || X[p] != _p) return T_id;",
            "\t\tauto &Y0 = Y[p + (int)X.size()];",
            "\t\tint q = lower_bound(Y0.begin(), Y0.end(), array{_q, _p}) - Y0.begin();",
            "\t\tif(q == (int)Y0.size() || Y0[q] != array{_q, _p}) return T_id;",
            "\t\treturn data[p + (int)X.size()][q + (int)Y0.size()];",
            "\t}",
            "\t// O(log^2(n))",
            "\tT query(B _xl, B _xr, B _yl, B _yr){",
            "\t\tint xl = lower_bound(X.begin(), X.end(), _xl) - X.begin();",
            "\t\tint xr = lower_bound(X.begin(), X.end(), _xr) - X.begin();",
            "\t\tT res = T_id;",
            "\t\tfor(xl += (int)X.size(), xr += (int)X.size(); xl < xr; xl >>= 1, xr >>= 1){",
            "\t\t\tif(xl & 1){",
            "\t\t\t\tauto &Y0 = Y[xl];",
            "\t\t\t\tauto &data0 = data[xl];",
            "\t\t\t\tint yl = lower_bound(Y0.begin(), Y0.end(), array{_yl, numeric_limits<B>::min()}) - Y0.begin();",
            "\t\t\t\tint yr = lower_bound(Y0.begin(), Y0.end(), array{_yr, numeric_limits<B>::min()}) - Y0.begin();",
            "\t\t\t\tfor(yl += (int)Y0.size(), yr += (int)Y0.size(); yl < yr; yl >>= 1, yr >>= 1){",
            "\t\t\t\t\tif(yl & 1) res = TT(res, data0[yl ++]);",
            "\t\t\t\t\tif(yr & 1) res = TT(res, data0[-- yr]);",
            "\t\t\t\t}",
            "\t\t\t\t++ xl;",
            "\t\t\t}",
            "\t\t\tif(xr & 1){",
            "\t\t\t\t-- xr;",
            "\t\t\t\tauto &Y0 = Y[xr];",
            "\t\t\t\tauto &data0 = data[xr];",
            "\t\t\t\tint yl = lower_bound(Y0.begin(), Y0.end(), array{_yl, numeric_limits<B>::min()}) - Y0.begin();",
            "\t\t\t\tint yr = lower_bound(Y0.begin(), Y0.end(), array{_yr, numeric_limits<B>::min()}) - Y0.begin();",
            "\t\t\t\tfor(yl += (int)Y0.size(), yr += (int)Y0.size(); yl < yr; yl >>= 1, yr >>= 1){",
            "\t\t\t\t\tif(yl & 1) res = TT(res, data0[yl ++]);",
            "\t\t\t\t\tif(yr & 1) res = TT(res, data0[-- yr]);",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t}",
            "\t\treturn res;",
            "\t}",
            "};"
        ],
        "description": "tranxuanbach"
    }
}