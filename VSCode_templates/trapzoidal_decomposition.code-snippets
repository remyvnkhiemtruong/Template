{
    "tranxuanbach": {
        "prefix": "trapzoidal_decomposition",
        "body": [
            "// Given a polygonal region bounded by outer polygon and a set of inner polygonal holes strictly contained in the outer polygon, where none of the polygons intersect, find all trapzoids in the vertical trapzoidal decomposition.",
            "// The outer polygon is given in CCW while the inner ones are in CW.",
            "// Returns {",
            "//  list of trapzoids in increasing order of x-coordinates,",
            "//  list of adjacency info",
            "// }",
            "// where a trapzoid given by the tuple (xl, xr, {i0, j0}, {i1, j1}) is defined by the lines X=xl, X=xr, segment(i0, j0), and segment(i1, j1) where segment(i, j) is the next edge of the j-th vertex of the i-th polygon (i=0 denotes the outer one), and",
            "// an adjacency info given by the tuple (i, j) is that the i-th trapzoid and the j-th trapzoids are adjacent with i-th one on the left.",
            "// O(n * log(n)) where n is the total number of vertices",
            "// Requires point",
            "template<class T>",
            "pair<",
            "\tvector<tuple<T, T, array<int, 2>, array<int, 2>>>,",
            "\tvector<array<int, 2>>",
            ">",
            "trapzoidal_decomposition(const vector<vector<point<T>>> &a){",
            "\tassert(!a.empty());",
            "\tassert(doubled_signed_area(a[0]) >= 0);",
            "\tfor(auto i = 1; i < (int)a.size(); ++ i) assert(doubled_signed_area(a[i]) <= 0);",
            "\tassert(!a.empty());",
            "\tassert(doubled_signed_area(a[0]) >= 0);",
            "\tfor(auto i = 1; i < (int)a.size(); ++ i) assert(doubled_signed_area(a[i]) <= 0);",
            "\tvector<array<int, 2>> order;",
            "\tfor(auto i = 0; i < (int)a.size(); ++ i) for(auto j = 0; j < (int)a[i].size(); ++ j) order.push_back({i, j});",
            "\tsort(order.begin(), order.end(), [&](auto i, auto j){ return a[i[0]][i[1]] < a[j[0]][j[1]]; });",
            "\tT sweep;",
            "\tstruct key_type{ // stores the line p-q",
            "\t\tmutable point<T> p, q;",
            "\t};",
            "\tauto cmp = [&](const key_type &a, const key_type &b)->bool{",
            "\t\tauto ya = a.p.x == a.q.x ? array{max(a.p.y, a.q.y), T(1)} : array{a.p.y * (a.q.x - sweep) + a.q.y * (sweep - a.p.x), a.q.x - a.p.x};",
            "\t\tauto yb = b.p.x == b.q.x ? array{min(b.p.y, b.q.y), T(1)} : array{b.p.y * (b.q.x - sweep) + b.q.y * (sweep - b.p.x), b.q.x - b.p.x};",
            "\t\tif(ya[1] < 0) ya = {-ya[0], -ya[1]};",
            "\t\tif(yb[1] < 0) yb = {-yb[0], -yb[1]};",
            "\t\treturn ya[0] * yb[1] < yb[0] * ya[1];",
            "\t};",
            "\tmap<key_type, int, decltype(cmp)> events(cmp);",
            "\tvector<tuple<T, T, array<int, 2>, array<int, 2>>> trapzoid;",
            "\tvector<array<int, 2>> edge;",
            "\tfor(auto [i, j]: order){",
            "\t\tauto &b = a[i];",
            "\t\tsweep = b[j].x;",
            "\t\tint pj = (j + (int)b.size() - 1) % (int)b.size();",
            "\t\tint nj = (j + 1) % (int)b.size();",
            "\t\tif(b[j] < b[pj] && b[j] < b[nj]){",
            "\t\t\tif(doubled_signed_area(b[pj], b[j], b[nj]) > 0){ // Start",
            "\t\t\t\tint u = (int)trapzoid.size();",
            "\t\t\t\ttrapzoid.push_back({sweep, {}, {i, j}, {i, pj}});",
            "\t\t\t\tevents.insert({{b[j], b[pj]}, u});",
            "\t\t\t}",
            "\t\t\telse{ // Split",
            "\t\t\t\tauto it = events.lower_bound({b[j], b[j]});",
            "\t\t\t\tget<1>(trapzoid[it->second]) = sweep;",
            "\t\t\t\tint u = (int)trapzoid.size();",
            "\t\t\t\ttrapzoid.push_back({sweep, {}, get<2>(trapzoid[it->second]), {i, pj}});",
            "\t\t\t\tedge.push_back({it->second, u});",
            "\t\t\t\tint v = (int)trapzoid.size();",
            "\t\t\t\ttrapzoid.push_back({sweep, {}, {i, j}, {get<3>(trapzoid[it->second])}});",
            "\t\t\t\tedge.push_back({it->second, v});",
            "\t\t\t\tit->second = v;",
            "\t\t\t\tevents.insert(it, {{b[j], b[pj]}, u});",
            "\t\t\t}",
            "\t\t}",
            "\t\telse if(b[j] > b[pj] && b[j] > b[nj]){ ",
            "\t\t\tif(doubled_signed_area(b[pj], b[j], b[nj]) > 0){ // End",
            "\t\t\t\tauto it = events.lower_bound({b[j], b[j]});",
            "\t\t\t\tget<1>(trapzoid[it->second]) = sweep;",
            "\t\t\t\tevents.erase(it);",
            "\t\t\t}",
            "\t\t\telse{ // Merge",
            "\t\t\t\tauto l = events.lower_bound({b[j], b[j]}), r = std::next(l);",
            "\t\t\t\tget<1>(trapzoid[l->second]) = get<1>(trapzoid[r->second]) = sweep;",
            "\t\t\t\tint u = (int)trapzoid.size();",
            "\t\t\t\ttrapzoid.push_back({sweep, {}, get<2>(trapzoid[l->second]), get<3>(trapzoid[r->second])});",
            "\t\t\t\tedge.push_back({l->second, u});",
            "\t\t\t\tedge.push_back({r->second, u});",
            "\t\t\t\tr->second = u;",
            "\t\t\t\tevents.erase(l);",
            "\t\t\t}",
            "\t\t}",
            "\t\telse{ // Regular",
            "\t\t\tauto it = events.lower_bound({b[j], b[j]});",
            "\t\t\tget<1>(trapzoid[it->second]) = sweep;",
            "\t\t\tint u = (int)trapzoid.size();",
            "\t\t\tif(b[pj] < b[j]){ // Left",
            "\t\t\t\ttrapzoid.push_back({sweep, {}, {i, j}, get<3>(trapzoid[it->second])});",
            "\t\t\t\tedge.push_back({it->second, u});",
            "\t\t\t\tit->second = u;",
            "\t\t\t}",
            "\t\t\telse{ // Right",
            "\t\t\t\ttrapzoid.push_back({sweep, {}, {get<2>(trapzoid[it->second])}, {i, pj}});",
            "\t\t\t\tedge.push_back({it->second, u});",
            "\t\t\t\tit->first.p = it->first.q;",
            "\t\t\t\tit->first.q = b[pj];",
            "\t\t\t\tit->second = u;",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "\treturn {trapzoid, edge};",
            "}"
        ],
        "description": "tranxuanbach"
    }
}