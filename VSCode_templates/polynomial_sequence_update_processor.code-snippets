{
    "tranxuanbach": {
        "prefix": "polynomial_sequence_update_processor",
        "body": [
            "template<class T>",
            "struct polynomial_sequence_update_processor{",
            "\tint n, d;",
            "\tvector<T> data, res;",
            "\tvector<vector<T>> choose;",
            "\t// d: length of the polynomial",
            "\t// O(n + d^2)",
            "\tpolynomial_sequence_update_processor(int n, int d): n(n), d(d), data(n + d), choose(d, vector<T>(d, 1)), deltal(n + d), deltar(n + d){",
            "\t\tassert(n >= 0 && d >= 0);",
            "\t\tfor(auto n = 2; n < d; ++ n) for(auto k = 1; k < n; ++ k) choose[n][k] = choose[n - 1][k - 1] + choose[n - 1][k];",
            "\t}",
            "\t// O(n)",
            "\tvoid clear(){",
            "\t\tfill(data.begin(), data.end(), 0);",
            "\t}",
            "\tvector<T> c, c_next, deltal, deltar;",
            "\t// Add c[0]+c[1](base+x-l)+...+c[d-1](base+x-l)^{d-1} for each x \\in [l,r)",
            "\t// Polynomial_Type must be either vector or array",
            "\t// O(d^3)",
            "\ttemplate<class Polynomial_Type>",
            "\tvoid update(int l, int r, T base, const Polynomial_Type &coef){",
            "\t\tassert(0 <= l && l <= r && r <= n);",
            "\t\tassert((int)coef.size() <= d);",
            "\t\tif(l == r) return;",
            "\t\tc.assign(d, 0);",
            "\t\tc_next.assign(d, 0);",
            "\t\tfor(auto i = l; i < l + d; ++ i) deltal[i] = 0;",
            "\t\tfor(auto i = r; i < r + d; ++ i) deltar[i] = 0;",
            "\t\tcopy(coef.begin(), coef.end(), c.begin());",
            "\t\tfor(auto t = 0; t < d; ++ t){",
            "\t\t\tT x = 0, y = 0;",
            "\t\t\tfor(auto i = d - 1 - t; i >= 0; -- i){",
            "\t\t\t\tx = x * base + c[i];",
            "\t\t\t\ty = y * (base + r - l) + c[i];",
            "\t\t\t}",
            "\t\t\tdeltal[l + t] += x;",
            "\t\t\tdeltar[r + t] -= y;",
            "\t\t\tfor(auto i = l + t; i > l; -- i) deltal[i] -= deltal[i - 1];",
            "\t\t\tfor(auto i = r + t; i > r; -- i) deltar[i] -= deltar[i - 1];",
            "\t\t\tfill(c_next.begin(), c_next.begin() + d - 1 - t, 0);",
            "\t\t\tfor(auto i = 0; i < d - 1 - t; ++ i) for(auto j = i + 1; j <= d - 1 - t; ++ j) c_next[i] += c[j] * choose[j][i];",
            "\t\t\tswap(c, c_next);",
            "\t\t}",
            "\t\tfor(auto i = l; i < l + d; ++ i) data[i] += deltal[i];",
            "\t\tfor(auto i = r; i < r + d; ++ i) data[i] += deltar[i];",
            "\t}",
            "\t// O(d * n)",
            "\tconst vector<T> &snapshot(){",
            "\t\tres.resize(n);",
            "\t\tcopy(data.begin(), data.end() - d, res.begin());",
            "\t\tfor(auto rep = 0; rep < d; ++ rep) for(auto i = 1; i < n; ++ i) res[i] += res[i - 1];",
            "\t\treturn res;",
            "\t}",
            "};"
        ],
        "description": "tranxuanbach"
    }
}