{
    "tranxuanbach": {
        "prefix": "generate_edge_cactus",
        "body": [
            "// Requires generate_tree",
            "vector<array<int, 2>> generate_edge_cactus(auto &&rng, int n, double cycle_extension_prob = 0.8){",
            "\tuniform_real_distribution<double> genp(0, 1);",
            "\tvector<vector<int>> adj(n);",
            "\tvector<array<int, 2>> res;",
            "\tfor(auto [u, v]: generate_tree(rng, n)){",
            "\t\tres.push_back({u, v});",
            "\t\tadj[u].push_back(v), adj[v].push_back(u);",
            "\t}",
            "\tvector<int> order, pv(n, -1), depth(n);",
            "\tauto dfs = [&](auto self, int u, int p)->void{",
            "\t\torder.push_back(u);",
            "\t\tpv[u] = p;",
            "\t\tfor(auto v: adj[u]) if(v != p){",
            "\t\t\tdepth[v] = depth[u] + 1;",
            "\t\t\tself(self, v, u);",
            "\t\t}",
            "\t};",
            "\tdfs(dfs, 0, -1);",
            "\tvector<int> covered(n);",
            "\tfor(auto i = n - 1; i >= 0; -- i){",
            "\t\tint u = order[i];",
            "\t\tif(depth[u] <= 1 || covered[u] || covered[pv[u]]){",
            "\t\t\tcontinue;",
            "\t\t}",
            "\t\tif(genp(rng) <= cycle_extension_prob){",
            "\t\t\tcovered[u] = covered[pv[u]] = true;",
            "\t\t\tint v = pv[pv[u]];",
            "\t\t\twhile(v && !covered[v] && genp(rng) <= cycle_extension_prob){",
            "\t\t\t\tcovered[v] = true;",
            "\t\t\t\tv = pv[v];",
            "\t\t\t}",
            "\t\t\tres.push_back({u, v});",
            "\t\t}",
            "\t}",
            "\treturn res;",
            "}"
        ],
        "description": "tranxuanbach"
    }
}