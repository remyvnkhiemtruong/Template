{
    "tranxuanbach": {
        "prefix": "integral_multiset",
        "body": [
            "// Efficient multiset when the keys are integers in range [offset, offset + len)",
            "template<class T>",
            "struct integral_multiset{",
            "\tint _size = 0;",
            "\tT len, offset, maxval;",
            "\tvector<int> freq;",
            "\tvector<int> data;",
            "\tintegral_multiset(int len, T offset = {}): len(len), offset(offset), maxval(offset + len), freq(len), data(len){ }",
            "\tintegral_multiset(const vector<T> &init, int len, T offset = 0): offset(offset), maxval(offset + len), freq(len){",
            "\t\tfor(auto x: init){",
            "\t\t\tassert(offset <= x && x < maxval);",
            "\t\t\t++ freq[x - offset], ++ _size;",
            "\t\t}",
            "\t\tdata = freq;",
            "\t\tfor(auto i = 1; i <= len; ++ i) if(i + (i & -i) <= len) data[i + (i & -i) - 1] += data[i - 1];",
            "\t}",
            "\tintegral_multiset(const integral_multiset &otr): _size(otr._size), offset(otr.offset), maxval(otr.maxval), freq(otr.freq), data(otr.data){",
            "\t}",
            "\tvector<T> to_array() const{",
            "\t\tvector<T> res;",
            "\t\tfor(auto x = offset; x < maxval; ++ x) for(auto rep = 0; rep < freq[x]; ++ rep) res.push_back(x);",
            "\t\treturn res;",
            "\t}",
            "\tfriend ostream &operator<<(ostream &out, const integral_multiset &ms){",
            "\t\tauto a = ms.to_array();",
            "\t\tout << \"{\";",
            "\t\tfor(auto i = 0; i < (int)a.size(); ++ i){",
            "\t\t\tout << a[i];",
            "\t\t\tif(i + 1 < (int)a.size()) out << \", \";",
            "\t\t}",
            "\t\treturn out << \"}\";",
            "\t}",
            "\t// O(1)",
            "\tint size() const{",
            "\t\treturn _size;",
            "\t}",
            "\t// O(1)",
            "\tbool empty() const{",
            "\t\treturn !_size;",
            "\t}",
            "\t// O(1)",
            "\tbool contains(T x) const{",
            "\t\tassert(offset <= x && x < maxval);",
            "\t\treturn freq[x - offset];",
            "\t}",
            "\t// O(1)",
            "\tint count(T x) const{",
            "\t\tassert(offset <= x && x < maxval);",
            "\t\treturn freq[x - offset];",
            "\t}",
            "\t// O(log(len))",
            "\tvoid insert(T x){",
            "\t\tassert(offset <= x && x < maxval);",
            "\t\t++ _size;",
            "\t\t++ freq[x - offset];",
            "\t\tfor(auto p = x - offset + 1; p <= len; p += p & -p) ++ data[p - 1];",
            "\t}",
            "\t// O(log(len)) if true, O(1) otherwise",
            "\tbool erase(T x){",
            "\t\tassert(offset <= x && x < maxval);",
            "\t\tif(freq[x - offset]){",
            "\t\t\t-- _size;",
            "\t\t\t-- freq[x - offset];",
            "\t\t\tfor(auto p = x - offset + 1; p <= len; p += p & -p) -- data[p - 1];",
            "\t\t\treturn true;",
            "\t\t}",
            "\t\treturn false;",
            "\t}",
            "\t// O(log(len))",
            "\tT find_by_order(int k) const{",
            "\t\tif(k < 0) return offset - 1;",
            "\t\tif(k >= _size) return maxval;",
            "\t\tint p = 0;",
            "\t\tfor(auto i = __lg(len + 1), sum = 0; i >= 0; -- i) if(p + (1 << i) <= len && sum + data[p + (1 << i) - 1] <= k){",
            "\t\t\tsum += data[p + (1 << i) - 1];",
            "\t\t\tp += 1 << i;",
            "\t\t}",
            "\t\treturn p + offset;",
            "\t}",
            "\t// O(log(len))",
            "\tint order_of_key(T x) const{",
            "\t\tif(x < offset) return 0;",
            "\t\tif(maxval <= x) return _size;",
            "\t\tint sum = 0;",
            "\t\tfor(auto r = x - offset; r > 0; r -= r & -r) sum += data[r - 1];",
            "\t\treturn sum;",
            "\t}",
            "\t// O(log(len))",
            "\tT front() const{",
            "\t\tassert(_size);",
            "\t\treturn find_by_order(0) + offset;",
            "\t}",
            "\t// O(log(len))",
            "\tT back() const{",
            "\t\tassert(_size);",
            "\t\treturn find_by_order(_size - 1) + offset;",
            "\t}",
            "\t// Returns maxval if no such element",
            "\t// O(log(len))",
            "\tT lower_bound(T x) const{",
            "\t\tint sum = 0;",
            "\t\tfor(auto r = x - offset; r > 0; r -= r & -r) sum += data[r - 1];",
            "\t\treturn find_by_order(sum);",
            "\t}",
            "\t// O(log(len)), returns maxval if no such element",
            "\tT upper_bound(T x) const{",
            "\t\tint sum = 0;",
            "\t\tfor(auto r = x - offset + 1; r > 0; r -= r & -r) sum += data[r - 1];",
            "\t\treturn find_by_order(sum);",
            "\t}",
            "\t// Returns minval if no such element",
            "\t// O(log(len))",
            "\tT reverse_lower_bound(T x) const{",
            "\t\tint sum = 0;",
            "\t\tfor(auto r = x - offset + 1; r > 0; r -= r & -r) sum += data[r - 1];",
            "\t\treturn find_by_order(sum - 1);",
            "\t}",
            "\t// Returns minval if no such element",
            "\t// O(log(len))",
            "\tT reverse_upper_bound(T x) const{",
            "\t\tint sum = 0;",
            "\t\tfor(auto r = x - offset; r > 0; r -= r & -r) sum += data[r - 1];",
            "\t\treturn find_by_order(sum - 1);",
            "\t}",
            "};"
        ],
        "description": "tranxuanbach"
    }
}