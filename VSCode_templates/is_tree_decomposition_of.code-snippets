{
    "tranxuanbach": {
        "prefix": "is_tree_decomposition_of",
        "body": [
            "// O(n * w^2) where w is the width of the decomposition",
            "// Requires graph and disjoint_set",
            "template<class T>",
            "bool is_tree_decomposition_of(const graph<T> &g, const vector<vector<int>> &bag, const vector<array<int, 2>> &edge){",
            "\tif(bag.empty()) return false;",
            "\tint n = g.n;",
            "\tfor(auto b: bag){",
            "\t\tif(b.empty() || !is_sorted(b.begin(), b.end())) return false;",
            "\t\tint s = (int)b.size();",
            "\t\tb.erase(unique(b.begin(), b.end()), b.end());",
            "\t\tif((int)b.size() != s) return false;",
            "\t\tif(b.front() < 0 || n <= b.back()) return false;",
            "\t}",
            "\tif((int)edge.size() != (int)bag.size() - 1) return false;",
            "\tdisjoint_set dsu((int)bag.size());",
            "\tvector<vector<int>> adj((int)bag.size());",
            "\tfor(auto [u, v]: edge){",
            "\t\tif(min(u, v) < 0 || (int)bag.size() <= max(u, v) || u == v) return false;",
            "\t\tif(!dsu.merge(u, v)) return false;",
            "\t\tadj[u].push_back(v);",
            "\t\tadj[v].push_back(u);",
            "\t}",
            "\tvector<vector<int>> belong(n);",
            "\tfor(auto i = 0; i < (int)bag.size(); ++ i) for(auto u: bag[i]) belong[u].push_back(i);",
            "\tdsu.clear();",
            "\tvector<int> flag((int)bag.size(), -1);",
            "\tfor(auto u = 0; u < n; ++ u){",
            "\t\tfor(auto i: belong[u]) flag[i] = u;",
            "\t\tfor(auto i: belong[u]) for(auto j: adj[i]) if(flag[j] == u) dsu.merge(i, j);",
            "\t\tif(dsu.size(belong[u][0]) != (int)belong[u].size()){",
            "\t\t\treturn false;",
            "\t\t}",
            "\t\tfor(auto i: belong[u]) dsu.p[i] = -1;",
            "\t\tdsu._classes = n;",
            "\t}",
            "\tauto gadj = g.get_adjacency_list();",
            "\tvector<vector<int>> check(n);",
            "\tfor(auto u = 0; u < n; ++ u){",
            "\t\tgadj[u].erase(unique(gadj[u].begin(), gadj[u].end()), gadj[u].end());",
            "\t\tcheck[u].resize((int)gadj[u].size());",
            "\t}",
            "\tfor(auto b: bag) for(auto i = 0; i < (int)b.size(); ++ i){",
            "\t\tint u = b[i];",
            "\t\tfor(auto j = i + 1; j < (int)b.size(); ++ j){",
            "\t\t\tint v = b[j];",
            "\t\t\tif(binary_search(gadj[u].begin(), gadj[u].end(), v)){",
            "\t\t\t\tcheck[u][lower_bound(gadj[u].begin(), gadj[u].end(), v) - gadj[u].begin()] = true;",
            "\t\t\t\tcheck[v][lower_bound(gadj[v].begin(), gadj[v].end(), u) - gadj[v].begin()] = true;",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "\tfor(auto u = 0; u < n; ++ u) if(find(check[u].begin(), check[u].end(), false) != check[u].end()) return false;",
            "\treturn true;",
            "}"
        ],
        "description": "tranxuanbach"
    }
}