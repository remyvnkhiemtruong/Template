{
    "tranxuanbach": {
        "prefix": "suffix_array",
        "body": [
            "struct suffix_array{",
            "\tvector<int> sa_naive(const vector<int> &s){",
            "\t\tint n = (int)s.size();",
            "\t\tvector<int> sa(n);",
            "\t\tiota(sa.begin(), sa.end(), 0);",
            "\t\tsort(sa.begin(), sa.end(), [&](int l, int r){",
            "\t\t\tif(l == r) return false;",
            "\t\t\tfor(; l < n && r < n; ++ l, ++ r) if(s[l] != s[r]) return s[l] < s[r];",
            "\t\t\treturn l == n;",
            "\t\t});",
            "\t\treturn sa;",
            "\t}",
            "\tvector<int> sa_doubling(const vector<int> &s){",
            "\t\tint n = (int)s.size();",
            "\t\tvector<int> sa(n), pos = s, tmp(n);",
            "\t\tiota(sa.begin(), sa.end(), 0);",
            "\t\tfor(auto k = 1; k < n; k <<= 1){",
            "\t\t\tauto cmp = [&](int x, int y){",
            "\t\t\t\tif(pos[x] != pos[y]) return pos[x] < pos[y];",
            "\t\t\t\tint rx = x + k < n ? pos[x + k] : -1;",
            "\t\t\t\tint ry = y + k < n ? pos[y + k] : -1;",
            "\t\t\t\treturn rx < ry;",
            "\t\t\t};",
            "\t\t\tsort(sa.begin(), sa.end(), cmp);",
            "\t\t\ttmp[sa[0]] = 0;",
            "\t\t\tfor(auto i = 1; i < n; ++ i) tmp[sa[i]] = tmp[sa[i - 1]] + (cmp(sa[i - 1], sa[i]) ? 1 : 0);",
            "\t\t\tswap(tmp, pos);",
            "\t\t}",
            "\t\treturn sa;",
            "\t}",
            "\ttemplate<int THRESHOLD_NAIVE = 10, int THRESHOLD_DOUBLING = 40>",
            "\tvector<int> sa_is(const vector<int> &s, int sigma){",
            "\t\tint n = (int)s.size();",
            "\t\tif(n == 0) return {};",
            "\t\tif(n == 1) return {0};",
            "\t\tif(n == 2){",
            "\t\t\tif(s[0] < s[1]) return {0, 1};",
            "\t\t\telse return {1, 0};",
            "\t\t}",
            "\t\tif(n < THRESHOLD_NAIVE) return sa_naive(s);",
            "\t\tif(n < THRESHOLD_DOUBLING) return sa_doubling(s);",
            "\t\tvector<int> sa(n);",
            "\t\tvector<bool> ls(n);",
            "\t\tfor(auto i = n - 2; i >= 0; -- i) ls[i] = (s[i] == s[i + 1]) ? ls[i + 1] : (s[i] < s[i + 1]);",
            "\t\tvector<int> sum_l(sigma), sum_s(sigma);",
            "\t\tfor(auto i = 0; i < n; ++ i){",
            "\t\t\tif(!ls[i]) ++ sum_s[s[i]];",
            "\t\t\telse ++ sum_l[s[i] + 1];",
            "\t\t}",
            "\t\tfor(auto i = 0; i < sigma; ++ i){",
            "\t\t\tsum_s[i] += sum_l[i];",
            "\t\t\tif(i + 1 < sigma) sum_l[i + 1] += sum_s[i];",
            "\t\t}",
            "\t\tauto induce = [&](const vector<int> &lms){",
            "\t\t\tfill(sa.begin(), sa.end(), -1);",
            "\t\t\tvector<int> buf(sigma);",
            "\t\t\tcopy(sum_s.begin(), sum_s.end(), buf.begin());",
            "\t\t\tfor(auto d: lms){",
            "\t\t\t\tif(d == n) continue;",
            "\t\t\t\tsa[buf[s[d]] ++] = d;",
            "\t\t\t}",
            "\t\t\tcopy(sum_l.begin(), sum_l.end(), buf.begin());",
            "\t\t\tsa[buf[s[n - 1]] ++] = n - 1;",
            "\t\t\tfor(auto i = 0; i < n; ++ i){",
            "\t\t\t\tint v = sa[i];",
            "\t\t\t\tif(v >= 1 && !ls[v - 1]) sa[buf[s[v - 1]] ++] = v - 1;",
            "\t\t\t}",
            "\t\t\tcopy(sum_l.begin(), sum_l.end(), buf.begin());",
            "\t\t\tfor(auto i = n - 1; i >= 0; -- i){",
            "\t\t\t\tint v = sa[i];",
            "\t\t\t\tif(v >= 1 && ls[v - 1]) sa[-- buf[s[v - 1] + 1]] = v - 1;",
            "\t\t\t}",
            "\t\t};",
            "\t\tvector<int> lms_map(n + 1, -1);",
            "\t\tint m = 0;",
            "\t\tfor(auto i = 1; i < n; ++ i) if(!ls[i - 1] && ls[i]) lms_map[i] = m ++;",
            "\t\tvector<int> lms;",
            "\t\tlms.reserve(m);",
            "\t\tfor(auto i = 1; i < n; ++ i) if(!ls[i - 1] && ls[i]) lms.push_back(i);",
            "\t\tinduce(lms);",
            "\t\tif(m){",
            "\t\t\tvector<int> sorted_lms;",
            "\t\t\tsorted_lms.reserve(m);",
            "\t\t\tfor(auto v: sa) if(lms_map[v] != -1) sorted_lms.push_back(v);",
            "\t\t\tvector<int> rec_s(m);",
            "\t\t\tint rec_sigma = 0;",
            "\t\t\trec_s[lms_map[sorted_lms[0]]] = 0;",
            "\t\t\tfor(auto i = 1; i < m; ++ i){",
            "\t\t\t\tint l = sorted_lms[i - 1], r = sorted_lms[i];",
            "\t\t\t\tint end_l = (lms_map[l] + 1 < m) ? lms[lms_map[l] + 1] : n;",
            "\t\t\t\tint end_r = (lms_map[r] + 1 < m) ? lms[lms_map[r] + 1] : n;",
            "\t\t\t\tbool same = true;",
            "\t\t\t\tif(end_l - l != end_r - r) same = false;",
            "\t\t\t\telse{",
            "\t\t\t\t\tfor(; l < end_l; ++ l, ++ r) if (s[l] != s[r]) break;",
            "\t\t\t\t\tif(l == n || s[l] != s[r]) same = false;",
            "\t\t\t\t}",
            "\t\t\t\tif(!same) ++ rec_sigma;",
            "\t\t\t\trec_s[lms_map[sorted_lms[i]]] = rec_sigma;",
            "\t\t\t}",
            "\t\t\tauto rec_sa = sa_is<THRESHOLD_NAIVE, THRESHOLD_DOUBLING>(rec_s, rec_sigma + 1);",
            "\t\t\tfor(auto i = 0; i < m; ++ i) sorted_lms[i] = lms[rec_sa[i]];",
            "\t\t\tinduce(sorted_lms);",
            "\t\t}",
            "\t\treturn sa;",
            "\t}",
            "\tint n;",
            "\t// data: sorted sequence of suffices including the empty suffix",
            "\t// pos[i]: position of the suffix i in the suffix array",
            "\t// lcp[i]: longest common prefix of data[i] and data[i + 1]",
            "\tvector<int> data, pos, lcp;",
            "\t// O(n + sigma)",
            "\tsuffix_array(const vector<int> &s, int sigma): n((int)s.size()), pos(n + 1), lcp(n){",
            "\t\tassert(0 <= sigma);",
            "\t\tfor(auto d: s) assert(0 <= d && d < sigma);",
            "\t\tdata = sa_is(s, sigma);",
            "\t\tdata.insert(data.begin(), n);",
            "\t\tfor(auto i = 0; i <= n; ++ i) pos[data[i]] = i;",
            "\t\tfor(auto i = 0, h = 0; i <= n; ++ i){",
            "\t\t\tif(h > 0) -- h;",
            "\t\t\tif(pos[i] == 0) continue;",
            "\t\t\tint j = data[pos[i] - 1];",
            "\t\t\tfor(; j + h <= n && i + h <= n; ++ h) if((j + h == n) != (i + h == n) || j + h < n && s[j + h] != s[i + h]) break;",
            "\t\t\tlcp[pos[i] - 1] = h;",
            "\t\t}",
            "\t}",
            "\t// O(n * log(n)) time, O(n) space",
            "\ttemplate<class T>",
            "\tsuffix_array(const vector<T> &s): n((int)s.size()), pos(n + 1), lcp(n){",
            "\t\tvector<int> idx(n);",
            "\t\tiota(idx.begin(), idx.end(), 0);",
            "\t\tsort(idx.begin(), idx.end(), [&](int l, int r){ return s[l] < s[r]; });",
            "\t\tvector<int> s2(n);",
            "\t\tint now = 0;",
            "\t\tfor(auto i = 0; i < n; ++ i){",
            "\t\t\tif(i && s[idx[i - 1]] != s[idx[i]]) ++ now;",
            "\t\t\ts2[idx[i]] = now;",
            "\t\t}",
            "\t\tdata = sa_is(s2, now + 1);",
            "\t\tdata.insert(data.begin(), n);",
            "\t\tfor(auto i = 0; i <= n; ++ i) pos[data[i]] = i;",
            "\t\tfor(auto i = 0, h = 0; i <= n; ++ i){",
            "\t\t\tif(h > 0) -- h;",
            "\t\t\tif(pos[i] == 0) continue;",
            "\t\t\tint j = data[pos[i] - 1];",
            "\t\t\tfor(; j + h <= n && i + h <= n; ++ h) if((j + h == n) != (i + h == n) || j + h < n && s[j + h] != s[i + h]) break;",
            "\t\t\tlcp[pos[i] - 1] = h;",
            "\t\t}",
            "\t}",
            "\t// rmq must be built over lcp",
            "\t// O(1)",
            "\ttemplate<class RangeMinQuery_t>",
            "\tint longest_common_prefix(int i, int j, const RangeMinQuery_t &rmq) const{",
            "\t\tassert(0 <= i && i <= n && 0 <= j && j <= n);",
            "\t\treturn i == j ? n - i : rmq.query(min(pos[i], pos[j]), max(pos[i], pos[j]));",
            "\t}",
            "\t// rmq must be built over lcp",
            "\t// Compares s[p, p + len) and s[q, q + len)",
            "\t// O(1)",
            "\ttemplate<class RangeMinQuery_t>",
            "\tbool compare(int p, int q, int len, const RangeMinQuery_t &rmq) const{",
            "\t\tassert(0 <= min({p, q, len}) && p + len <= n && q + len <= n);",
            "\t\tif(len == 0 || p == q) return false;",
            "\t\tint common_len = longest_common_prefix(p, q, rmq);",
            "\t\tif(common_len >= len) return false;",
            "\t\treturn data[p] < data[q];",
            "\t}",
            "};"
        ],
        "description": "tranxuanbach"
    }
}