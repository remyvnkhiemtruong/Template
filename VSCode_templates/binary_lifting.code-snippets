{
    "tranxuanbach": {
        "prefix": "binary_lifting",
        "body": [
            "template<int h = 20>",
            "struct binary_lifting{",
            "\tint n = 0;",
            "\tvector<int> depth;",
            "\tvector<array<int, h>> lift;",
            "\tbinary_lifting(){ }",
            "\t// pv: parent vertex (-1 if root of an arborescence)",
            "\tbinary_lifting(const vector<int> &pv): n((int)pv.size()), depth(n, numeric_limits<int>::max()), lift(n){",
            "\t\tfor(auto u = 0; u < n; ++ u) lift[u][0] = ~pv[u] ? pv[u] : u;",
            "\t\tfor(auto bit = 1; bit < h; ++ bit) for(auto u = 0; u < n; ++ u) lift[u][bit] = lift[lift[u][bit - 1]][bit - 1];",
            "\t}",
            "\t// Requires graph",
            "\ttemplate<class Graph>",
            "\tbinary_lifting(const Graph &g, const vector<int> &roots){",
            "\t\tvector<int> pv(g.n, -1), depth(g.n);",
            "\t\tauto dfs = [&](auto self, int u, int pe)->void{",
            "\t\t\tfor(auto id: g.adj[u]){",
            "\t\t\t\tif(id == pe || g.ignore && g.ignore(id)) continue;",
            "\t\t\t\tauto &e = g.edge[id];",
            "\t\t\t\tint v = u ^ e.from ^ e.to;",
            "\t\t\t\tdepth[v] = depth[u] + 1;",
            "\t\t\t\tpv[v] = u;",
            "\t\t\t\tself(self, v, id);",
            "\t\t\t}",
            "\t\t};",
            "\t\tfor(auto u: roots) assert(!depth[u]), pv[u] = u, dfs(dfs, u, -1);",
            "\t\t*this = binary_lifting(pv, depth);",
            "\t}",
            "\t// pv: parent vertex (-1 if root of an arborescence)",
            "\tbinary_lifting(const vector<int> &pv, const vector<int> &depth): n((int)pv.size()), depth(depth){",
            "\t\tlift.resize(n);",
            "\t\tfor(auto u = 0; u < n; ++ u) lift[u][0] = ~pv[u] ? pv[u] : u;",
            "\t\tfor(auto d = 1; d < h; ++ d) for(auto u = 0; u < n; ++ u) lift[u][d] = lift[lift[u][d - 1]][d - 1];",
            "\t}",
            "\t// Index becomes the current number of nodes",
            "\t// O(log n)",
            "\tint add_root(){",
            "\t\tint u = n ++;",
            "\t\tdepth.push_back(0);",
            "\t\tlift.emplace_back();",
            "\t\tfill(lift.back().begin(), lift.back().end(), u);",
            "\t\treturn u;",
            "\t}",
            "\t// Index becomes the current number of nodes",
            "\t// O(log n)",
            "\tint add_child(int p){",
            "\t\tassert(0 <= p && p < n);",
            "\t\tint u = n ++;",
            "\t\tdepth.push_back(depth[p] + 1);",
            "\t\tlift.emplace_back();",
            "\t\tlift[u][0] = p;",
            "\t\tfor(auto d = 1; d < h; ++ d) lift[u][d] = lift[lift[u][d - 1]][d - 1];",
            "\t}",
            "\t// Get the k-th ancestor of u",
            "\t// O(log n)",
            "\tint ancestor(int u, int k) const{",
            "\t\tfor(auto d = 0; d < h; ++ d) if(k & 1 << d) u = lift[u][d];",
            "\t\treturn u;",
            "\t}",
            "\t// Assumes u and v lies on the same arboresence",
            "\t// O(log n)",
            "\tint lca(int u, int v) const{",
            "\t\tif(depth[u] < depth[v]) swap(u, v);",
            "\t\tu = ancestor(u, depth[u] - depth[v]);",
            "\t\tif(u == v) return u;",
            "\t\tfor(auto d = h - 1; d >= 0; -- d) if(lift[u][d] != lift[v][d]) u = lift[u][d], v = lift[v][d];",
            "\t\treturn lift[u][0];",
            "\t}",
            "\t// Get # of edges between u and v",
            "\t// Assumes u and v lies on the same arboresence",
            "\t// O(log n)",
            "\tint steps(int u, int v, int w = -1) const{",
            "\t\treturn depth[u] + depth[v] - 2 * depth[~w ? w : lca(u, v)];",
            "\t}",
            "\t// For an ancestor p of u, pred(p) is T, ..., T, F, ..., F in decreasing order of depth. Returns the highest p with T",
            "\t// O(log n)",
            "\tint find_highest(int u, auto pred) const{",
            "\t\tassert(pred(u));",
            "\t\tfor(auto d = h - 1; d >= 0; -- d) if(pred(lift[u][d])) u = lift[u][d];",
            "\t\treturn u;",
            "\t}",
            "};"
        ],
        "description": "tranxuanbach"
    }
}