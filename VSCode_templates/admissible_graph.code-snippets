{
    "tranxuanbach": {
        "prefix": "admissible_graph",
        "body": [
            "// Corrected version of the construction presented in http://www.math.ucsd.edu/~fan/mypaps/fanpap/fc35universal_trees.pdf",
            "struct admissible_graph{",
            "\tint n;",
            "\tvector<array<int, 2>> next;",
            "\tvector<int> size, pv;",
            "\t// The graph with O(n * log(n)^2) edges and n vertices which has a spanning tree isomorphic to every possible tree on n vertices",
            "\t// O(n)",
            "\tadmissible_graph(int n): n(n){",
            "\t\tassert(n >= 1);",
            "\t\tauto build = [&](auto self, int n)->int{",
            "\t\t\tif(!n) return -1;",
            "\t\t\tint u = (int)next.size();",
            "\t\t\tnext.push_back({-1, -1});",
            "\t\t\tsize.push_back(n);",
            "\t\t\tpv.push_back(-1);",
            "\t\t\tif(n == 1) return u;",
            "\t\t\tint k = __lg(n), left = min(n, 1 << k) - 1;",
            "\t\t\tnext[u][0] = self(self, left);",
            "\t\t\tpv[next[u][0]] = u;",
            "\t\t\tif(left + 1 == n) return u;",
            "\t\t\tnext[u][1] = self(self, n - left - 1);",
            "\t\t\tpv[next[u][1]] = u;",
            "\t\t\treturn u;",
            "\t\t};",
            "\t\tbuild(build, n);",
            "\t}",
            "\t// -1: root, 0: left, 1: right",
            "\t// O(1)",
            "\tint side(int u) const{",
            "\t\tassert(0 <= u && u < n);",
            "\t\treturn u ? next[pv[u]][1] == u : -1;",
            "\t}",
            "\tvector<array<int, 2>> get_edge() const{",
            "\t\tvector<array<int, 2>> res;",
            "\t\tvector<int> q(n), path;",
            "\t\tfor(auto u = 0; u < n; ++ u){",
            "\t\t\tint beg = 0, end = 0;",
            "\t\t\tfor(auto i = 0; i < 2; ++ i) if(~next[u][i]) q[end ++] = next[u][i];",
            "\t\t\tpath.clear();",
            "\t\t\tfor(auto w = u; w; w = pv[w]){",
            "\t\t\t\tpath.push_back(next[pv[w]][1] == w);",
            "\t\t\t\tif(!path.back()) continue;",
            "\t\t\t\tint v = pv[w];",
            "\t\t\t\tfor(auto i = (int)path.size() - 1; i >= 0; -- i) v = next[v][!path[i]];",
            "\t\t\t\tq[end ++] = (int)path.size() >= 2 ? pv[v] : v;",
            "\t\t\t}",
            "\t\t\twhile(beg < end){",
            "\t\t\t\tint v = q[beg ++];",
            "\t\t\t\tres.push_back({u, v});",
            "\t\t\t\tfor(auto i = 0; i < 2; ++ i) if(~next[v][i]) q[end ++] = next[v][i];",
            "\t\t\t}",
            "\t\t}",
            "\t\treturn res;",
            "\t}",
            "\t// tr must be a tree",
            "\t// Returns an embedding E such that G - E(tr) is admissible.",
            "\t// O(n^2 + m^2)",
            "\tvector<int> embed(vector<vector<int>> tree){",
            "\t\tint m = (int)tree.size();",
            "\t\tassert(1 <= m && m <= n);",
            "\t\tauto erase = [&](vector<int> &a, int x)->void{",
            "\t\t\tauto it = find(a.begin(), a.end(), x);",
            "\t\t\tassert(it != a.end() && *it == x);",
            "\t\t\ta.erase(it);",
            "\t\t};",
            "\t\tauto cut = [&](vector<int> &tree_vertices, int u)->void{",
            "\t\t\terase(tree_vertices, u);",
            "\t\t\tfor(auto v : tree[u]) erase(tree[v], u);",
            "\t\t\tfor(auto i = 1; i < (int)tree[u].size(); ++i) {",
            "\t\t\t\tint x = tree[u][0], y = tree[u][i];",
            "\t\t\t\ttree[x].insert(find(tree[x].begin(), tree[x].end(), y), y);",
            "\t\t\t\ttree[y].insert(find(tree[y].begin(), tree[y].end(), x), x);",
            "\t\t\t}",
            "\t\t\ttree[u].clear();",
            "\t\t};",
            "\t\tvector<int> tree_size(n);",
            "\t\tauto get_small_subtrees = [&](const vector<int> &tree_vertices, int k)->pair<int, vector<int>>{",
            "\t\t\tassert(1 <= k && k < (int)tree_vertices.size());",
            "\t\t\tif((int)tree_vertices.size() == k + 1) return {tree_vertices[0], tree[tree_vertices[0]]};",
            "\t\t\tint root = -1;",
            "\t\t\tfor(auto u: tree_vertices){",
            "\t\t\t\ttree_size[u] = 1;",
            "\t\t\t\tif(!~root && (int)tree[u].size() == 1) root = u;",
            "\t\t\t}",
            "\t\t\tassert(~root);",
            "\t\t\tauto dfs = [&](auto self, int u, int p)->void{",
            "\t\t\t\tfor(auto v: tree[u]) if(v != p){",
            "\t\t\t\t\tself(self, v, u);",
            "\t\t\t\t\ttree_size[u] += tree_size[v];",
            "\t\t\t\t}",
            "\t\t\t};",
            "\t\t\tdfs(dfs, root, -1);",
            "\t\t\tfor(auto u = tree[root][0]; ;){",
            "\t\t\t\tassert(tree_size[u] >= k + 1);",
            "\t\t\t\tint big = -1;",
            "\t\t\t\tfor(auto v: tree[u]){",
            "\t\t\t\t\tif(v == root) continue;",
            "\t\t\t\t\tif(tree_size[v] == k) return {u, {v}};",
            "\t\t\t\t\tif(tree_size[v] >= k + 1){",
            "\t\t\t\t\t\tbig = v;",
            "\t\t\t\t\t\tbreak;",
            "\t\t\t\t\t}",
            "\t\t\t\t}",
            "\t\t\t\tif(!~big){",
            "\t\t\t\t\tvector<int> a = tree[u];",
            "\t\t\t\t\terase(a, root);",
            "\t\t\t\t\tint sum = accumulate(a.begin(), a.end(), 0, [&](int x, int u){ return x + tree_size[u]; });",
            "\t\t\t\t\twhile(sum >= 2 * k){",
            "\t\t\t\t\t\tsum -= tree_size[a.back()];",
            "\t\t\t\t\t\ta.pop_back();",
            "\t\t\t\t\t}",
            "\t\t\t\t\treturn {u, a};",
            "\t\t\t\t}",
            "\t\t\t\troot = u;",
            "\t\t\t\tu = big;",
            "\t\t\t}",
            "\t\t\tassert(false);",
            "\t\t};",
            "\t\tvector<int> was(n);",
            "\t\tauto cut_small_subtrees = [&](const vector<int> &tree_vertices, int k)->array<vector<int>, 2>{",
            "\t\t\tauto [u, roots] = get_small_subtrees(tree_vertices, k);",
            "\t\t\tstatic int it = 0;",
            "\t\t\t++ it;",
            "\t\t\tvector<int> small{u}, large;",
            "\t\t\twas[u] = it;",
            "\t\t\tfor(auto r: roots){",
            "\t\t\t\tauto dfs = [&](auto self, int u)->void{",
            "\t\t\t\t\twas[u] = it;",
            "\t\t\t\t\tsmall.push_back(u);",
            "\t\t\t\t\tfor(auto v: tree[u]) if(was[v] != it) self(self, v);",
            "\t\t\t\t};",
            "\t\t\t\tdfs(dfs, r);",
            "\t\t\t}",
            "\t\t\tint w = -1;",
            "\t\t\tfor(auto v: tree[u]) if(was[v] != it){",
            "\t\t\t\tif(~w){",
            "\t\t\t\t\ttree[w].push_back(v);",
            "\t\t\t\t\ttree[v].push_back(w);",
            "\t\t\t\t}",
            "\t\t\t\telse w = v;",
            "\t\t\t\terase(tree[v], u);",
            "\t\t\t}",
            "\t\t\ttree[u].erase(remove_if(tree[u].begin(), tree[u].end(), [&](int v){ return was[v] != it; }), tree[u].end());",
            "\t\t\tfor(auto v: tree_vertices) if(was[v] != it) large.push_back(v);",
            "\t\t\treturn {small, large};",
            "\t\t};",
            "\t\tvector<int> mapped(n, false);",
            "\t\tvector<int> res(m, -1);",
            "\t\t// tree vertex, graph vertex",
            "\t\tauto set_res = [&](int u, int v)->void{",
            "\t\t\tassert(0 <= u && u < m);",
            "\t\t\tassert(0 <= v && v < n);",
            "\t\t\tassert(!~res[u]);",
            "\t\t\tassert(!mapped[v]);",
            "\t\t\tres[u] = v;",
            "\t\t\tmapped[v] = true;",
            "\t\t};",
            "\t\t// graph vertex",
            "\t\tauto valid = [&](int u)->bool{",
            "\t\t\treturn ~u && !mapped[u];",
            "\t\t};",
            "\t\t// graph vertex",
            "\t\tvector<int> q(n);",
            "\t\tauto get_size = [&](int u)->int{",
            "\t\t\tassert(~u && valid(u));",
            "\t\t\tint res = 0;",
            "\t\t\tq[0] = u;",
            "\t\t\tfor(auto end = 1; res < end; ){",
            "\t\t\t\tint u = q[res ++];",
            "\t\t\t\tfor(auto i = 0; i < 2; ++ i) if(valid(next[u][i])) q[end ++] = next[u][i];",
            "\t\t\t}",
            "\t\t\treturn res;",
            "\t\t};",
            "\t\tauto solve = [&](auto self, int root, int u, vector<int> tree_vertices)->void{",
            "\t\t\tint m = (int)tree_vertices.size();",
            "\t\t\tassert(~root);",
            "\t\t\tint root_size = get_size(root), left = next[root][0], right = next[root][1];",
            "\t\t\tassert(1 <= m && m <= root_size);",
            "\t\t\tassert(find(tree_vertices.begin(), tree_vertices.end(), u) != tree_vertices.end());",
            "\t\t\tif(m == 1){",
            "\t\t\t\twhile(true){",
            "\t\t\t\t\tif(valid(next[root][1])) root = next[root][1];",
            "\t\t\t\t\telse if(valid(next[root][0])) root = next[root][0];",
            "\t\t\t\t\telse break;",
            "\t\t\t\t}",
            "\t\t\t\tset_res(u, root);",
            "\t\t\t}",
            "\t\t\telse if(!valid(right)){",
            "\t\t\t\tassert(valid(left));",
            "\t\t\t\tif(m < root_size){",
            "\t\t\t\t\tself(self, left, u, tree_vertices);",
            "\t\t\t\t}",
            "\t\t\t\telse{",
            "\t\t\t\t\tassert(m == root_size);",
            "\t\t\t\t\tcut(tree_vertices, u);",
            "\t\t\t\t\tself(self, left, tree_vertices[0], tree_vertices);",
            "\t\t\t\t\tset_res(u, root);",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t\telse{",
            "\t\t\t\tassert(valid(left) && valid(right));",
            "\t\t\t\tint right_size = get_size(right);",
            "\t\t\t\tif(m <= right_size){",
            "\t\t\t\t\tself(self, right, u, tree_vertices);",
            "\t\t\t\t}",
            "\t\t\t\telse{",
            "\t\t\t\t\tif(right_size == 1){",
            "\t\t\t\t\t\tcut(tree_vertices, u);",
            "\t\t\t\t\t\tset_res(u, right);",
            "\t\t\t\t\t\tself(self, root, tree_vertices[0], tree_vertices);",
            "\t\t\t\t\t}",
            "\t\t\t\t\telse if(!valid(next[right][1])){",
            "\t\t\t\t\t\tassert(valid(next[right][0]));",
            "\t\t\t\t\t\tif(m < root_size){",
            "\t\t\t\t\t\t\tcut(tree_vertices, u);",
            "\t\t\t\t\t\t\tauto [small, large] = cut_small_subtrees(tree_vertices, get_size(next[right][0]));",
            "\t\t\t\t\t\t\t{",
            "\t\t\t\t\t\t\t\tauto _nextright = next[right];",
            "\t\t\t\t\t\t\t\tnext[right] = { next[left][1], next[right][0] };",
            "\t\t\t\t\t\t\t\tself(self, right, small[0], small);",
            "\t\t\t\t\t\t\t\tnext[right] = _nextright;",
            "\t\t\t\t\t\t\t}",
            "\t\t\t\t\t\t\tset_res(u, right);",
            "\t\t\t\t\t\t\tif(!large.empty()) self(self, root, large[0], large);",
            "\t\t\t\t\t\t}",
            "\t\t\t\t\t\telse{",
            "\t\t\t\t\t\t\tassert(m == root_size);",
            "\t\t\t\t\t\t\tcut(tree_vertices, u);",
            "\t\t\t\t\t\t\tself(self, root, tree_vertices[0], tree_vertices);",
            "\t\t\t\t\t\t\tset_res(u, root);",
            "\t\t\t\t\t\t}",
            "\t\t\t\t\t}",
            "\t\t\t\t\telse{",
            "\t\t\t\t\t\tassert(valid(left) && valid(right));",
            "\t\t\t\t\t\tif(m < root_size){",
            "\t\t\t\t\t\t\tcut(tree_vertices, u);",
            "\t\t\t\t\t\t\tauto[small, large] = cut_small_subtrees(tree_vertices, get_size(next[right][1]));",
            "\t\t\t\t\t\t\t{",
            "\t\t\t\t\t\t\t\tself(self, right, small[0], small);",
            "\t\t\t\t\t\t\t}",
            "\t\t\t\t\t\t\tif(!large.empty()){",
            "\t\t\t\t\t\t\t\tif(valid(next[right][0])){",
            "\t\t\t\t\t\t\t\t\tauto[small2, large2] = cut_small_subtrees(large, get_size(next[right][0]));",
            "\t\t\t\t\t\t\t\t\t{",
            "\t\t\t\t\t\t\t\t\t\tauto _nextright = next[right];",
            "\t\t\t\t\t\t\t\t\t\tnext[right] = {next[left][1], next[right][0]};",
            "\t\t\t\t\t\t\t\t\t\tself(self, right, small2[0], small2);",
            "\t\t\t\t\t\t\t\t\t\tnext[right] = _nextright;",
            "\t\t\t\t\t\t\t\t\t}",
            "\t\t\t\t\t\t\t\t\tset_res(u, right);",
            "\t\t\t\t\t\t\t\t\tif(!large2.empty()){",
            "\t\t\t\t\t\t\t\t\t\tself(self, root, large2[0], large2);",
            "\t\t\t\t\t\t\t\t\t}",
            "\t\t\t\t\t\t\t\t}",
            "\t\t\t\t\t\t\t\telse{",
            "\t\t\t\t\t\t\t\t\tset_res(u, right);",
            "\t\t\t\t\t\t\t\t\tself(self, root, large[0], large);",
            "\t\t\t\t\t\t\t\t}",
            "\t\t\t\t\t\t\t}",
            "\t\t\t\t\t\t}",
            "\t\t\t\t\t\telse{",
            "\t\t\t\t\t\t\tassert(m == root_size);",
            "\t\t\t\t\t\t\tcut(tree_vertices, u);",
            "\t\t\t\t\t\t\tself(self, root, tree_vertices[0], tree_vertices);",
            "\t\t\t\t\t\t\tset_res(u, root);",
            "\t\t\t\t\t\t}",
            "\t\t\t\t\t}",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t};",
            "\t\tvector<int> tree_vertices(m);",
            "\t\tiota(tree_vertices.begin(), tree_vertices.end(), 0);",
            "\t\tsolve(solve, 0, 0, tree_vertices);",
            "\t\tassert(*min_element(res.begin(), res.end()) >= 0);",
            "\t\treturn res;",
            "\t}",
            "};"
        ],
        "description": "tranxuanbach"
    }
}