{
    "tranxuanbach": {
        "prefix": "mo_sweepline",
        "body": [
            "// Source: https://codeforces.com/blog/entry/83248",
            "// T must be a commutative group",
            "// Given some function op:\\mathbb{Z}^2->T,",
            "// each query asks for \\sum_{l<=i<j<r} op(i,j)",
            "//",
            "// solve() initializes a multiset S to be empty.",
            "// Each insert(x) call should insert x to S.",
            "// Each query_left(x) should return \\sum_{y \\in S} op(x, y).",
            "// Each query_right(x) should return \\sum_{y \\in S} op(y, x).",
            "//",
            "// O(n) insert() calls",
            "// O(n + qn*BX) query_left() calls, and",
            "// O(n + n^2/BX) query_right() calls.",
            "//",
            "// Set BX = n/sqrt(qn) to achieve",
            "// O(n) insert() calls, and",
            "// O(n * sqrt(qn)) query_left() and query_right() calls.",
            "template<int BX, class T, class F = plus<>, class I = negate<>>",
            "struct mo_sweepline_base{",
            "\tint n;",
            "\tmutable vector<array<int, 3>> q;",
            "\tF TT;",
            "\tT T_id;",
            "\tI Tinv;",
            "\tmo_sweepline_base(int n, F TT = plus<>(), T T_id = 0, I Tinv = negate<>()): n(n), TT(TT), T_id(T_id), Tinv(Tinv){ }",
            "\tvoid query(int qi, int ql, int qr){",
            "\t\tassert(0 <= ql && ql <= qr && qr <= n);",
            "\t\tq.push_back({ql, qr, qi});",
            "\t}",
            "\tvector<T> solve(auto insert, auto query_left, auto query_right) const{",
            "\t\tsort(q.begin(), q.end(), [&](auto x, auto y){ return x[0] / BX != y[0] / BX ? x[0] < y[0] : x[0] / BX & 1 ? x[1] > y[1] : x[1] < y[1]; });",
            "\t\tvector<vector<array<int, 4>>> update(n + 1);",
            "\t\tint l = 0, r = 0;",
            "\t\t// [0-bit] 0: query_left, 1: query_right",
            "\t\t// [1-bit] 0: add       , 1: subtract",
            "\t\tfor(auto [ql, qr, qi]: q){",
            "\t\t\tif(ql < l){",
            "\t\t\t\tupdate[r].push_back({ql, l, 2, qi});",
            "\t\t\t\tl = ql;",
            "\t\t\t}",
            "\t\t\tif(r < qr){",
            "\t\t\t\tupdate[l].push_back({r, qr, 1, qi});",
            "\t\t\t\tr = qr;",
            "\t\t\t}",
            "\t\t\tif(l < ql){",
            "\t\t\t\tupdate[r].push_back({l, ql, 0, qi});",
            "\t\t\t\tl = ql;",
            "\t\t\t}",
            "\t\t\tif(qr < r){",
            "\t\t\t\tupdate[l].push_back({qr, r, 3, qi});",
            "\t\t\t\tr = qr;",
            "\t\t\t}",
            "\t\t}",
            "\t\tvector<T> pref_exc(n + 1), pref_inc(n + 1);",
            "\t\t// pref_exc[r] = \\sum_{0<=i< j<r} op(i,j)",
            "\t\t// pref_inc[r] = \\sum_{0<=i<=j<r} op(j,i)",
            "\t\tint qn = (int)q.size();",
            "\t\tvector<T> res(qn, T_id);",
            "\t\tfor(auto x = 0; x <= n; ++ x){",
            "\t\t\tfor(auto [from, to, coef, qi]: update[x]){",
            "\t\t\t\tT sum = T_id;",
            "\t\t\t\tif(coef & 1) for(auto i = from; i < to; ++ i) sum = TT(sum, query_right(i));",
            "\t\t\t\telse for(auto i = from; i < to; ++ i) sum = TT(sum, query_left(i));",
            "\t\t\t\tres[qi] = coef & 2 ? TT(res[qi], Tinv(sum)) : TT(res[qi], sum);",
            "\t\t\t}",
            "\t\t\tif(x < n){",
            "\t\t\t\tpref_exc[x + 1] = TT(pref_exc[x], query_right(x));",
            "\t\t\t\tinsert(x);",
            "\t\t\t\tpref_inc[x + 1] = TT(pref_inc[x], query_left(x));",
            "\t\t\t}",
            "\t\t}",
            "\t\t//  \\sum_{0<=i<=j<l} op(j,i) +",
            "\t\t//  \\sum_{0<=i<l,i<j<r} op(i,j)",
            "\t\tT aux = T_id;",
            "\t\tfor(auto [ql, qr, qi]: q){",
            "\t\t\taux = TT(aux, res[qi]);",
            "\t\t\tres[qi] = TT(TT(pref_inc[ql], pref_exc[qr]), Tinv(aux));",
            "\t\t}",
            "\t\treturn res;",
            "\t}",
            "};",
            "template<class T, class F = plus<>, class I = negate<>>",
            "using mo_sweepline = mo_sweepline_base<500, T, F, I>;"
        ],
        "description": "tranxuanbach"
    }
}