{
    "tranxuanbach": {
        "prefix": "strong_augmentation",
        "body": [
            "// g must be a directed acyclic graph",
            "// Requires graph",
            "template<class T>",
            "vector<array<int, 2>> strong_augmentation(const graph<T> &g){",
            "\tint n = g.n;",
            "\tif(n <= 1) return {};",
            "\tvector<int> is_source(n, true), is_sink(n);",
            "\tfor(auto u = 0; u < n; ++ u){",
            "\t\tis_sink[u] = g.adj[u].empty();",
            "\t\tfor(auto id: g.adj[u]){",
            "\t\t\tif(g.ignore && g.ignore(id)) continue;",
            "\t\t\tis_source[g.edge[id].to] = false;",
            "\t\t}",
            "\t}",
            "\tvector<int> source, sink, found(n);",
            "\tfor(auto r = 0; r < n; ++ r){",
            "\t\tif(found[r] || !is_source[r]) continue;",
            "\t\tstatic vector<int> stack;",
            "\t\tstack.push_back(r);",
            "\t\twhile(!stack.empty()){",
            "\t\t\tint u = stack.back();",
            "\t\t\tstack.pop_back();",
            "\t\t\tif(found[u]) continue;",
            "\t\t\tfound[u] = true;",
            "\t\t\tif(is_sink[u]){",
            "\t\t\t\tsource.push_back(r);",
            "\t\t\t\tsink.push_back(u);",
            "\t\t\t\tis_source[r] = is_sink[u] = false;",
            "\t\t\t\tstack.clear();",
            "\t\t\t\tbreak;",
            "\t\t\t}",
            "\t\t\tfor(auto id: g.adj[u]){",
            "\t\t\t\tif(g.ignore && g.ignore(id)) continue;",
            "\t\t\t\tstack.push_back(g.edge[id].to);",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "\tint p = (int)source.size();",
            "\tfor(auto u = 0; u < n; ++ u){",
            "\t\tif(is_source[u]) source.push_back(u);",
            "\t\tif(is_sink[u]) sink.push_back(u);",
            "\t}",
            "\tint l = (int)source.size(), r = (int)sink.size(), lr = min(l, r);",
            "\tvector<array<int, 2>> res{{sink[0], source[p - 1]}};",
            "\tfor(auto i = 1; i < p; ++ i) res.push_back({sink[i], source[i - 1]});",
            "\tfor(auto i = p; i < lr; ++ i) res.push_back({sink[i], source[i]});",
            "\tfor(auto i = lr; i < l; ++ i) res.push_back({sink[0], source[i]});",
            "\tfor(auto i = lr; i < r; ++ i) res.push_back({sink[i], source[0]});",
            "\treturn res;",
            "}"
        ],
        "description": "tranxuanbach"
    }
}