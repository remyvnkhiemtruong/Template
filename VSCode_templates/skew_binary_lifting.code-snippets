{
    "tranxuanbach": {
        "prefix": "skew_binary_lifting",
        "body": [
            "// Requires graph",
            "struct skew_binary_lifting{",
            "\tint n = 0;",
            "\tvector<int> pv, depth, lift;",
            "\tskew_binary_lifting(){ }",
            "\t// pv: parent vertex (-1 if root of an arborescence)",
            "\tskew_binary_lifting(const vector<int> &pv){",
            "\t\tgraph<int> g((int)pv.size());",
            "\t\tvector<int> roots;",
            "\t\tfor(auto u = 0; u < (int)pv.size(); ++ u) if(~pv[u]) g.orient(pv[u], u); else roots.push_back(u);",
            "\t\t*this = skew_binary_lifting(g, roots);",
            "\t}",
            "\t// O(|V|)",
            "\ttemplate<class T>",
            "\tskew_binary_lifting(const graph<T> &g, const vector<int> &roots): n(g.n){",
            "\t\tn = g.n;",
            "\t\tpv.assign(n, -1);",
            "\t\tdepth.assign(n, -1);",
            "\t\tlift.assign(n, -1);",
            "\t\tauto dfs = [&](auto self, int u, int pe)->void{",
            "\t\t\tfor(auto id: g.adj[u]){",
            "\t\t\t\tif(id == pe || g.ignore && g.ignore(id)) continue;",
            "\t\t\t\tauto &e = g.edge[id];",
            "\t\t\t\tint v = u ^ e.from ^ e.to;",
            "\t\t\t\tdepth[v] = depth[u] + 1;",
            "\t\t\t\tpv[v] = u;",
            "\t\t\t\tlift[v] = depth[lift[u]] - depth[u] == depth[lift[lift[u]]] - depth[lift[u]] ? lift[lift[u]] : u;",
            "\t\t\t\tself(self, v, id);",
            "\t\t\t}",
            "\t\t};",
            "\t\tfor(auto u: roots) assert(!~depth[u]), depth[u] = 0, pv[u] = u, lift[u] = u, dfs(dfs, u, -1);",
            "\t}",
            "\t// O(1)",
            "\tint add_root(){",
            "\t\tint u = (int)pv.size();",
            "\t\tdepth.push_back(0);",
            "\t\tpv.push_back(u);",
            "\t\tlift.push_back(u);",
            "\t\treturn u;",
            "\t}",
            "\t// O(1)",
            "\tvoid add_child(int u){",
            "\t\tassert(0 <= u && u < (int)pv.size());",
            "\t\tint v = (int)pv.size();",
            "\t\tdepth.push_back(depth[u] + 1);",
            "\t\tpv.push_back(u);",
            "\t\tlift.push_back(depth[lift[u]] - depth[u] == depth[lift[lift[u]]] - depth[lift[u]] ? lift[lift[u]] : u);",
            "\t}",
            "\t// Get the k-th ancestor of u;",
            "\t// O(log |V|)",
            "\tint ancestor(int u, int k) const{",
            "\t\tassert(depth[u] >= k);",
            "\t\tk = depth[u] - k;",
            "\t\twhile(depth[u] > k) u = depth[lift[u]] > k ? lift[u] : pv[u];",
            "\t\treturn u;",
            "\t}",
            "\t// Assumes u and v lies on the same arboresence",
            "\t// O(log |V|)",
            "\tint lca(int u, int v) const{",
            "\t\tif(depth[u] < depth[v]) swap(u, v);",
            "\t\twhile(depth[u] > depth[v]) u = depth[lift[u]] >= depth[v] ? lift[u] : pv[u];",
            "\t\twhile(u != v) tie(u, v) = lift[u] == lift[v] ? pair{pv[u], pv[v]} : pair{lift[u], lift[v]};",
            "\t\treturn u;",
            "\t}",
            "\t// Get # of edges between u and v",
            "\t// Assumes u and v lies on the same arboresence",
            "\t// O(log |V|)",
            "\tint steps(int u, int v, int w = -1) const{",
            "\t\treturn depth[u] + depth[v] - 2 * depth[~w ? w : lca(u, v)];",
            "\t}",
            "\t// For an ancestor p of u, pred(p) is T, ..., T, F, ..., F in decreasing order of depth. Returns the highest p with T",
            "\t// O(log |V|)",
            "\tint find_highest(int u, auto pred) const{",
            "\t\tassert(pred(u));",
            "\t\twhile(pv[u] != u){",
            "\t\t\tif(pred(lift[u])) u = lift[u];",
            "\t\t\telse if(pred(pv[u])) u = pv[u];",
            "\t\t\telse return u;",
            "\t\t}",
            "\t\treturn u;",
            "\t}",
            "};"
        ],
        "description": "tranxuanbach"
    }
}