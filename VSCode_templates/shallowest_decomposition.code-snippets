{
    "tranxuanbach": {
        "prefix": "shallowest_decomposition",
        "body": [
            "// pajenegod orz",
            "// Requires graph",
            "struct shallowest_decomposition{",
            "\tvector<int> was;",
            "\tint attempt;",
            "\tvector<int> dp;",
            "\tvector<vector<int>> stack;",
            "\t// g must be a tree",
            "\t// O(n)",
            "\ttemplate<class T>",
            "\tvoid build(const graph<T> &g, const vector<int> &src){",
            "\t\tassert(g.n <= n);",
            "\t\t++ attempt;",
            "\t\troot.clear();",
            "\t\torder.clear();",
            "\t\tfor(auto &s: stack) s.clear();",
            "\t\tabr.edge.clear();",
            "\t\tauto create_chain = [&](int labels, int u)->void{",
            "\t\t\twhile(labels){",
            "\t\t\t\tint label = __lg(labels);",
            "\t\t\t\tlabels ^= 1 << label;",
            "\t\t\t\tint v = stack[label].back();",
            "\t\t\t\tstack[label].pop_back();",
            "\t\t\t\tabr.orient(u, v);",
            "\t\t\t\tu = v;",
            "\t\t\t}",
            "\t\t};",
            "\t\tauto construct = [&](auto self, int u)->void{",
            "\t\t\twas[u] = attempt;",
            "\t\t\tdp[u] = 0;",
            "\t\t\tabr.adj[u].clear();",
            "\t\t\tint seen = 0, seen_twice = 0;",
            "\t\t\tfor(auto id: g.adj[u]){",
            "\t\t\t\tif(g.ignore && g.ignore(id)) continue;",
            "\t\t\t\tint v = g(u, id);",
            "\t\t\t\tif(was[v] == attempt) continue;",
            "\t\t\t\tself(self, v);",
            "\t\t\t\tseen_twice |= seen & dp[v];",
            "\t\t\t\tseen |= dp[v];",
            "\t\t\t}",
            "\t\t\tint temp = ~seen & -(1 << (seen_twice ? __lg(seen_twice) + 1: 0));",
            "\t\t\tint label = temp & -temp;",
            "\t\t\tdp[u] = (label | seen) & -label;",
            "\t\t\tstack[__lg(label)].push_back(u);",
            "\t\t\tfor(auto t = (int)g.adj[u].size() - 1; t >= 0; -- t){",
            "\t\t\t\tint id = g.adj[u][t];",
            "\t\t\t\tif(g.ignore && g.ignore(id)) continue;",
            "\t\t\t\tint v = g(u, id);",
            "\t\t\t\tcreate_chain(dp[v] & label - 1, u);",
            "\t\t\t}",
            "\t\t};",
            "\t\tfor(auto r: src){",
            "\t\t\tif(was[r] == attempt) continue;",
            "\t\t\tconstruct(construct, r);",
            "\t\t\troot.push_back(stack[__lg(dp[r])].back());",
            "\t\t\tstack[__lg(dp[r])].pop_back();",
            "\t\t\tcreate_chain(dp[r] ^ dp[root.back()], root.back());",
            "\t\t}",
            "\t\tauto dfs = [&](auto self, int u)->void{",
            "\t\t\tpos[u] = (int)order.size();",
            "\t\t\torder.push_back(u);",
            "\t\t\tfor(auto id: abr.adj[u]){",
            "\t\t\t\tint v = abr.edge[id].to;",
            "\t\t\t\tdepth[v] = depth[u] + 1;",
            "\t\t\t\tpv[v] = u;",
            "\t\t\t\tpe[v] = id;",
            "\t\t\t\tself(self, v);",
            "\t\t\t}",
            "\t\t\tend[u] = (int)order.size();",
            "\t\t\tsize[u] = end[u] - pos[u];",
            "\t\t};",
            "\t\tfor(auto r: root){",
            "\t\t\tdepth[r] = 0;",
            "\t\t\tpv[r] = pe[r] = -1;",
            "\t\t\tdfs(dfs, r);",
            "\t\t}",
            "\t}",
            "\ttemplate<class T>",
            "\tvoid build_all(const graph<T> &g){",
            "\t\tvector<int> src(g.n);",
            "\t\tiota(src.begin(), src.end(), 0);",
            "\t\tbuild(g, src);",
            "\t}",
            "\tvoid init(int n){",
            "\t\tassert(n >= 1);",
            "\t\tthis->n = n;",
            "\t\troot.clear();",
            "\t\tabr = graph<int>{n};",
            "\t\tpv.assign(n, -1);",
            "\t\tpe.assign(n, -1);",
            "\t\torder.clear();",
            "\t\tpos.assign(n, -1);",
            "\t\tend.assign(n, -1);",
            "\t\tsize.assign(n, -1);",
            "\t\tdepth.assign(n, -1);",
            "\t\twas.assign(n, -2);",
            "\t\tattempt = -1;",
            "\t\tdp.assign(n, -1);",
            "\t\tstack.assign(__lg(n) + 1, {});",
            "\t\tspv.assign(n, -1);",
            "\t\tspe.assign(n, -1);",
            "\t\tsorder.clear();",
            "\t\tspos.assign(n, -1);",
            "\t\tsend.assign(n, -1);",
            "\t\tssize.assign(n, -1);",
            "\t\tsdepth.assign(n, -1);",
            "\t}",
            "\ttemplate<class T>",
            "\tvoid init_step(const graph<T> &g){",
            "\t\tstep.assign(g.n, {});",
            "\t\tauto set_step = [&](auto self, int u, int pe, int d)->void{",
            "\t\t\tfor(auto id: g.adj[u]){",
            "\t\t\t\tif(id == pe || g.ignore && g.ignore(id)) continue;",
            "\t\t\t\tint v = g(u, id);",
            "\t\t\t\tif(depth[v] <= d) continue;",
            "\t\t\t\tstep[v].push_back(step[u].back() + 1);",
            "\t\t\t\tself(self, v, id, d);",
            "\t\t\t}",
            "\t\t};",
            "\t\tfor(auto t = (int)order.size() - 1; t >= 0; -- t){",
            "\t\t\tint u = order[t];",
            "\t\t\tstep[u].push_back(0);",
            "\t\t\tset_step(set_step, u, -1, depth[u]);",
            "\t\t}",
            "\t}",
            "\t// Check if u is visited during the last build-like call.",
            "\tbool visited(int u) const{",
            "\t\tassert(0 <= u && u < n);",
            "\t\treturn was[u] == attempt;",
            "\t}",
            "\t// Check if u is an ancestor of v in the decomposition",
            "\tbool ancestor_of(int u, int v) const{",
            "\t\tassert(visited(u) && visited(v));",
            "\t\treturn pos[u] <= pos[v] && end[v] <= end[u];",
            "\t}",
            "\tshallowest_decomposition(){ }",
            "\ttemplate<class T>",
            "\tshallowest_decomposition(const graph<T> &g){",
            "\t\tinit(g.n);",
            "\t\tbuild_all(g);",
            "\t}",
            "\ttemplate<class T>",
            "\tshallowest_decomposition(const graph<T> &g, const vector<int> &src){",
            "\t\tinit(g.n);",
            "\t\tbuild(g, src);",
            "\t}",
            "\tint n;",
            "\tvector<int> root; // the roots of the arborescence",
            "\tgraph<int> abr; // stores the arborescence",
            "\tvector<int> pv; // parent vertex in the decomposition",
            "\tvector<int> pe; // parent edge in the decomposition",
            "\tvector<int> order; // dfs order of the decomposition tree",
            "\tvector<int> pos; // starting position in the dfs order",
            "\tvector<int> end; // ending position in the dfs order",
            "\tvector<int> size; // size of the subtree in the decomposition",
            "\tvector<int> depth; // depth in the decomposition",
            "\tvector<vector<int>> step; // step[u][i]: # of edges from u to its i-th decomposition parent, must call init_step() to initialize",
            "\ttemplate<class T>",
            "\tvoid focus_subdecomposition(const graph<T> &g, int r){",
            "\t\tspv[r] = spe[r] = -1;",
            "\t\tsorder.clear();",
            "\t\tsdepth[r] = 0;",
            "\t\tauto dfs = [&](auto self, int u)->void{",
            "\t\t\tspos[u] = (int)sorder.size();",
            "\t\t\tsorder.push_back(u);",
            "\t\t\tfor(auto id: g.adj[u]){",
            "\t\t\t\tif(id == spe[u] || g.ignore && g.ignore(id)) continue;",
            "\t\t\t\tint v = g(u, id);",
            "\t\t\t\tif(!ancestor_of(r, v)) continue;",
            "\t\t\t\tspv[v] = u;",
            "\t\t\t\tspe[v] = id;",
            "\t\t\t\tsdepth[v] = sdepth[u] + 1;",
            "\t\t\t\tself(self, v);",
            "\t\t\t}",
            "\t\t\tsend[u] = (int)sorder.size();",
            "\t\t\tssize[u] = send[u] - spos[u];",
            "\t\t};",
            "\t\tdfs(dfs, r);",
            "\t}",
            "\tvector<int> spv;",
            "\tvector<int> spe;",
            "\tvector<int> sorder;",
            "\tvector<int> spos;",
            "\tvector<int> send;",
            "\tvector<int> ssize;",
            "\tvector<int> sdepth;",
            "};"
        ],
        "description": "tranxuanbach"
    }
}