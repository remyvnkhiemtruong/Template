{
    "tranxuanbach": {
        "prefix": "tree_diameter",
        "body": [
            "template<class T>",
            "struct tree_diameter{",
            "\tint n;",
            "\tvector<int> q, pe;",
            "\tvector<T> dist;",
            "\ttree_diameter(int n): n(n), q(n), pe(n), dist(n){",
            "\t\tassert(n >= 1);",
            "\t}",
            "\t// The connected component containing s must be a tree.",
            "\t// Returns {diamter, {starting vertex, list of edges}}",
            "\t// O(size(component))",
            "\t// Requires graph",
            "\ttemplate<class U>",
            "\ttuple<T, vector<int>> diameter(const graph<U> &g, int s){",
            "\t\tassert(g.n == n);",
            "\t\tauto bfs = [&](int s)->void{",
            "\t\t\tq[0] = s;",
            "\t\t\tpe[s] = -1;",
            "\t\t\tdist[s] = 0;",
            "\t\t\tfor(auto qbeg = 0, qend = 1; qbeg < qend; ++ qbeg){",
            "\t\t\t\tint u = q[qbeg];",
            "\t\t\t\tfor(auto id: g.adj[u]){",
            "\t\t\t\t\tif(g.ignore && g.ignore(id) || id == pe[u]) continue;",
            "\t\t\t\t\tint v = g(u, id);",
            "\t\t\t\t\tT w = g.edge[id].cost;",
            "\t\t\t\t\tq[qend ++] = v;",
            "\t\t\t\t\tpe[v] = id;",
            "\t\t\t\t\tdist[v] = dist[u] + w;",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t};",
            "\t\tbfs(s);",
            "\t\tint x = max_element(dist.begin(), dist.end()) - dist.begin();",
            "\t\tbfs(x);",
            "\t\tint y = max_element(dist.begin(), dist.end()) - dist.begin();",
            "\t\tvector<int> diam;",
            "\t\tfor(auto u = y; u != x; u = g(u, pe[u])) diam.push_back(pe[u]);",
            "\t\tdiam.push_back(x);",
            "\t\treverse(diam.begin(), diam.end());",
            "\t\treturn {dist[y], diam};",
            "\t}",
            "};"
        ],
        "description": "tranxuanbach"
    }
}