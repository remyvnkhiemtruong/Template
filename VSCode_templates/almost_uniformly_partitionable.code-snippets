{
    "tranxuanbach": {
        "prefix": "almost_uniformly_partitionable",
        "body": [
            "// Implementation of http://www.ecei.tohoku.ac.jp/alg/nishizeki/sub/j/DVD/PDF_P/P109.pdf",
            "// Returns an array a of length p where a[i] = [there exists a partition of the tree g into i+1 subtrees",
            "// such that sum of weight of each components is in [low, high)",
            "// O(p^3 * |V|)",
            "// Requires graph",
            "template<class T, class U>",
            "vector<int> almost_uniformly_partitionable(const graph<T> &g, const vector<U> &weight, int p, U low, U high){",
            "\tassert(p >= 0 && low <= high);",
            "\tif(!p || low == high || any_of(weight.begin(), weight.end(), [&](auto x){ return x >= high; })) return vector<int>(p);",
            "\tvector<int> sz(g.n, 1);",
            "\tconst U len = high - low;",
            "\tauto dfs = [&](auto self, int u, int pe)->vector<vector<array<U, 2>>>{",
            "\t\tvector<vector<array<U, 2>>> dp(min(p, sz[u]));",
            "\t\tdp[0].push_back({weight[u], weight[u] + 1});",
            "\t\tfor(auto id: g.adj[u]){",
            "\t\t\tif(id == pe || g.ignore && g.ignore(id)) continue;",
            "\t\t\tint v = g(u, id);",
            "\t\t\tauto dpv = self(self, v, id);",
            "\t\t\tvector<int> valid(p);",
            "\t\t\tfor(auto i = 0; i < (int)dpv.size(); ++ i) for(auto [l, r]: dpv[i]) if(low < r && l < high){",
            "\t\t\t\tvalid[i] = true;",
            "\t\t\t\tbreak;",
            "\t\t\t}",
            "\t\t\tvector<vector<array<U, 2>>> dp_next(min(p, sz[u] + sz[v]));",
            "\t\t\tfor(auto i = 0; i < (int)dp_next.size(); ++ i){",
            "\t\t\t\tvector<array<U, 2>> intervals;",
            "\t\t\t\tU minl = numeric_limits<U>::max(), maxl = numeric_limits<U>::min();",
            "\t\t\t\tfor(auto j = max(0, i - (int)dpv.size() + 1); j < min((int)dp.size(), i + 1); ++ j) for(auto [l, r]: dp[j]) for(auto [ll, rr]: dpv[i - j]){",
            "\t\t\t\t\tintervals.push_back({l + ll, r + rr - 1});",
            "\t\t\t\t\tminl = min(minl, l + ll);",
            "\t\t\t\t\tmaxl = max(maxl, l + ll);",
            "\t\t\t\t}",
            "\t\t\t\tfor(auto j = 0; j < min(i, (int)dp.size()); ++ j) if(valid[i - 1 - j]) for(auto [l, r]: dp[j]){",
            "\t\t\t\t\tintervals.push_back({l, r});",
            "\t\t\t\t\tminl = min(minl, l);",
            "\t\t\t\t\tmaxl = max(maxl, l);",
            "\t\t\t\t}",
            "\t\t\t\tif(intervals.empty()) continue;",
            "\t\t\t\tvector<array<U, 2>> groups((maxl - minl) / len + 1, {numeric_limits<U>::max(), numeric_limits<U>::min()});",
            "\t\t\t\tfor(auto [l, r]: intervals){",
            "\t\t\t\t\tint i = (l - minl) / len;",
            "\t\t\t\t\tgroups[i] = {min(groups[i][0], l), max(groups[i][1], r)};",
            "\t\t\t\t}",
            "\t\t\t\tfor(auto [l, r]: groups){",
            "\t\t\t\t\tl = min(l, high), r = min(r, high);",
            "\t\t\t\t\tif(l < r){",
            "\t\t\t\t\t\tif(dp_next[i].empty() || l - dp_next[i].back()[1] >= len) dp_next[i].push_back({l, r});",
            "\t\t\t\t\t\telse dp_next[i].back()[1] = max(dp_next[i].back()[1], r);",
            "\t\t\t\t\t}",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t\tsz[u] += sz[v];",
            "\t\t\tswap(dp, dp_next);",
            "\t\t}",
            "\t\treturn dp;",
            "\t};",
            "\tauto dp = dfs(dfs, 0, -1);",
            "\tvector<int> res(p);",
            "\tfor(auto i = 0; i < p; ++ i) for(auto [l, r]: dp[i]) if(low < r && l < high){",
            "\t\tres[i] = true;",
            "\t\tbreak;",
            "\t}",
            "\treturn res;",
            "}"
        ],
        "description": "tranxuanbach"
    }
}