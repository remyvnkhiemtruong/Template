{
    "tranxuanbach": {
        "prefix": "fast_fourier_transform",
        "body": [
            "struct fast_fourier_transform_wrapper{",
            "\tusing CD = complex<double>;",
            "\tusing CLD = complex<long double>;",
            "\t// i \\in [2^k, 2^{k+1}) holds w_{2^k+1}^{i-2^k}",
            "\tstatic vector<CD> root;",
            "\tstatic vector<CLD> root_ld;",
            "\tstatic void adjust_root(int n){",
            "\t\tif(root.empty()) root = {1, 1}, root_ld = {1, 1};",
            "\t\tfor(auto k = (int)root.size(); k < n; k <<= 1){",
            "\t\t\troot.resize(n), root_ld.resize(n);",
            "\t\t\tauto theta = polar(1.0L, acos(-1.0L) / k);",
            "\t\t\tfor(auto i = k; i < k << 1; ++ i) root[i] = root_ld[i] = i & 1 ? root_ld[i >> 1] * theta : root_ld[i >> 1];",
            "\t\t}",
            "\t}",
            "\t// O(n * log(n))",
            "\tstatic void transform(vector<CD> &p, bool invert = false){",
            "\t\tint n = (int)p.size();",
            "\t\tassert(n && __builtin_popcount(n) == 1);",
            "\t\tfor(auto i = 1, j = 0; i < n; ++ i){",
            "\t\t\tint bit = n >> 1;",
            "\t\t\tfor(; j & bit; bit >>= 1) j ^= bit;",
            "\t\t\tj ^= bit;",
            "\t\t\tif(i < j) swap(p[i], p[j]);",
            "\t\t}",
            "\t\tadjust_root(n);",
            "\t\tfor(auto len = 1; len < n; len <<= 1) for(auto i = 0; i < n; i += len << 1) for(auto j = 0; j < len; ++ j){",
            "\t\t\tauto x = (double *)&root[j + len], y = (double *)&p[i + j + len];",
            "\t\t\tCD z(x[0] * y[0] - x[1] * y[1], x[0] * y[1] + x[1] * y[0]);",
            "\t\t\tp[len + i + j] = p[i + j] - z, p[i + j] += z;",
            "\t\t}",
            "\t\tif(invert){",
            "\t\t\treverse(p.begin() + 1, p.end());",
            "\t\t\tauto inv_n = 1.0l / n;",
            "\t\t\tfor(auto &x: p) x *= inv_n;",
            "\t\t}",
            "\t}",
            "\tstatic vector<CD> buffer1, buffer2;",
            "\t// O(n * m)",
            "\ttemplate<class T>",
            "\tstatic vector<T> convolute_naive(const vector<T> &p, const vector<T> &q){",
            "\t\tvector<T> res(max((int)p.size() + (int)q.size() - 1, 0));",
            "\t\tfor(auto i = 0; i < (int)p.size(); ++ i) for(auto j = 0; j < (int)q.size(); ++ j) res[i + j] += p[i] * q[j];",
            "\t\treturn res;",
            "\t}",
            "\t// Safe for sum(p[i]^2 + q[i]^2) lg2(n) < 9e14",
            "\t// O(n * log(n))",
            "\ttemplate<class T>",
            "\tstatic vector<T> convolute(const vector<T> &p, const vector<T> &q){",
            "\t\tif(min(p.size(), q.size()) < 60) return convolute_naive(p, q);",
            "\t\tint n = 1 << __lg((int)p.size() + (int)q.size() - 1) + 1;",
            "\t\tbuffer1.assign(n, 0);",
            "\t\tfor(auto i = 0; i < (int)p.size(); ++ i) buffer1[i].real(p[i]);",
            "\t\tfor(auto i = 0; i < (int)q.size(); ++ i) buffer1[i].imag(q[i]);",
            "\t\ttransform(buffer1);",
            "\t\tfor(auto &x: buffer1) x *= x;",
            "\t\tbuffer2.assign(n, 0);",
            "\t\tfor(auto i = 0; i < n; ++ i) buffer2[i] = buffer1[i] - conj(buffer1[-i & n - 1]);",
            "\t\ttransform(buffer2, true);",
            "\t\tvector<T> res((int)p.size() + (int)q.size() - 1);",
            "\t\tfor(auto i = 0; i < (int)res.size(); ++ i) res[i] = is_integral_v<T> ? llround(buffer2[i].imag() / 4) : buffer2[i].imag() / 4;",
            "\t\treturn res;",
            "\t}",
            "\t// O(n * log(n))",
            "\tstatic vector<CD> convolute_complex(const vector<CD> &p, const vector<CD> &q){",
            "\t\tif(min(p.size(), q.size()) < 60) return convolute_naive(p, q);",
            "\t\tint n = 1 << __lg((int)p.size() + (int)q.size() - 1) + 1;",
            "\t\tbuffer1 = p, buffer2 = q;",
            "\t\tbuffer1.resize(n), buffer2.resize(n);",
            "\t\ttransform(buffer1), transform(buffer2);",
            "\t\tfor(auto i = 0; i < n; ++ i) buffer1[i] *= buffer2[i];",
            "\t\ttransform(buffer1, true);",
            "\t\treturn {buffer1.begin(), buffer1.begin() + ((int)p.size() + (int)q.size() - 1)};",
            "\t}",
            "\t// Safe for 64-bit integer range",
            "\t// O(n * log(n))",
            "\ttemplate<class T>",
            "\tstatic vector<T> convolute_splitting(const vector<T> &p, const vector<T> &q){",
            "\t\tif(min(p.size(), q.size()) < 80) return convolute_naive(p, q);",
            "\t\tint n = 1 << __lg((int)p.size() + (int)q.size() - 1) + 1;",
            "\t\tconst int cut = 32000;",
            "\t\tbuffer1.assign(n, 0);",
            "\t\tfor(auto i = 0; i < (int)p.size(); ++ i) buffer1[i] = {(int)p[i] / cut, (int)p[i] % cut};",
            "\t\ttransform(buffer1);",
            "\t\tbuffer2.assign(n, 0);",
            "\t\tfor(auto i = 0; i < (int)q.size(); ++ i) buffer2[i] = {(int)q[i] / cut, (int)q[i] % cut};",
            "\t\ttransform(buffer2);",
            "\t\tfor(auto i = 0; i <= n >> 1; ++ i){",
            "\t\t\tint j = -i & n - 1;",
            "\t\t\tif(i == j){",
            "\t\t\t\ttie(buffer1[i], buffer2[i]) = pair<CD, CD>{",
            "\t\t\t\t\t(buffer1[i] + conj(buffer1[i])) * buffer2[i] / 2.0,",
            "\t\t\t\t\t(buffer1[i] - conj(buffer1[i])) * buffer2[i] / 2i",
            "\t\t\t\t};",
            "\t\t\t}",
            "\t\t\telse{",
            "\t\t\t\ttie(buffer1[i], buffer2[i], buffer1[j], buffer2[j]) = tuple<CD, CD, CD, CD>{",
            "\t\t\t\t\t(buffer1[i] + conj(buffer1[j])) * buffer2[i] / 2.0,",
            "\t\t\t\t\t(buffer1[i] - conj(buffer1[j])) * buffer2[i] / 2i,",
            "\t\t\t\t\t(buffer1[j] + conj(buffer1[i])) * buffer2[j] / 2.0,",
            "\t\t\t\t\t(buffer1[j] - conj(buffer1[i])) * buffer2[j] / 2i",
            "\t\t\t\t};",
            "\t\t\t}",
            "\t\t}",
            "\t\ttransform(buffer1, true);",
            "\t\ttransform(buffer2, true);",
            "\t\tvector<T> res((int)p.size() + (int)q.size() - 1);",
            "\t\tfor(auto i = 0; i < (int)res.size(); ++ i) res[i] = ((T)llround(buffer1[i].real()) * cut + (T)(llround(buffer1[i].imag()) + llround(buffer2[i].real()))) * cut + (T)llround(buffer2[i].imag());",
            "\t\treturn res;",
            "\t}",
            "\t// Safe for 64-bit integer range",
            "\t// O(n * log(n))",
            "\ttemplate<class T>",
            "\tstatic vector<T> convolute_splitting_mod(const vector<T> &p, const vector<T> &q){",
            "\t\tif(min(p.size(), q.size()) < 80) return convolute_naive(p, q);",
            "\t\tvector<int> p2(p.begin(), p.end()), q2(q.begin(), q.end());",
            "\t\tp2 = convolute_splitting(p2, q2);",
            "\t\treturn {p2.begin(), p2.end()};",
            "\t}",
            "};",
            "vector<complex<double>> fast_fourier_transform_wrapper::root;",
            "vector<complex<long double>> fast_fourier_transform_wrapper::root_ld;",
            "vector<complex<double>> fast_fourier_transform_wrapper::buffer1;",
            "vector<complex<double>> fast_fourier_transform_wrapper::buffer2;",
            " ",
            "using fft = fast_fourier_transform_wrapper;"
        ],
        "description": "tranxuanbach"
    }
}