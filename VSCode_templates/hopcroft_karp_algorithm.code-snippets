{
    "tranxuanbach": {
        "prefix": "hopcroft_karp_algorithm",
        "body": [
            "// Requires maximum_bipartite_matching_solver",
            "struct hopcroft_karp_algorithm: maximum_bipartite_matching_solver{",
            "\thopcroft_karp_algorithm(int n, int m): a(n), p(n), q(n){",
            "\t\tthis->n = n;",
            "\t\tthis->m = m;",
            "\t\tadj.assign(n, {});",
            "\t\tpu.assign(n, -1);",
            "\t\tpv.assign(m, -1);",
            "\t}",
            "\tint insert(int from, int to){",
            "\t\tadj[from].push_back(to);",
            "\t\treturn (int)adj[from].size() - 1;",
            "\t}",
            "\tvoid clear(){",
            "\t\tadj.assign(n, {});",
            "\t\tpu.assign(n, -1);",
            "\t\tpv.assign(m, -1);",
            "\t}",
            "\tvector<int> a, p, q;",
            "\tint maximum_matching(){",
            "\t\tint matching = 0;",
            "\t\twhile(true){",
            "\t\t\tfill(a.begin(), a.end(), -1);",
            "\t\t\tfill(p.begin(), p.end(), -1);",
            "\t\t\tint delta = 0, qend = 0;",
            "\t\t\tfor(auto u = 0; u < n; ++ u) if(!~pu[u]) q[qend ++] = a[u] = p[u] = u;",
            "\t\t\tfor(auto qbeg = 0; qbeg < qend; ++ qbeg){",
            "\t\t\t\tint u = q[qbeg];",
            "\t\t\t\tif(~pu[a[u]]) continue;",
            "\t\t\t\tfor(auto v: adj[u]){",
            "\t\t\t\t\tif(!~pv[v]){",
            "\t\t\t\t\t\twhile(~v) pv[v] = u, swap(pu[u], v), u = p[u];",
            "\t\t\t\t\t\t++ delta;",
            "\t\t\t\t\t\tbreak;",
            "\t\t\t\t\t}",
            "\t\t\t\t\tif(!~p[pv[v]]) q[qend ++] = v = pv[v], p[v] = u, a[v] = a[u];",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t\tif(!delta) break;",
            "\t\t\tmatching += delta;",
            "\t\t}",
            "\t\treturn matching;",
            "\t}",
            "};"
        ],
        "description": "tranxuanbach"
    }
}