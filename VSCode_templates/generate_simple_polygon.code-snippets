{
    "tranxuanbach": {
        "prefix": "generate_polygon",
        "body": [
            "// T_large must be able to hold max_coordiate^4",
            "// Requires point, line, line_intersection, quad_edge, delaunay_triangulation, and disjoint_set",
            "template<class T, class T_large>",
            "vector<point<T>> generate_simple_polygon(auto &&rng, int n, T low, T high){",
            "\tassert(n >= 3 && low < high);",
            "\tvector<point<T>> order;",
            "\twhile(true){",
            "\t\tset<point<T>> used;",
            "\t\tfor(auto i = 0; i < n; ++ i){",
            "\t\t\twhile(true){",
            "\t\t\t\tT x = rng() % (high - low) + low, y = rng() % (high - low) + low;",
            "\t\t\t\tif(!used.count({x, y})){",
            "\t\t\t\t\tused.insert({x, y});",
            "\t\t\t\t\tbreak;",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t}",
            "\t\torder = vector<point<T>>(used.begin(), used.end());",
            "\t\tfor(auto i = 2; i < n; ++ i){",
            "\t\t\tif(!colinear(order[0], order[1], order[i])){",
            "\t\t\t\tgoto DONE;",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "\tDONE:;",
            "\tshuffle(order.begin(), order.end(), rng);",
            "\tif(rng() & 1){",
            "\t\tvector<tuple<double, int, int>> edge;",
            "\t\tdelaunay_triangulation<T, T_large>(order, [&](auto){  }, [&](int u, int v, int w){",
            "\t\t\tedge.push_back({distance(order[u], order[v]), u, v});",
            "\t\t\tedge.push_back({distance(order[v], order[w]), v, w});",
            "\t\t\tedge.push_back({distance(order[w], order[u]), w, u});",
            "\t\t});",
            "\t\tsort(edge.begin(), edge.end());",
            "\t\tdisjoint_set dsu(n);",
            "\t\tvector<vector<int>> adj(n);",
            "\t\tfor(auto [w, u, v]: edge){",
            "\t\t\tif(dsu.merge(u, v)){",
            "\t\t\t\tadj[u].push_back(v);",
            "\t\t\t\tadj[v].push_back(u);",
            "\t\t\t}",
            "\t\t}",
            "\t\tvector<array<int, 2>> q(n);",
            "\t\tq[0] = {0, -1};",
            "\t\tvector<point<T>> norder(n);",
            "\t\tfor(auto beg = 0, end = 1; beg < end; ++ beg){",
            "\t\t\tauto [u, p] = q[beg];",
            "\t\t\tnorder[beg] = order[u];",
            "\t\t\tfor(auto v: adj[u]) if(v != p) q[end ++] = {v, u};",
            "\t\t}",
            "\t\torder = norder;",
            "\t}",
            "\tfor(bool changed = true; changed; ){",
            "\t\tchanged = false;",
            "\t\tfor(auto u = 0; u < n; ++ u){",
            "\t\t\tint v = (u + 1) % n, w = (u + 2) % n;",
            "\t\t\tif((order[v] - order[u] ^ order[w] - order[v]) == 0 && (order[v] - order[u]) * (order[w] - order[v]) < 0){",
            "\t\t\t\tchanged = true;",
            "\t\t\t\tif((order[w] - order[u]) * (order[v] - order[w]) > 0) swap(order[v], order[w]);",
            "\t\t\t\telse swap(order[u], order[v]);",
            "\t\t\t}",
            "\t\t\tline<T> L(order[u], order[v]);",
            "\t\t\tfor(auto v = u + 2; v < n - !u; ++ v){",
            "\t\t\t\tif(intersect_closed_segments(L, line<T>(order[v], order[(v + 1) % n]))){",
            "\t\t\t\t\tchanged = true;",
            "\t\t\t\t\treverse(order.begin() + u + 1, order.begin() + v + 1);",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "\tif(doubled_signed_area(order) < 0) reverse(order.begin(), order.end());",
            "\treturn order;",
            "}"
        ],
        "description": "tranxuanbach"
    }
}