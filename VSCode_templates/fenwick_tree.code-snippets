{
    "tranxuanbach": {
        "prefix": "fenwick_tree",
        "body": [
            "template<bool ALLOW_NON_PREFIX_QUERY, class T, class F, class I>",
            "struct fenwick_tree{",
            "\tint n;",
            "\tvector<T> data;",
            "\tF TT;",
            "\tT T_id;",
            "\tI Tinv;",
            "\tfenwick_tree(F TT, T T_id, I Tinv): TT(TT), T_id(T_id), Tinv(Tinv){ }",
            "\tfenwick_tree &operator=(const fenwick_tree &fw){",
            "\t\tn = fw.n;",
            "\t\tdata = fw.data;",
            "\t}",
            "\t// O(n)",
            "\tvoid build(int n){",
            "\t\tassert(n >= 0);",
            "\t\tthis->n = n;",
            "\t\tdata.assign(n, T_id);",
            "\t}",
            "\t// O(n)",
            "\tvoid build(int n, T x){",
            "\t\tassert(n >= 0);",
            "\t\tthis->n = n;",
            "\t\tdata.assign(n, x);",
            "\t\tfor(auto i = 1; i <= n; ++ i) if(i + (i & -i) <= n) data[i + (i & -i) - 1] = TT(data[i + (i & -i) - 1], data[i - 1]);",
            "\t}",
            "\t// O(n)",
            "\ttemplate<class U>",
            "\tvoid build(const vector<U> &a){",
            "\t\tn = (int)a.size();",
            "\t\tdata.resize(n);",
            "\t\tcopy(a.begin(), a.end(), data.begin());",
            "\t\tfor(auto i = 1; i <= n; ++ i) if(i + (i & -i) <= n) data[i + (i & -i) - 1] = TT(data[i + (i & -i) - 1], data[i - 1]);",
            "\t}",
            "\t// O(log(n))",
            "\tvoid update(int p, T x){",
            "\t\tassert(0 <= p && p < n);",
            "\t\tfor(++ p; p <= n; p += p & -p) data[p - 1] = TT(data[p - 1], x);",
            "\t}",
            "\t// O(log(n))",
            "\tvoid set(int p, T x){",
            "\t\tupdate(p, TT(x, Tinv(query(p))));",
            "\t}",
            "\t// O(log(n))",
            "\tT prefix(int r) const{",
            "\t\tassert(0 <= r && r <= n);",
            "\t\tT s = T_id;",
            "\t\tfor(; r > 0; r -= r & -r) s = TT(s, data[r - 1]);",
            "\t\treturn s;",
            "\t}",
            "\t// O(log(n))",
            "\tT query(int l, int r) const{",
            "\t\tstatic_assert(ALLOW_NON_PREFIX_QUERY);",
            "\t\tassert(0 <= l && l <= r && r <= n);",
            "\t\tif(l == r) return T_id;",
            "\t\tT sum_minus = T_id, sum_plus = T_id;",
            "\t\tfor(; l < r; r -= r & -r) sum_plus = TT(sum_plus, data[r - 1]);",
            "\t\tfor(; r < l; l -= l & -l) sum_minus = TT(sum_minus, data[l - 1]);",
            "\t\treturn TT(sum_plus, Tinv(sum_minus));",
            "\t}",
            "\t// O(log(n))",
            "\tT query(int p) const{",
            "\t\tstatic_assert(ALLOW_NON_PREFIX_QUERY);",
            "\t\treturn query(p, p + 1);",
            "\t}",
            "\t// O(log(n))",
            "\tT query_all() const{",
            "\t\treturn prefix(n);",
            "\t}",
            "\t// pred(sum[0, r)) is T, T, ..., T, F, F, ..., F, returns max r with T",
            "\t// O(log(n))",
            "\tint max_pref(auto pred) const{",
            "\t\tassert(pred(T_id));",
            "\t\tint p = 0;",
            "\t\tT sum = T_id;",
            "\t\tfor(auto i = __lg(n + 1); i >= 0; -- i) if(p + (1 << i) <= n && pred(TT(sum, data[p + (1 << i) - 1]))){",
            "\t\t\tsum = TT(sum, data[p + (1 << i) - 1]);",
            "\t\t\tp += 1 << i;",
            "\t\t}",
            "\t\treturn p;",
            "\t}",
            "\ttemplate<class output_stream>",
            "\tfriend output_stream &operator<<(output_stream &out, const fenwick_tree &fw){",
            "\t\tout << \"{\";",
            "\t\tfor(auto i = 0; i < fw.n; ++ i){",
            "\t\t\tout << fw.query(i);",
            "\t\t\tif(i != fw.n - 1) out << \", \";",
            "\t\t}",
            "\t\treturn out << '}';",
            "\t}",
            "};",
            "",
            "template<class T, class F, class I>",
            "auto make_fenwick_tree(F TT, T T_id, I Tinv){",
            "\treturn fenwick_tree<true, T, F, I>(TT, T_id, Tinv);",
            "}",
            "template<class T>",
            "auto make_fenwick_tree_sum(){",
            "\treturn fenwick_tree<true, T, plus<>, negate<>>(plus<>(), T{0}, negate<>());",
            "}",
            "template<class T>",
            "auto make_fenwick_tree_product(){",
            "\tauto inverse = [](const T &x){ return 1 / x; };",
            "\treturn fenwick_tree<true, T, multiplies<>, decltype(inverse)>(multiplies<>(), T{1}, inverse);",
            "}",
            "template<class T>",
            "auto make_fenwick_tree_min(){",
            "\tauto TT = [&](const T &x, const T &y)->T{ return min(x, y); };",
            "\treturn fenwick_tree<false, T, decltype(TT), negate<>>(TT, numeric_limits<T>::max(), negate<>());",
            "}",
            "template<class T>",
            "auto make_fenwick_tree_max(){",
            "\tauto TT = [&](const T &x, const T &y)->T{ return max(x, y); };",
            "\treturn fenwick_tree<false, T, decltype(TT), negate<>>(TT, numeric_limits<T>::max(), negate<>());",
            "}"
        ],
        "description": "tranxuanbach"
    }
}