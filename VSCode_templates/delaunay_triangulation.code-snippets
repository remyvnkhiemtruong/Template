{
    "tranxuanbach": {
        "prefix": "delaunay_triangulation",
        "body": [
            "// T_large must be able to hold O(T^4) (can be long long if coord <= 2e4)",
            "// O(n * log(n))",
            "// Requires point and quad_edge",
            "template<class T, class T_large, class F1, class F2>",
            "bool delaunay_triangulation(const vector<point<T>> &a, F1 process_outer_face, F2 process_triangles){",
            "\tvector<int> ind(a.size());",
            "\tiota(ind.begin(), ind.end(), 0);",
            "\tsort(ind.begin(), ind.end(), [&](int i, int j){ return a[i] < a[j]; });",
            "\tind.erase(unique(ind.begin(), ind.end(), [&](int i, int j){ return a[i] == a[j]; }), ind.end());",
            "\tint n = (int)ind.size();",
            "\tif(n < 2) return {};",
            "\tauto circular = [&](point<T> p, point<T> a, point<T> b, point<T> c){",
            "\t\ta -= p, b -= p, c -= p;",
            "\t\treturn ((T_large)a.squared_norm() * (b ^ c) + (T_large)b.squared_norm() * (c ^ a) + (T_large)c.squared_norm() * (a ^ b)) * (doubled_signed_area(a, b, c) > 0 ? 1 : -1) > 0;",
            "\t};",
            "\tauto recurse = [&](auto self, int l, int r)->array<quad_edge *, 2>{",
            "\t\tif(r - l <= 3){",
            "\t\t\tquad_edge *p = quad_edge::make_sphere(ind[l], ind[l + 1]);",
            "\t\t\tif(r - l == 2) return {p, p->sym()};",
            "\t\t\tquad_edge *q = quad_edge::make_sphere(ind[l + 1], ind[l + 2]);",
            "\t\t\tquad_edge::splice(p->sym(), q);",
            "\t\t\tauto side = doubled_signed_area(a[ind[l]], a[ind[l + 1]], a[ind[l + 2]]);",
            "\t\t\tquad_edge *c = side ? quad_edge::connect(q, p) : NULL;",
            "\t\t\treturn {side < 0 ? c->sym() : p, side < 0 ? c : q->sym()};",
            "\t\t}",
            "\t\tint m = l + (r - l >> 1);",
            "\t\tauto [ra, A] = self(self, l, m);",
            "\t\tauto [B, rb] = self(self, m, r);",
            "\t\twhile(doubled_signed_area(a[B->o], a[A->d()], a[A->o]) < 0 && (A = A->lnext()) || doubled_signed_area(a[A->o], a[B->d()], a[B->o]) > 0 && (B = B->sym()->onext));",
            "\t\tquad_edge *base = quad_edge::connect(B->sym(), A);",
            "\t\tif(A->o == ra->o) ra = base->sym();",
            "\t\tif(B->o == rb->o) rb = base;",
            "#define valid(e) (doubled_signed_area(a[e->d()], a[base->d()], a[base->o]) > 0)",
            "#define DEL(e, init, dir) \\",
            "quad_edge *e = init->dir; \\",
            "if(valid(e)) while(circular(a[e->dir->d()], a[base->d()], a[base->o], a[e->d()])){ \\",
            "\tquad_edge *t = e->dir; \\",
            "\tquad_edge::splice(e, e->oprev()); \\",
            "\tquad_edge::splice(e->sym(), e->sym()->oprev()); \\",
            "\tdelete e->rot->rot->rot; \\",
            "\tdelete e->rot->rot; \\",
            "\tdelete e->rot; \\",
            "\tdelete e; \\",
            "\te = t; \\",
            "}",
            "\t\twhile(true){",
            "\t\t\tDEL(LC, base->sym(), onext);",
            "\t\t\tDEL(RC, base, oprev());",
            "\t\t\tif(!valid(LC) && !valid(RC)) break;",
            "\t\t\tif(!valid(LC) || valid(RC) && circular(a[RC->d()], a[RC->o], a[LC->d()], a[LC->o])) base = quad_edge::connect(RC, base->sym());",
            "\t\t\telse base = quad_edge::connect(base->sym(), LC->sym());",
            "\t\t}",
            "\t\treturn {ra, rb};",
            "\t};",
            "\tauto e = recurse(recurse, 0, n)[0];",
            "\tvector<quad_edge *> q = {e}, rem;",
            "\twhile(doubled_signed_area(a[e->onext->d()], a[e->d()], a[e->o]) < 0) e = e->onext;",
            "\tvector<int> face;",
            "\tface.reserve(n);",
            "\tbool colinear = false;",
            "#define ADD \\",
            "{ \\",
            "\tquad_edge *c = e; \\",
            "\tface.clear(); \\",
            "\tdo{ \\",
            "\t\tc->mark = true; \\",
            "\t\tface.push_back(c->o); \\",
            "\t\tq.push_back(c->sym()); \\",
            "\t\trem.push_back(c); \\",
            "\t\tc = c->lnext(); \\",
            "\t}while(c != e); \\",
            "}",
            "\tADD;",
            "\tprocess_outer_face(face);",
            "\tfor(auto qi = 0; qi < (int)q.size(); ++ qi){",
            "\t\tif(!(e = q[qi])->mark){",
            "\t\t\tADD;",
            "\t\t\tcolinear = false;",
            "\t\t\tprocess_triangles(face[0], face[1], face[2]);",
            "\t\t}",
            "\t}",
            "\tfor(auto e: rem) delete e->rot, delete e;",
            "\treturn !colinear;",
            "}"
        ],
        "description": "tranxuanbach"
    }
}