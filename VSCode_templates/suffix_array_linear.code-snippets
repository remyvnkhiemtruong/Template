{
    "tranxuanbach": {
        "prefix": "suffix_array_linear",
        "body": [
            "vector<int> sa_naive(const vector<int> &s){",
            "\tint n = (int)s.size();",
            "\tvector<int> sa(n);",
            "\tiota(sa.begin(), sa.end(), 0);",
            "\tsort(sa.begin(), sa.end(), [&](int l, int r){",
            "\t\tif(l == r) return false;",
            "\t\tfor(; l < n && r < n; ++ l, ++ r) if(s[l] != s[r]) return s[l] < s[r];",
            "\t\treturn l == n;",
            "\t});",
            "\treturn sa;",
            "}",
            "vector<int> sa_doubling(const vector<int> &s){",
            "\tint n = (int)s.size();",
            "\tvector<int> sa(n), rnk = s, tmp(n);",
            "\tiota(sa.begin(), sa.end(), 0);",
            "\tfor(int k = 1; k < n; k <<= 1){",
            "\t\tauto cmp = [&](int x, int y){",
            "\t\t\tif(rnk[x] != rnk[y]) return rnk[x] < rnk[y];",
            "\t\t\tint rx = x + k < n ? rnk[x + k] : -1;",
            "\t\t\tint ry = y + k < n ? rnk[y + k] : -1;",
            "\t\t\treturn rx < ry;",
            "\t\t};",
            "\t\tsort(sa.begin(), sa.end(), cmp);",
            "\t\ttmp[sa[0]] = 0;",
            "\t\tfor(int i = 1; i < n; ++ i) tmp[sa[i]] = tmp[sa[i - 1]] + (cmp(sa[i - 1], sa[i]) ? 1 : 0);",
            "\t\tswap(tmp, rnk);",
            "\t}",
            "\treturn sa;",
            "}",
            "template <int THRESHOLD_NAIVE = 10, int THRESHOLD_DOUBLING = 40>",
            "vector<int> sa_is(const vector<int> &s, int upper){",
            "\tint n = (int)s.size();",
            "\tif(n == 0) return {};",
            "\tif(n == 1) return {0};",
            "\tif(n == 2){",
            "\t\tif(s[0] < s[1]) return {0, 1};",
            "\t\telse return {1, 0};",
            "\t}",
            "\tif(n < THRESHOLD_NAIVE) return sa_naive(s);",
            "\tif (n < THRESHOLD_DOUBLING) return sa_doubling(s);",
            "\tvector<int> sa(n);",
            "\tvector<bool> ls(n);",
            "\tfor(int i = n - 2; i >= 0; -- i) ls[i] = (s[i] == s[i + 1]) ? ls[i + 1] : (s[i] < s[i + 1]);",
            "\tvector<int> sum_l(upper + 1), sum_s(upper + 1);",
            "\tfor(int i = 0; i < n; ++ i){",
            "\t\tif(!ls[i]) ++ sum_s[s[i]];",
            "\t\telse ++ sum_l[s[i] + 1];",
            "\t}",
            "\tfor(int i = 0; i <= upper; ++ i){",
            "\t\tsum_s[i] += sum_l[i];",
            "\t\tif(i < upper) sum_l[i + 1] += sum_s[i];",
            "\t}",
            "\tauto induce = [&](const vector<int> &lms){",
            "\t\tfill(sa.begin(), sa.end(), -1);",
            "\t\tvector<int> buf(upper + 1);",
            "\t\tcopy(sum_s.begin(), sum_s.end(), buf.begin());",
            "\t\tfor(auto d: lms){",
            "\t\t\tif(d == n) continue;",
            "\t\t\tsa[buf[s[d]] ++] = d;",
            "\t\t}",
            "\t\tcopy(sum_l.begin(), sum_l.end(), buf.begin());",
            "\t\tsa[buf[s[n - 1]] ++] = n - 1;",
            "\t\tfor(int i = 0; i < n; ++ i){",
            "\t\t\tint v = sa[i];",
            "\t\t\tif(v >= 1 && !ls[v - 1]) sa[buf[s[v - 1]] ++] = v - 1;",
            "\t\t}",
            "\t\tcopy(sum_l.begin(), sum_l.end(), buf.begin());",
            "\t\tfor(int i = n - 1; i >= 0; -- i){",
            "\t\t\tint v = sa[i];",
            "\t\t\tif(v >= 1 && ls[v - 1]) sa[-- buf[s[v - 1] + 1]] = v - 1;",
            "\t\t}",
            "\t};",
            "\tvector<int> lms_map(n + 1, -1);",
            "\tint m = 0;",
            "\tfor(int i = 1; i < n; ++ i) if(!ls[i - 1] && ls[i]) lms_map[i] = m ++;",
            "\tvector<int> lms;",
            "\tlms.reserve(m);",
            "\tfor(int i = 1; i < n; ++ i) if(!ls[i - 1] && ls[i]) lms.push_back(i);",
            "\tinduce(lms);",
            "\tif(m){",
            "\t\tvector<int> sorted_lms;",
            "\t\tsorted_lms.reserve(m);",
            "\t\tfor(int v : sa) if(lms_map[v] != -1) sorted_lms.push_back(v);",
            "\t\tvector<int> rec_s(m);",
            "\t\tint rec_upper = 0;",
            "\t\trec_s[lms_map[sorted_lms[0]]] = 0;",
            "\t\tfor(int i = 1; i < m; ++ i){",
            "\t\t\tint l = sorted_lms[i - 1], r = sorted_lms[i];",
            "\t\t\tint end_l = (lms_map[l] + 1 < m) ? lms[lms_map[l] + 1] : n;",
            "\t\t\tint end_r = (lms_map[r] + 1 < m) ? lms[lms_map[r] + 1] : n;",
            "\t\t\tbool same = true;",
            "\t\t\tif(end_l - l != end_r - r) same = false;",
            "\t\t\telse{",
            "\t\t\t\tfor(; l < end_l; ++ l, ++ r) if (s[l] != s[r]) break;",
            "\t\t\t\tif(l == n || s[l] != s[r]) same = false;",
            "\t\t\t}",
            "\t\t\tif(!same) ++ rec_upper;",
            "\t\t\trec_s[lms_map[sorted_lms[i]]] = rec_upper;",
            "\t\t}",
            "\t\tauto rec_sa = sa_is<THRESHOLD_NAIVE, THRESHOLD_DOUBLING>(rec_s, rec_upper);",
            "\t\tfor(int i = 0; i < m; ++ i) sorted_lms[i] = lms[rec_sa[i]];",
            "\t\tinduce(sorted_lms);",
            "\t}",
            "\treturn sa;",
            "}",
            "vector<int> suffix_array(const vector<int> &s, int upper){",
            "\tassert(0 <= upper);",
            "\tfor(int d: s) assert(0 <= d && d <= upper);",
            "\tauto sa = sa_is(s, upper);",
            "\treturn sa;",
            "} // O(n + upper) time",
            "template<typename T> vector<int> suffix_array(const vector<T> &s){",
            "\tint n = (int)s.size();",
            "\tvector<int> idx(n);",
            "\tiota(idx.begin(), idx.end(), 0);",
            "\tsort(idx.begin(), idx.end(), [&](int l, int r){ return s[l] < s[r]; });",
            "\tvector<int> s2(n);",
            "\tint now = 0;",
            "\tfor(int i = 0; i < n; ++ i){",
            "\t\tif(i && s[idx[i - 1]] != s[idx[i]]) ++ now;",
            "\t\ts2[idx[i]] = now;",
            "\t}",
            "\treturn sa_is(s2, now);",
            "} // O(n log n) time, O(n) space",
            "vector<int> suffix_array(const string& s){",
            "\tint n = (int)s.size();",
            "\tvector<int> s2(n);",
            "\tfor(int i = 0; i < n; ++ i) s2[i] = s[i];",
            "\treturn sa_is(s2, 255);",
            "} // O(n) time",
            "template<typename T>",
            "vector<int> lcp_array(const vector<T> &s, const vector<int> &sa){",
            "\tint n = (int)s.size();",
            "\tassert(n >= 1);",
            "\tvector<int> rnk(n), lcp(n - 1);",
            "\tfor(int i = 0; i < n; ++ i) rnk[sa[i]] = i;",
            "\tint h = 0;",
            "\tfor(int i = 0; i < n; ++ i){",
            "\t\tif(h > 0) -- h;",
            "\t\tif(rnk[i] == 0) continue;",
            "\t\tint j = sa[rnk[i] - 1];",
            "\t\tfor(; j + h < n && i + h < n; ++ h) if(s[j + h] != s[i + h]) break;",
            "\t\tlcp[rnk[i] - 1] = h;",
            "\t}",
            "\treturn lcp;",
            "} // O(n)",
            "vector<int> lcp_array(const string& s, const vector<int>& sa){",
            "\tint n = (int)s.size();",
            "\tvector<int> s2(n);",
            "\tfor(int i = 0; i < n; ++ i) s2[i] = s[i];",
            "\treturn lcp_array(s2, sa);",
            "} // O(n)"
        ],
        "description": "tranxuanbach"
    }
}