{
    "tranxuanbach": {
        "prefix": "Z2_matrix",
        "body": [
            "template<int SZ>",
            "struct Z2_matrix: vector<bitset<SZ>>{",
            "\tusing C = vector<bitset<SZ>>;",
            "\tusing C::assign;",
            "\tZ2_matrix &operator+=(const Z2_matrix &M){",
            "\t\tassert(n == M.n && m == M.m);",
            "\t\tfor(int i = 0; i < n; ++ i) (*this)[i] ^= M[i];",
            "\t\treturn *this;",
            "\t}",
            "\tZ2_matrix operator+(const Z2_matrix &M) const{",
            "\t\tZ2_matrix res(n, m); res += M;",
            "\t\treturn res;",
            "\t}",
            "\tZ2_matrix operator*(const Z2_matrix &otr) const{",
            "\t\tassert(m == otr.n);",
            "\t\tint l = otr.m;",
            "\t\tZ2_matrix res(n, l);",
            "\t\tvector<bitset<SZ>> temp(l);",
            "\t\tfor(int i = 0; i < l; ++ i) for(int j = 0; j < m; ++ j) temp[i][j] = otr[j][i];",
            "\t\tfor(int i = 0; i < n; ++ i) for(int j = 0; j < l; ++ j) res[i][j] = ((*this)[i] & temp[j]).count() & 1;",
            "\t\treturn res;",
            "\t}",
            "\tZ2_matrix &operator*=(const Z2_matrix &otr){",
            "\t\treturn *this = *this * otr;",
            "\t}",
            "\tZ2_matrix &operator*=(bool c){",
            "\t\tif(c) for(int i = 0; i < n; ++ i) (*this)[i].flip();",
            "\t\treturn *this;",
            "\t}",
            "\tZ2_matrix operator*(bool c) const{",
            "\t\tZ2_matrix res(*this); res *= c;",
            "\t\treturn res;",
            "\t}",
            "\tZ2_matrix &operator^=(long long e){",
            "\t\tZ2_matrix res(n, n, true);",
            "\t\tfor(; e; *this *= *this, e >>= 1) if(e & 1) res *= *this;",
            "\t\treturn *this = res;",
            "\t}",
            "\tZ2_matrix operator^(long long e) const{",
            "\t\tassert(n == m);",
            "\t\tZ2_matrix res(*this); res ^= e;",
            "\t\treturn res;",
            "\t}",
            "\tbool det() const{",
            "\t\tassert(n == m);",
            "\t\tZ2_matrix temp(*this);",
            "\t\tfor(int i = 0; i < n; ++ i){",
            "\t\t\tfor(int j = i + 1; j < n; ++ j) if(temp[j][i]){",
            "\t\t\t\tif(temp[i][i]) temp[j] ^= temp[i];",
            "\t\t\t\telse swap(temp[i], temp[j]);",
            "\t\t\t}",
            "\t\t\tif(!temp[i][i]) return false;",
            "\t\t}",
            "\t\treturn true;",
            "\t}",
            "\tint n, m;",
            "\tZ2_matrix(int n, int m, bool init_diagonal = false, bool init_off_diagonal = false): n(n), m(m){",
            "\t\tassign(n, {});",
            "\t\tfor(int i = 0; i < n; ++ i) for(int j = 0; j < m; ++ j) (*this)[i][j] = i == j ? init_diagonal : init_off_diagonal;",
            "\t}",
            "\tZ2_matrix(const C &arr): n((int)arr.size()), m((int)arr[0].size()){",
            "\t\tassign(n, {});",
            "\t\tfor(int i = 0; i < n; ++ i) for(int j = 0; j < m; ++ j) (*this)[i][j] = arr[i][j];",
            "\t}",
            "};",
            "template<size_t SZ>",
            "Z2_matrix<SZ> operator*(bool c, Z2_matrix<SZ> M){",
            "\tif(c) for(int i = 0; i < M.n; ++ i) M[i].flip();",
            "\treturn M;",
            "}"
        ],
        "description": "tranxuanbach"
    }
}