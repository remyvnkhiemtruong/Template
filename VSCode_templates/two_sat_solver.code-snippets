{
    "tranxuanbach": {
        "prefix": "two_sat_solver",
        "body": [
            "struct two_sat_solver{",
            "private:",
            "\tint n;",
            "\tvector<vector<int>> adj;",
            "\tvector<int> val, comp, z;",
            "public:",
            "\tvector<int> value;",
            "\ttwo_sat_solver(int n = 0): n(n), adj(n << 1){ }",
            "\tint add_variable(){",
            "\t\tadj.emplace_back();",
            "\t\tadj.emplace_back();",
            "\t\treturn n ++;",
            "\t}",
            "\tvoid either(int u, int v){",
            "\t\tu = max(2 * u, -1 - 2 * u);",
            "\t\tv = max(2 * v, -1 - 2 * v);",
            "\t\tadj[u].push_back(v ^ 1);",
            "\t\tadj[v].push_back(u ^ 1);",
            "\t}",
            "\tvoid implies(int u, int v){",
            "\t\teither(~u, v);",
            "\t}",
            "\tvoid equals(int u, int v){",
            "\t\teither(~u, v), either(u, ~v);",
            "\t}",
            "\tvoid differs(int u, int v){",
            "\t\teither(u, v), either(~u, ~v);",
            "\t}",
            "\tvoid set_value(int u, bool x = true){",
            "\t\tx ? either(u, u) : either(~u, ~u);",
            "\t}",
            "\tvoid at_most_one(const vector<int> &arr){",
            "\t\tif((int)arr.size() <= 1) return;",
            "\t\tint cur = ~arr[0];",
            "\t\tfor(auto u = 2; u < (int)arr.size(); ++ u){",
            "\t\t\tint next = add_variable();",
            "\t\t\teither(cur, ~arr[u]), either(cur, next), either(~arr[u], next);",
            "\t\t\tcur = ~next;",
            "\t\t}",
            "\t\teither(cur, ~arr[1]);",
            "\t}",
            "\tint time, comp_cnt;",
            "\tint dfs(int u){",
            "\t\tint low = val[u] = ++ time, v;",
            "\t\tz.push_back(u);",
            "\t\tfor(auto v: adj[u]) if(!~comp[v]) low = min(low, val[v] ?: dfs(v));",
            "\t\t++ time;",
            "\t\tif(low == val[u]){",
            "\t\t\tdo{",
            "\t\t\t\tv = z.back();",
            "\t\t\t\tz.pop_back();",
            "\t\t\t\tcomp[v] = comp_cnt;",
            "\t\t\t\tif(value[v >> 1] == -1) value[v >> 1] = v & 1;",
            "\t\t\t}while(v != u);",
            "\t\t\tcomp_cnt ++;",
            "\t\t}",
            "\t\treturn val[u] = low;",
            "\t}",
            "\t// O(n)",
            "\tbool solve(){",
            "\t\tvalue.assign(n, -1);",
            "\t\tval.assign(2 * n, 0);",
            "\t\tcomp.assign(2 * n, -1);",
            "\t\ttime = comp_cnt = 0;",
            "\t\tfor(auto u = 0; u < n << 1; ++ u) if(!~comp[u]) dfs(u);",
            "\t\tfor(auto u = 0; u < n; ++ u) if(comp[u << 1] == comp[u << 1 ^ 1]) return false;",
            "\t\treturn true;",
            "\t}",
            "\t// Enumerate solutions while act_while() returns true.",
            "\t// O(n^2 + (m + n * (# of solutions found))*S/w)",
            "\ttemplate<size_t S>",
            "\tbool enumerate_solutions(auto act_while){",
            "\t\tassert(2 * n <= S);",
            "\t\tif(!solve()) return false;",
            "\t\tfill(value.begin(), value.end(), -1);",
            "\t\tbitset<S> has_value;",
            "\t\tvector<vector<int>> has(comp_cnt);",
            "\t\tvector<bitset<S>> reachable(n << 1);",
            "\t\tfor(auto u = 0; u < n << 1; ++ u) has[comp[u]].push_back(u);",
            "\t\tvector<int> vis(comp_cnt, -1);",
            "\t\tfor(auto t = 0; t < comp_cnt; ++ t){",
            "\t\t\tint u = has[t][0];",
            "\t\t\tvis[t] = t;",
            "\t\t\tfor(auto v: has[t]){",
            "\t\t\t\treachable[u].set(v);",
            "\t\t\t\tfor(auto w: adj[v]) if(vis[comp[w]] != t){",
            "\t\t\t\t\tvis[comp[w]] = t;",
            "\t\t\t\t\treachable[u] |= reachable[w];",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t\tfor(auto v: has[t]) reachable[v] = reachable[u];",
            "\t\t}",
            "\t\tfor(auto u = 0; u < n << 1; ++ u){",
            "\t\t\tif(!reachable[u][u ^ 1]) continue;",
            "\t\t\thas_value[u] = has_value[u ^ 1] = true;",
            "\t\t\tvalue[u >> 1] = ~u & 1;",
            "\t\t\tfor(auto v = 0; v < n << 1; ++ v) if(reachable[u ^ 1][v]){",
            "\t\t\t\thas_value[v] = has_value[v ^ 1] = true;",
            "\t\t\t\tvalue[v >> 1] = v & 1;",
            "\t\t\t}",
            "\t\t}",
            "\t\tvector<bitset<S>> delta(comp_cnt);",
            "\t\tauto dfs = [&](auto self, int t)->bool{",
            "\t\t\tif(!~t) return act_while(value);",
            "\t\t\tint u = has[t][0];",
            "\t\t\tif(~value[u >> 1]) return self(self, t - 1);",
            "\t\t\tfor(auto v: has[t]){",
            "\t\t\t\thas_value[v] = has_value[v ^ 1] = true;",
            "\t\t\t\tvalue[v >> 1] = ~v & 1;",
            "\t\t\t}",
            "\t\t\tif(!self(self, t - 1)) return false;",
            "\t\t\tfor(auto v: has[t]) value[v >> 1] = v & 1;",
            "\t\t\tdelta[t] = reachable[u] & ~has_value;",
            "\t\t\tfor(auto v = delta[t]._Find_first(); v != S; v = delta[t]._Find_next(v)){",
            "\t\t\t\thas_value[v] = has_value[v ^ 1] = true;",
            "\t\t\t\tvalue[v >> 1] = v & 1;",
            "\t\t\t}",
            "\t\t\tif(!self(self, t - 1)) return false;",
            "\t\t\tfor(auto v: has[t]){",
            "\t\t\t\thas_value[v] = has_value[v ^ 1] = false;",
            "\t\t\t\tvalue[v >> 1] = -1;",
            "\t\t\t}",
            "\t\t\tfor(auto v = delta[t]._Find_first(); v != S; v = delta[t]._Find_next(v)){",
            "\t\t\t\thas_value[v] = has_value[v ^ 1] = false;",
            "\t\t\t\tvalue[v >> 1] = -1;",
            "\t\t\t}",
            "\t\t\treturn true;",
            "\t\t};",
            "\t\tdfs(dfs, comp_cnt - 1);",
            "\t\treturn true;",
            "\t}",
            "};"
        ],
        "description": "tranxuanbach"
    }
}