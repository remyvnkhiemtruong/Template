{
    "tranxuanbach": {
        "prefix": "dinic_maximum_flow",
        "body": [
            "// Requires flow_network",
            "template<class T>",
            "struct dinic_maximum_flow{",
            "\tstatic constexpr T eps = (T)1e-9, inf = numeric_limits<T>::max();",
            "\tflow_network<T> &F;",
            "\tdinic_maximum_flow(flow_network<T> &F): F(F), ptr(F.n), level(F.n), q(F.n){ }",
            "\tvector<int> ptr, level, q;",
            "\tbool bfs(int source, int sink){",
            "\t\tfill(level.begin(), level.end(), -1);",
            "\t\tq[0] = sink;",
            "\t\tlevel[sink] = 0;",
            "\t\tfor(auto beg = 0, end = 1; beg < end; ){",
            "\t\t\tint i = q[beg ++];",
            "\t\t\tfor(auto ind: F.adj[i]){",
            "\t\t\t\tauto &e = F.edge[ind];",
            "\t\t\t\tauto &re = F.edge[ind ^ 1];",
            "\t\t\t\tif(re.capacity - re.flow > eps && level[e.to] == -1){",
            "\t\t\t\t\tlevel[e.to] = level[i] + 1;",
            "\t\t\t\t\tif(e.to == source) return true;",
            "\t\t\t\t\tq[end ++] = e.to;",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t}",
            "\t\treturn false;",
            "\t}",
            "\tT dfs(int u, T w, int sink){",
            "\t\tif(u == sink) return w;",
            "\t\tint &j = ptr[u];",
            "\t\twhile(j >= 0){",
            "\t\t\tint ind = F.adj[u][j];",
            "\t\t\tauto &e = F.edge[ind];",
            "\t\t\tif(e.capacity - e.flow > eps && level[e.to] == level[u] - 1){",
            "\t\t\t\tT flow = dfs(e.to, min(e.capacity - e.flow, w), sink);",
            "\t\t\t\tif(flow > eps){",
            "\t\t\t\t\tF.add_flow(ind, flow);",
            "\t\t\t\t\treturn flow;",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t\t-- j;",
            "\t\t}",
            "\t\treturn 0;",
            "\t}",
            "\t// Find a maximum source-sink flow",
            "\t// O(V^2 E) ( O(E min(V^2/3, E^1/2)) for unit network )",
            "\tT maximum_flow(int source, int sink){",
            "\t\tassert(0 <= source && source < F.n && 0 <= sink && sink < F.n);",
            "\t\tT flow = 0;",
            "\t\twhile(bfs(source, sink)){",
            "\t\t\tfor(auto i = 0; i < F.n; ++ i) ptr[i] = (int)F.adj[i].size() - 1;",
            "\t\t\tT sum = 0;",
            "\t\t\twhile(true){",
            "\t\t\t\tT add = dfs(source, inf, sink);",
            "\t\t\t\tif(add <= eps) break;",
            "\t\t\t\tsum += add;",
            "\t\t\t}",
            "\t\t\tif(sum <= eps) break;",
            "\t\t\tflow += sum;",
            "\t\t}",
            "\t\treturn flow;",
            "\t}",
            "\t// Find a minimum source-sink cut",
            "\t// O(V^2 E) ( O(E min(V^2/3, E^1/2)) for unit network )",
            "\ttuple<T, vector<int>, vector<int>> minimum_cut(int source, int sink){",
            "\t\tT cut_weight = maximum_flow(source, sink);",
            "\t\tvector<int> left, right;",
            "\t\tfor(auto u = 0; u < F.n; ++ u) (!~level[u] ? left : right).push_back(u);",
            "\t\treturn {cut_weight, left, right};",
            "\t}",
            "};"
        ],
        "description": "tranxuanbach"
    }
}