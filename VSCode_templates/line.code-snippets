{
    "tranxuanbach": {
        "prefix": "line",
        "body": [
            "// Requires point",
            "template<class T>",
            "struct line{",
            "\tpoint<T> p{}, d{1, 0}; // p + d*t",
            "\tline(){ }",
            "\ttemplate<class U>",
            "\tline(const line<U> &l): p(l.p), d(l.d){ }",
            "\ttemplate<class U, class V>",
            "\tline(const point<U> &p, const point<V> &q, bool Two_Points = true): p(p), d(Two_Points ? q - p : q){ }",
            "\tline(const point<T> &d): p(), d(d){ }",
            "\tline(T a, T b, T c): p(abs(a) > T(1e-9) ? -c / a : 0, abs(a) <= T(1e-9) && abs(b) > T(1e-9) ? -c / b : 0), d(-b, a){ }",
            "\tfriend istream &operator>>(istream &in, line<T> &l){",
            "\t\tin >> l.p >> l.d, l.d -= l.p;",
            "\t\treturn in;",
            "\t}",
            "\tfriend ostream &operator<<(ostream &out, const line<T> &l){",
            "\t\treturn out << \"{\" << l.p << \" -> \" << l.q() << \"}\";",
            "\t}",
            "\tbool degenerate() const{",
            "\t\tif constexpr(is_floating_point_v<T>) return d.norm() <= 1e-9;",
            "\t\telse return d == point<T>();",
            "\t}",
            "\tpoint<T> q() const{",
            "\t\treturn p + d;",
            "\t}",
            "\tline &flip(){",
            "\t\tp += d;",
            "\t\td = -d;",
            "\t\treturn *this;",
            "\t}",
            "\tline flipped() const{",
            "\t\treturn line(*this).flip();",
            "\t}",
            "\t// d.y * (X - p.x) - d.x * (Y - p.y) = 0",
            "\ttuple<T, T, T> coef() const{",
            "\t\treturn {d.y, -d.x, d.perp() * p};",
            "\t}",
            "\tbool parallel_to(const line<T> &L) const{",
            "\t\treturn abs(d ^ L.d) <= 1e-9;",
            "\t}",
            "\tline<double> translate(T x) const{",
            "\t\tauto dir = d.perp();",
            "\t\treturn {point<double>(p) + dir.unit() * x, d, false};",
            "\t}",
            "\tline<long double> translatel(T x) const{",
            "\t\tauto dir = d.perp();",
            "\t\treturn {point<long double>(p) + dir.unit_l() * x, d, false};",
            "\t}",
            "\tbool on_left(const point<T> &r) const{",
            "\t\treturn (r - p ^ d) < 0;",
            "\t}",
            "\tbool on_right(const point<T> &r) const{",
            "\t\treturn (r - p ^ d) > 0;",
            "\t}",
            "\tbool on_line(const point<T> &r) const{",
            "\t\treturn abs(r - p ^ d) <= 1e-9;",
            "\t}",
            "\tbool on_ray(const point<T> &r) const{",
            "\t\treturn abs(r - p ^ d) <= 1e-9 && (r - p) * d >= 0;",
            "\t}",
            "\tbool on_segment(const point<T> &r) const{",
            "\t\tif(abs(r - p ^ d) > 1e-9) return false;",
            "\t\tauto x = (r - p) * d;",
            "\t\treturn 0 <= x && x <= d.squared_norm();",
            "\t}",
            "\tbool on_open_segment(const point<T> &r) const{",
            "\t\tif(abs(r - p ^ d) > 1e-9) return false;",
            "\t\tauto x = (r - p) * d;",
            "\t\treturn 0 < x && x < d.squared_norm();",
            "\t}",
            "\tdouble distance_to_line(const point<T> &r) const{",
            "\t\treturn abs(r - p ^ d) / d.norm();",
            "\t}",
            "\tlong double distance_to_line_l(const point<T> &r) const{",
            "\t\treturn abs(r - p ^ d) / d.norm_l();",
            "\t}",
            "\tdouble distance_to_ray(const point<T> &r) const{",
            "\t\treturn (r - p) * d <= 0 ? distance(p, r) : distance_to_line(r);",
            "\t}",
            "\tlong double distance_to_ray_l(const point<T> &r) const{",
            "\t\treturn (r - p) * d <= 0 ? distance_l(p, r) : distance_to_line_l(r);",
            "\t}",
            "\tdouble distance_to_segment(const point<T> &r) const{",
            "\t\tauto x = (r - p) * d;",
            "\t\treturn x <= 0 ? distance(p, r) : x >= d.squared_norm() >= 0 ? distance(q(), r) : distance_to_line(r);",
            "\t}",
            "\tlong double distance_to_segment_l(const point<T> &r) const{",
            "\t\tauto x = (r - p) * d;",
            "\t\treturn x <= 0 ? distance_l(p, r) : x >= d.squared_norm() ? distance_l(q(), r) : distance_to_line_l(r);",
            "\t}",
            "\tpoint<double> projection(const point<T> &r) const{",
            "\t\treturn point<double>(p) + (point<double>(r) - point<double>(p)) * d / d.squared_norm() * point<double>(d);",
            "\t}",
            "\tpoint<long double> projection_l(const point<T> &r) const{",
            "\t\treturn point<long double>(p) + (point<long double>(r) - point<long double>(p)) * d / d.squared_norm() * point<long double>(d);",
            "\t}",
            "\t// T must be a field.",
            "\tpoint<T> projection_f(const point<T> &r) const{",
            "\t\treturn point<T>(p) + (r - p) * d / d.squared_norm() * point<T>(d);",
            "\t}",
            "\tpoint<double> reflection(const point<T> &r) const{",
            "\t\treturn 2.0 * projection(r) - point<double>(r);",
            "\t}",
            "\tpoint<long double> reflection_l(const point<T> &r) const{",
            "\t\treturn 2.0l * projection_l(r) - point<long double>(r);",
            "\t}",
            "\t// T must be a field.",
            "\tpoint<T> reflection_f(const point<T> &r) const{",
            "\t\treturn T{2} * projection_f(r) - point<T>(r);",
            "\t}",
            "\tpoint<double> closest_point_on_segment(const point<T> &r) const{",
            "\t\tauto x = (r - p) * d;",
            "\t\treturn x <= 0 ? point<double>(p) : x >= d.squared_norm() ? point<double>(q()) : projection(r);",
            "\t}",
            "\tpoint<long double> closest_point_on_segment_l(const point<T> &r) const{",
            "\t\tauto x = (r - p) * d;",
            "\t\treturn x <= 0 ? point<long double>(p) : x >= d.squared_norm() ? point<long double>(q()) : projection_l(r);",
            "\t}",
            "\t// T must be a field.",
            "\tpoint<T> closest_point_on_segment_f(const point<T> &r) const{",
            "\t\tauto x = (r - p) * d;",
            "\t\treturn x <= 0 ? point<T>(p) : x >= d.squared_norm() ? point<T>(q()) : projection_f(r);",
            "\t}",
            "};",
            "",
            "using lineint = line<int>;",
            "using linell = line<long long>;",
            "using linelll = line<__int128_t>;",
            "using lined = line<double>;",
            "using lineld = line<long double>;"
        ],
        "description": "tranxuanbach"
    }
}