{
    "tranxuanbach": {
        "prefix": "monotone_queue_optimization",
        "body": [
            "template<class T, bool GET_MAX = false>",
            "pair<vector<T>, vector<int>> monotone_queue_optimization(const vector<T> &init, auto cost){",
            "\tassert(!init.empty());",
            "\tint n = (int)init.size();",
            "\tvector<T> dp = init;",
            "\tvector<int> prev(n, -1);",
            "\tauto cross = [&](int i, int j){",
            "\t\tint l = j, r = n;",
            "\t\twhile(r - l > 1){",
            "\t\t\tint mid = l + r >> 1;",
            "\t\t\tif constexpr(GET_MAX) dp[i] + cost(i, mid) >= dp[j] + cost(j, mid) ? l = mid : r = mid;",
            "\t\t\telse dp[i] + cost(i, mid) <= dp[j] + cost(j, mid) ? l = mid : r = mid;",
            "\t\t}",
            "\t\treturn l;",
            "\t};",
            "\tdeque<int> q{0};",
            "\tfor(auto i = 1; i < n; ++ i){",
            "\t\tauto x = cost(q.front(), i);",
            "\t\tif constexpr(GET_MAX){",
            "\t\t\twhile(q.size() > 1 && dp[q[0]] + cost(q[0], i) < dp[q[1]] + cost(q[1], i)) q.pop_front();",
            "\t\t\tif(dp[i] < dp[q.front()] + x){",
            "\t\t\t\tdp[i] = dp[q.front()] + x;",
            "\t\t\t\tprev[i] = q.front();",
            "\t\t\t}",
            "\t\t}",
            "\t\telse{",
            "\t\t\twhile(q.size() > 1 && dp[q[0]] + cost(q[0], i) > dp[q[1]] + cost(q[1], i)) q.pop_front();",
            "\t\t\tif(dp[i] > dp[q.front()] + x){",
            "\t\t\t\tdp[i] = dp[q.front()] + x;",
            "\t\t\t\tprev[i] = q.front();",
            "\t\t\t}",
            "\t\t}",
            "\t\twhile(int(q.size()) > 1 && cross(*next(q.rbegin()), *q.rbegin()) >= cross(*q.rbegin(), i)) q.pop_back();",
            "\t\tq.push_back(i);",
            "\t}",
            "\treturn {dp, prev};",
            "}"
        ],
        "description": "tranxuanbach"
    }
}