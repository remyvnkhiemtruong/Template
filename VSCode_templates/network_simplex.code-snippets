{
    "tranxuanbach": {
        "prefix": "network_simplex",
        "body": [
            "// Network simplex for mincost circulation/flow with supply/demand at nodes",
            "// Supports edge lower bounds, negative costs and negative cost cycles",
            "// Flow type should be large enough to hold node supply/excess and sum of all capacities",
            "// Cost type should be large enough to hold costs and potentials (usually >=64 bits)",
            "// CostSum type should be large enough to hold inner product of capacities and costs",
            "// Expected runtime: O(VE) for positive costs, O(EÂ²) for negative costs too",
            "// Usage:",
            "//   network_simplex<int, long long> netw(V);",
            "//   for(edges...){ netw.insert(u, v, lower, upper, unit_cost); }",
            "//   for(nodes...){ netw.set_supply(u, supply); }",
            "//   auto max_flow = netw.mincost_flow();           or mincost_circulation()",
            "//   auto min_cost = netw.get_circulation_cost();",
            "// Source: https://github.com/brunodccarvalho/competitive/blob/master/code/flow/network_simplex.hpp",
            "template<class Flow = long long, class Cost = long long>",
            "struct network_simplex{",
            "\tnetwork_simplex(int V) : V(V), node(V + 1){ }",
            "\tint insert(int u, int v, Flow lower, Flow upper, Cost cost){",
            "\t\tassert(0 <= u && u < V && 0 <= v && v < V && lower <= upper);",
            "\t\treturn edge.push_back({{u, v}, lower, upper, cost}), E ++;",
            "\t}",
            "\tint add_node(){ return node.emplace_back(), V ++; }",
            "\tvoid add_supply(int u, Flow supply){ node[u].supply += supply; }",
            "\tvoid set_supply(int u, Flow supply){ node[u].supply = supply; }",
            "\tvoid update_edge(int e, Flow lower, Flow upper, Cost cost){",
            "\t\tedge[e].lower = lower, edge[e].upper = upper, edge[e].cost = cost;",
            "\t}",
            "\tauto get_supply(int u) const{ return node[u].supply; }",
            "\tauto get_potential(int u) const{ return node[u].pi; }",
            "\tauto get_flow(int e) const{ return edge[e].flow; }",
            "\tauto reduced_cost(int e) const{",
            "\t\tauto [u, v] = edge[e].node;",
            "\t\treturn edge[e].cost + node[u].pi - node[v].pi;",
            "\t}",
            "\t// Get excess for every vertex: excess(u) = flow(out of u) - flow(into u)",
            "\tauto get_excesses() const{",
            "\t\tvector<Flow> excess(V);",
            "\t\tfor(auto e = 0; e < E; ++ e){",
            "\t\t\tauto [u, v] = edge[e].node;",
            "\t\t\texcess[u] += edge[e].flow;",
            "\t\t\texcess[v] -= edge[e].flow;",
            "\t\t}",
            "\t\treturn excess;",
            "\t}",
            "\ttemplate<class CostSum = long long>",
            "\tauto get_circulation_cost() const{",
            "\t\tCostSum sum = 0;",
            "\t\tfor(auto e = 0; e < E; ++ e){",
            "\t\t\tsum += edge[e].flow * CostSum(edge[e].cost);",
            "\t\t}",
            "\t\treturn sum;",
            "\t}",
            "\tvoid verify() const{",
            "\t\tfor(auto e = 0; e < E; ++ e){",
            "\t\t\tassert(edge[e].lower <= edge[e].flow && edge[e].flow <= edge[e].upper);",
            "\t\t\tassert(edge[e].flow == edge[e].lower || reduced_cost(e) <= 0);",
            "\t\t\tassert(edge[e].flow == edge[e].upper || reduced_cost(e) >= 0);",
            "\t\t}",
            "\t}",
            "\t// Run as circulation: find a feasible circulation and fail if one doesn't exist.",
            "\t// Also checks for zero supply sum. Usually this is not what you want.",
            "\tbool mincost_circulation(){",
            "\t\tstatic constexpr bool INFEASIBLE = false, OPTIMAL = true;",
            "\t\t// Assert supply sum is zero",
            "\t\tFlow sum_supply = 0;",
            "\t\tfor(auto u = 0; u < V; ++ u){",
            "\t\t\tsum_supply += node[u].supply;",
            "\t\t}",
            "\t\tif(sum_supply != 0){",
            "\t\t\treturn INFEASIBLE;",
            "\t\t}",
            "\t\trun();",
            "\t\t// Assert zero flow through artificial edges",
            "\t\tfor(auto e = E; e < E + V; ++ e){",
            "\t\t\tif(edge[e].flow != 0){",
            "\t\t\t\tedge.resize(E);",
            "\t\t\t\treturn INFEASIBLE;",
            "\t\t\t}",
            "\t\t}",
            "\t\tedge.resize(E);",
            "\t\treturn OPTIMAL;",
            "\t}",
            "\t// Run as mincost maxflow: ignore extra artificial flow and non-zero supply sum",
            "\t// You must set supply at the source(s) and demand at the sink(s) (inf for maxflow)",
            "\t// The excess at a supply/source node u will be in the range [0,supply[u]].",
            "\t// The excess at a demand/sink   node u will be in the range [supply[u],0].",
            "\tFlow mincost_flow(){",
            "\t\trun();",
            "\t\tFlow maxflow = 0;",
            "\t\tfor(auto e = E; e < E + V; ++ e){",
            "\t\t\tif(edge[e].node[1] == V){",
            "\t\t\t\tmaxflow += edge[e].upper - edge[e].flow;",
            "\t\t\t}",
            "\t\t}",
            "\t\tedge.resize(E);",
            "\t\treturn maxflow;",
            "\t}",
            "\t// Implementation",
            "\tenum ArcState : int8_t{ STATE_UPPER = -1, STATE_TREE = 0, STATE_LOWER = 1 };",
            "\tauto signed_reduced_cost(int e) const{ return edge[e].state * reduced_cost(e); }",
            "\tstruct int_lists{",
            "\t\tint L, N;",
            "\t\tvector<int> next, prev;",
            "\t\t// L: lists are [0...L), N: integers are [0...N)",
            "\t\texplicit int_lists(int L = 0, int N = 0){ assign(L, N); }",
            "\t\tint rep(int l) const{ return l + N; }",
            "\t\tint head(int l) const{ return next[rep(l)]; }",
            "\t\tint tail(int l) const{ return prev[rep(l)]; }",
            "\t\tvoid push_front(int l, int n){ meet(rep(l), n, head(l)); }",
            "\t\tvoid push_back(int l, int n){ meet(tail(l), n, rep(l)); }",
            "\t\tvoid erase(int n){ meet(prev[n], next[n]); }",
            "\t\tvoid clear(){",
            "\t\t\tiota(begin(next) + N, end(next), N);",
            "\t\t\tiota(begin(prev) + N, end(prev), N);",
            "\t\t}",
            "\t\tvoid assign(int L, int N){",
            "\t\t\tthis->L = L, this->N = N;",
            "\t\t\tnext.resize(N + L), prev.resize(N + L), clear();",
            "\t\t}",
            "\t  private:",
            "\t\tinline void meet(int u, int v){ next[u] = v, prev[v] = u; }",
            "\t\tinline void meet(int u, int v, int w){ meet(u, v), meet(v, w); }",
            "\t};",
            "\tstruct Node{",
            "\t\tint parent, pred;",
            "\t\tFlow supply;",
            "\t\tCost pi;",
            "\t};",
            "\tstruct Edge{",
            "\t\tint node[2];",
            "\t\tFlow lower, upper;",
            "\t\tCost cost;",
            "\t\tFlow flow = 0;",
            "\t\tArcState state = STATE_LOWER;",
            "\t};",
            "\tint V, E = 0;",
            "\tvector<Node> node;",
            "\tvector<Edge> edge;",
            "\tint_lists children;",
            "\tint next_arc = 0, block_size = 0;",
            "\tvector<int> bfs, perm; // scratchpad for bfs and upwards walk / random permutation",
            "\tvoid run(){",
            "\t\t// Remove non-zero lower bounds and compute artif_cost as sum of all costs",
            "\t\tCost artif_cost = 1;",
            "\t\tfor(auto e = 0; e < E; ++ e){",
            "\t\t\tauto [u, v] = edge[e].node;",
            "\t\t\tedge[e].flow = 0;",
            "\t\t\tedge[e].state = STATE_LOWER;",
            "\t\t\tedge[e].upper -= edge[e].lower;",
            "\t\t\tnode[u].supply -= edge[e].lower;",
            "\t\t\tnode[v].supply += edge[e].lower;",
            "\t\t\tartif_cost += edge[e].cost < 0 ? -edge[e].cost : edge[e].cost;",
            "\t\t}",
            "\t\tedge.resize(E + V);",
            "\t\tbfs.resize(V + 1);",
            "\t\tchildren.assign(V + 1, V + 1);",
            "\t\t// Add root<->node artificial edges with initial supply for feasible flow",
            "\t\tint root = V;",
            "\t\tnode[root] = {-1, -1, 0, 0};",
            "\t\tfor(auto u = 0, e = E; u < V; ++ u, ++ e){",
            "\t\t\tnode[u].parent = root, node[u].pred = e;",
            "\t\t\tchildren.push_back(root, u);",
            "\t\t\tauto supply = node[u].supply;",
            "\t\t\tif(supply >= 0){",
            "\t\t\t\tnode[u].pi = -artif_cost;",
            "\t\t\t\tedge[e] = {{u, root}, 0, supply, artif_cost, supply, STATE_TREE};",
            "\t\t\t}",
            "\t\t\telse{",
            "\t\t\t\tnode[u].pi = artif_cost;",
            "\t\t\t\tedge[e] = {{root, u}, 0, -supply, artif_cost, -supply, STATE_TREE};",
            "\t\t\t}",
            "\t\t}",
            "\t\t// We want to, hopefully, find a pivot edge in O(sqrt(E))",
            "\t\t// This should be <E to check different sets of edges in each select()",
            "\t\t// Otherwise we are vulnerable to simplex killers",
            "\t\tblock_size = max(int(ceil(sqrt(E + V))), min(5, V + 1));",
            "\t\tnext_arc = 0;",
            "\t\t// Random permutation of the edges; helps with wide graphs and killer test cases",
            "\t\tstatic mt19937 rng(random_device{}());",
            "\t\tperm.resize(E + V);",
            "\t\tiota(begin(perm), end(perm), 0);",
            "\t\tshuffle(begin(perm), end(perm), rng);",
            "\t\t// Pivot until we're done",
            "\t\tint in_arc = select_pivot_edge();",
            "\t\twhile(in_arc != -1){",
            "\t\t\tpivot(in_arc);",
            "\t\t\tin_arc = select_pivot_edge();",
            "\t\t}",
            "\t\t// Restore flows and supplies",
            "\t\tfor(auto e = 0; e < E; ++ e){",
            "\t\t\tauto [u, v] = edge[e].node;",
            "\t\t\tedge[e].flow += edge[e].lower;",
            "\t\t\tedge[e].upper += edge[e].lower;",
            "\t\t\tnode[u].supply += edge[e].lower;",
            "\t\t\tnode[v].supply -= edge[e].lower;",
            "\t\t}",
            "\t}",
            "\tint select_pivot_edge(){",
            "\t\t// lemon-like block search, check block_size edges and pick the best one",
            "\t\tCost minimum = 0;",
            "\t\tint in_arc = -1, count = block_size, seen_edges = E + V;",
            "\t\tfor(auto &e = next_arc; seen_edges -- > 0; e = e + 1 == E + V ? 0 : e + 1){",
            "\t\t\tint x = perm[e];",
            "\t\t\tif(minimum > signed_reduced_cost(x)){",
            "\t\t\t\tminimum = signed_reduced_cost(x);",
            "\t\t\t\tin_arc = x;",
            "\t\t\t}",
            "\t\t\tif(-- count == 0 && minimum < 0){",
            "\t\t\t\tbreak;",
            "\t\t\t}",
            "\t\t\telse if(count == 0){",
            "\t\t\t\tcount = block_size;",
            "\t\t\t}",
            "\t\t}",
            "\t\treturn in_arc;",
            "\t}",
            "\tvoid pivot(int in_arc){",
            "\t\t// Find join node (lca of u_in and v_in)",
            "\t\tauto [u_in, v_in] = edge[in_arc].node;",
            "\t\tint a = u_in, b = v_in;",
            "\t\twhile(a != b){",
            "\t\t\ta = node[a].parent == -1 ? v_in : node[a].parent;",
            "\t\t\tb = node[b].parent == -1 ? u_in : node[b].parent;",
            "\t\t}",
            "\t\tint join = a;",
            "\t\t// Orient edge so that we add flow to source->target",
            "\t\tint source = edge[in_arc].state == STATE_LOWER ? u_in : v_in;",
            "\t\tint target = edge[in_arc].state == STATE_LOWER ? v_in : u_in;",
            "\t\tenum OutArcSide{ SAME_EDGE, SOURCE_SIDE, TARGET_SIDE };",
            "\t\tFlow flow_delta = edge[in_arc].upper;",
            "\t\tOutArcSide side = SAME_EDGE;",
            "\t\tint u_out = -1;",
            "\t\t// Go up the cycle from source to the join node",
            "\t\tfor(auto u = source; u != join && flow_delta; u = node[u].parent){",
            "\t\t\tint e = node[u].pred;",
            "\t\t\tbool edge_down = u == edge[e].node[1];",
            "\t\t\tFlow d = edge_down ? edge[e].upper - edge[e].flow : edge[e].flow;",
            "\t\t\tif(flow_delta > d){",
            "\t\t\t\tflow_delta = d;",
            "\t\t\t\tu_out = u;",
            "\t\t\t\tside = SOURCE_SIDE;",
            "\t\t\t}",
            "\t\t}",
            "\t\t// Go up the cycle from target to the join node",
            "\t\tfor(auto u = target; u != join && (flow_delta || side != TARGET_SIDE);",
            "\t\t\t u = node[u].parent){",
            "\t\t\tint e = node[u].pred;",
            "\t\t\tbool edge_up = u == edge[e].node[0];",
            "\t\t\tFlow d = edge_up ? edge[e].upper - edge[e].flow : edge[e].flow;",
            "\t\t\tif(flow_delta >= d){",
            "\t\t\t\tflow_delta = d;",
            "\t\t\t\tu_out = u;",
            "\t\t\t\tside = TARGET_SIDE;",
            "\t\t\t}",
            "\t\t}",
            "\t\t// Augment along the cycle",
            "\t\tif(flow_delta){",
            "\t\t\tauto delta = edge[in_arc].state * flow_delta;",
            "\t\t\tedge[in_arc].flow += delta;",
            "\t\t\tfor(auto u = edge[in_arc].node[0]; u != join; u = node[u].parent){",
            "\t\t\t\tint e = node[u].pred;",
            "\t\t\t\tedge[e].flow += u == edge[e].node[0] ? -delta : +delta;",
            "\t\t\t}",
            "\t\t\tfor(auto u = edge[in_arc].node[1]; u != join; u = node[u].parent){",
            "\t\t\t\tint e = node[u].pred;",
            "\t\t\t\tedge[e].flow += u == edge[e].node[0] ? +delta : -delta;",
            "\t\t\t}",
            "\t\t}",
            "\t\tif(side == SAME_EDGE){",
            "\t\t\tedge[in_arc].state = ArcState(-edge[in_arc].state);",
            "\t\t\treturn;",
            "\t\t}",
            "\t\t// Replace out_arc with in_arc in the spanning tree",
            "\t\tint out_arc = node[u_out].pred;",
            "\t\tedge[in_arc].state = STATE_TREE;",
            "\t\tedge[out_arc].state = edge[out_arc].flow ? STATE_UPPER : STATE_LOWER;",
            "\t\t// Put u_in on the same side as u_out",
            "\t\tu_in = side == SOURCE_SIDE ? source : target;",
            "\t\tv_in = side == SOURCE_SIDE ? target : source;",
            "\t\t// Walk up from u_in to u_out, then fix parent/pred/child pointers backwards",
            "\t\tint i = 0, S = 0;",
            "\t\tfor(auto u = u_in; u != u_out; u = node[u].parent){",
            "\t\t\tbfs[S ++] = u;",
            "\t\t}",
            "\t\tfor(i = S - 1; i >= 0; -- i){",
            "\t\t\tint u = bfs[i], p = node[u].parent;",
            "\t\t\tchildren.erase(p);",
            "\t\t\tchildren.push_back(u, p);",
            "\t\t\tnode[p].parent = u;",
            "\t\t\tnode[p].pred = node[u].pred;",
            "\t\t}",
            "\t\tchildren.erase(u_in);",
            "\t\tchildren.push_back(v_in, u_in);",
            "\t\tnode[u_in].parent = v_in;",
            "\t\tnode[u_in].pred = in_arc;",
            "\t\t// Adjust potentials in the subtree of u_in (pi_delta is not 0)",
            "\t\tCost current_pi = reduced_cost(in_arc);",
            "\t\tCost pi_delta = u_in == edge[in_arc].node[0] ? -current_pi : +current_pi;",
            "\t\tbfs[0] = u_in;",
            "\t\tfor(i = 0, S = 1; i < S; ++ i){",
            "\t\t\tint u = bfs[i];",
            "\t\t\tnode[u].pi += pi_delta;",
            "\t\t\tfor(auto v = children.head(u); v != children.rep(u); v = children.next[v]){",
            "\t\t\t\tbfs[S ++] = v;",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "};"
        ],
        "description": "tranxuanbach"
    }
}