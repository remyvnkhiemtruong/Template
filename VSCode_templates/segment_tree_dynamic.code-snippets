{
    "tranxuanbach": {
        "prefix": "segment_tree_dynamic",
        "body": [
            "template<bool HAS_QUERY, bool HAS_UPDATE, class B, class T, class U, class F1, class F2, class F3, class F4>",
            "struct segment_tree_dynamic_base{",
            "\tstatic_assert(HAS_QUERY || HAS_UPDATE);",
            "#define ifQ if constexpr(HAS_QUERY)",
            "#define ifU if constexpr(HAS_UPDATE)",
            "\tB low, high; // All coordinates lie in range [low, high)",
            "\tF1 T_init; // T_init(l, r): initial aggregated value for [l, r)",
            "\tvector<int> left; // left child",
            "\tvector<int> right; // right child",
            "\tvector<int> pv; // parent",
            "\tvector<T> data;",
            "\tvector<U> data_action;",
            "\tF2 TT; // monoid operation (always adjacent)",
            "\tT T_id; // monoid identity",
            "\tF3 UU; // monoid operation (superset, subset)",
            "\tU U_id; // monoid identity",
            "\tF4 UT; // action of U on T (superset, subset)",
            "\tsegment_tree_dynamic_base(B low, B high, F1 T_init, F2 TT, T T_id, F3 UU, U U_id, F4 UT): low(low), high(high), T_init(T_init), TT(TT), T_id(T_id), UU(UU), U_id(U_id), UT(UT){",
            "\t\tassert(low < high);",
            "\t\tnew_state(T_init(low, high), U_id);",
            "\t}",
            "\tvoid extend(int u, B l, B r){",
            "\t\tif(!~left[u]){",
            "\t\t\tB m = l + (r - l >> 1);",
            "\t\t\tleft[u] = new_state(T_init(l, m), U_id);",
            "\t\t\tright[u] = new_state(T_init(m, r), U_id);",
            "\t\t\tpv[left[u]] = pv[right[u]] = u;",
            "\t\t}",
            "\t}",
            "\tint last_state(){",
            "\t\treturn (int)data.size() - 1;",
            "\t}",
            "\tint new_state(T x, U f){",
            "\t\tleft.push_back(-1);",
            "\t\tright.push_back(-1);",
            "\t\tpv.push_back(-1);",
            "\t\tifQ data.push_back(x);",
            "\t\tifU data_action.push_back(f);",
            "\t\treturn last_state();",
            "\t}",
            "\tvoid push(int u){",
            "\t\tstatic_assert(HAS_UPDATE);",
            "\t\tint v = left[u], w = right[u];",
            "\t\tifQ data[v] = UT(data_action[u], data[v]);",
            "\t\tdata_action[v] = UU(data_action[u], data_action[v]);",
            "\t\tifQ data[w] = UT(data_action[u], data[w]);",
            "\t\tdata_action[w] = UU(data_action[u], data_action[w]);",
            "\t\tdata_action[u] = U_id;",
            "\t}",
            "\t// O(log(n))",
            "\tT query(B p){",
            "\t\tstatic_assert(HAS_QUERY);",
            "\t\tassert(low <= p && p < high);",
            "\t\tint u = 0;",
            "\t\tB l = low, r = high;",
            "\t\twhile(true){",
            "\t\t\tif(r - l == 1) return data[u];",
            "\t\t\textend(u, l, r);",
            "\t\t\tifU push(u);",
            "\t\t\tB m = l + (r - l >> 1);",
            "\t\t\tif(p < m) u = left[u], r = m;",
            "\t\t\telse u = right[u], l = m;",
            "\t\t}",
            "\t}",
            "\t// O(log(n))",
            "\tU query_action(B p){",
            "\t\tstatic_assert(!HAS_QUERY && HAS_UPDATE);",
            "\t\tassert(low <= p && p < high);",
            "\t\tint u = 0;",
            "\t\tB l = low, r = high;",
            "\t\twhile(true){",
            "\t\t\tif(r - l == 1) return data_action[u];",
            "\t\t\textend(u, l, r);",
            "\t\t\tpush(u);",
            "\t\t\tB m = l + (r - l >> 1);",
            "\t\t\tif(p < m) u = left[u], r = m;",
            "\t\t\telse u = right[u], l = m;",
            "\t\t}",
            "\t}",
            "\t// O(log(n))",
            "\tT query(B ql, B qr){",
            "\t\tstatic_assert(HAS_QUERY);",
            "\t\tassert(low <= ql && ql <= qr && qr <= high);",
            "\t\tauto recurse = [&](auto recurse, int u, B l, B r)->T{",
            "\t\t\tif(qr <= l || r <= ql) return T_id;",
            "\t\t\tif(ql <= l && r <= qr) return data[u];",
            "\t\t\textend(u, l, r);",
            "\t\t\tifU push(u);",
            "\t\t\tB m = l + (r - l >> 1);",
            "\t\t\treturn TT(recurse(recurse, left[u], l, m), recurse(recurse, right[u], m, r));",
            "\t\t};",
            "\t\treturn recurse(recurse, 0, low, high);",
            "\t}",
            "\t// O(1)",
            "\tT query_all() const{",
            "\t\tstatic_assert(HAS_QUERY);",
            "\t\treturn data[0];",
            "\t}",
            "\t// O(log(n))",
            "\tvoid set(B p, T x){",
            "\t\tstatic_assert(HAS_QUERY);",
            "\t\tassert(low <= p && p < high);",
            "\t\tint u = 0;",
            "\t\tB l = low, r = high;",
            "\t\twhile(true){",
            "\t\t\tif(r - l == 1){",
            "\t\t\t\tdata[u] = x;",
            "\t\t\t\tbreak;",
            "\t\t\t}",
            "\t\t\textend(u, l, r);",
            "\t\t\tifU push(u);",
            "\t\t\tB m = l + (r - l >> 1);",
            "\t\t\tif(p < m) u = left[u], r = m;",
            "\t\t\telse u = right[u], l = m;",
            "\t\t}",
            "\t\twhile(u > 0){",
            "\t\t\tu = pv[u];",
            "\t\t\tdata[u] = TT(data[left[u]], data[right[u]]);",
            "\t\t}",
            "\t}",
            "\t// O(log(n))",
            "\tvoid set_action(B p, U f){",
            "\t\tstatic_assert(!HAS_QUERY && HAS_UPDATE);",
            "\t\tassert(low <= p && p < high);",
            "\t\tint u = 0;",
            "\t\tB l = low, r = high;",
            "\t\twhile(true){",
            "\t\t\tif(r - l == 1){",
            "\t\t\t\tdata_action[u] = f;",
            "\t\t\t\tbreak;",
            "\t\t\t}",
            "\t\t\textend(u, l, r);",
            "\t\t\tpush(u);",
            "\t\t\tB m = l + (r - l >> 1);",
            "\t\t\tif(p < m) u = left[u], r = m;",
            "\t\t\telse u = right[u], l = m;",
            "\t\t}",
            "\t}",
            "\t// O(log(n))",
            "\tvoid update(B p, U f){",
            "\t\tstatic_assert(HAS_UPDATE);",
            "\t\tassert(low <= p && p < high);",
            "\t\tint u = 0;",
            "\t\tB l = low, r = high;",
            "\t\twhile(true){",
            "\t\t\tif(r - l == 1){",
            "\t\t\t\tifQ data[u] = UT(f, data[u]);",
            "\t\t\t\tdata_action[u] = UU(f, data_action[u]);",
            "\t\t\t\tbreak;",
            "\t\t\t}",
            "\t\t\textend(u, l, r);",
            "\t\t\tpush(u);",
            "\t\t\tB m = l + (r - l >> 1);",
            "\t\t\tif(p < m) u = left[u], r = m;",
            "\t\t\telse u = right[u], l = m;",
            "\t\t}",
            "\t\twhile(u > 0){",
            "\t\t\tu = pv[u];",
            "\t\t\tdata[u] = TT(data[left[u]], data[right[u]]);",
            "\t\t}",
            "\t}",
            "\t// O(log(n))",
            "\tvoid update(B ql, B qr, U f){",
            "\t\tstatic_assert(HAS_UPDATE);",
            "\t\tassert(low <= ql && ql <= qr && qr <= high);",
            "\t\tif(ql == qr) return;",
            "\t\tauto recurse = [&](auto self, int u, B l, B r)->void{",
            "\t\t\tif(qr <= l || r <= ql) return;",
            "\t\t\tif(ql <= l && r <= qr){",
            "\t\t\t\tifQ data[u] = UT(f, data[u]);",
            "\t\t\t\tdata_action[u] = UU(f, data_action[u]);",
            "\t\t\t\treturn;",
            "\t\t\t}",
            "\t\t\textend(u, l, r);",
            "\t\t\tpush(u);",
            "\t\t\tB m = l + (r - l >> 1);",
            "\t\t\tself(self, left[u], l, m), self(self, right[u], m, r);",
            "\t\t\tifQ data[u] = TT(data[left[u]], data[right[u]]);",
            "\t\t};",
            "\t\trecurse(recurse, 0, low, high);",
            "\t}",
            "\t// pred(sum[l, r)) is T, T, ..., T, F, F, ..., F",
            "\t// Returns max r with T",
            "\t// O(log(n))",
            "\tB max_pref(B ql, auto pred){",
            "\t\tstatic_assert(HAS_QUERY);",
            "\t\tassert(low <= ql && ql <= high && pred(T_id));",
            "\t\tif(ql == high) return ql;",
            "\t\tT pref = T_id;",
            "\t\tauto recurse = [&](auto self, int u, B l, B r)->B{",
            "\t\t\tif(r <= ql) return -1;",
            "\t\t\tif(ql <= l && pred(TT(pref, data[u]))){",
            "\t\t\t\tpref = TT(pref, data[u]);",
            "\t\t\t\treturn -1;",
            "\t\t\t}",
            "\t\t\tif(r - l == 1) return l;",
            "\t\t\textend(u, l, r);",
            "\t\t\tifU push(u);",
            "\t\t\tB m = l + (r - l >> 1), p = self(self, left[u], l, m);",
            "\t\t\treturn ~p ? p : self(self, right[u], m, r);",
            "\t\t};",
            "\t\tB qr = recurse(recurse, 0, low, high);",
            "\t\tif(!~qr) qr = high;",
            "\t\treturn qr;",
            "\t}",
            "\t// pred(sum[l, r)) is F, F, ..., F, T, T, ..., T",
            "\t// Returns min l with T",
            "\t// O(log(n))",
            "\tB min_suff(B qr, auto pred){",
            "\t\tstatic_assert(HAS_QUERY);",
            "\t\tassert(low <= qr && qr <= high && pred(T_id));",
            "\t\tif(qr == low) return qr;",
            "\t\tT suff = T_id;",
            "\t\tauto recurse = [&](auto self, int u, B l, B r)->B{",
            "\t\t\tif(qr <= l) return -1;",
            "\t\t\tif(r <= qr && pred(TT(data[u], suff))){",
            "\t\t\t\tsuff = TT(data[u], suff);",
            "\t\t\t\treturn -1;",
            "\t\t\t}",
            "\t\t\tif(r - l == 1) return r;",
            "\t\t\textend(u, l, r);",
            "\t\t\tifU push(u);",
            "\t\t\tB m = l + (r - l >> 1), p = self(self, right[u], m, r);",
            "\t\t\treturn ~p ? p : self(self, left[u], l, m);",
            "\t\t};",
            "\t\tB ql = recurse(recurse, 0, low, high);",
            "\t\tif(!~ql) ql = low;",
            "\t\treturn ql;",
            "\t}",
            "\ttemplate<class output_stream>",
            "\tfriend output_stream &operator<<(output_stream &out, segment_tree_dynamic_base<HAS_QUERY, HAS_UPDATE, B, T, U, F1, F2, F3, F4> seg){",
            "\t\tout << \"{\";",
            "\t\tfor(auto i = 0; i < seg.n; ++ i){",
            "\t\t\tifQ out << seg.query(i);",
            "\t\t\telse out << seg.query_action(i);",
            "\t\t\tif(i != seg.n - 1) out << \", \";",
            "\t\t}",
            "\t\treturn out << '}';",
            "\t}",
            "#undef ifQ",
            "#undef ifU",
            "};",
            "",
            "// Supports query",
            "template<class B, class T, class F1, class F2>",
            "auto make_Q_segment_tree_dynamic(B low, B high, F1 T_init, F2 TT, T T_id){",
            "\tusing U = int;",
            "\tauto _UU = [&](U, U)->U{ return U{}; };",
            "\tauto _UT = [&](U, T)->T{ return T{}; };",
            "\treturn segment_tree_dynamic_base<true, false, B, T, U, F1, F2, decltype(_UU), decltype(_UT)>(low, high, T_init, TT, T_id, _UU, U{}, _UT);",
            "}",
            "// Supports query",
            "template<class B, class T, class F>",
            "auto make_Q_segment_tree_dynamic(B low, B high, F TT, T T_id){",
            "\tauto _T_init = [T_id](B, B){ return T_id; };",
            "\treturn make_Q_segment_tree_dynamic<B, T, decltype(_T_init), F>(low, high, move(_T_init), TT, T_id);",
            "}",
            "// Supports update",
            "template<class B, class U, class F>",
            "auto make_U_segment_tree_dynamic(B low, B high, F UU, U U_id){",
            "\tusing T = int;",
            "\tauto _T_init = [&](B, B)->T{ return T{}; };",
            "\tauto _TT = [&](T, T)->T{ return T{}; };",
            "\tauto _UT = [&](U, T)->T{ return T{}; };",
            "\treturn segment_tree_dynamic_base<false, true, B, T, U, decltype(_T_init), decltype(_TT), F, decltype(_UT)>(low, high, _T_init, _TT, T{}, UU, U_id, _UT);",
            "}",
            "// Supports query and update",
            "template<class B, class T, class U, class F1, class F2, class F3, class F4>",
            "auto make_QU_segment_tree_dynamic(B low, B high, F1 T_init, F2 TT, T T_id, F3 UU, U U_id, F4 UT){",
            "\treturn segment_tree_dynamic_base<true, true, B, T, U, F1, F2, F3, F4>(low, high, T_init, TT, T_id, UU, U_id, UT);",
            "}",
            "// Supports query and update",
            "template<class B, class T, class U, class F1, class F2, class F3>",
            "auto make_QU_segment_tree_dynamic(B low, B high, F1 TT, T T_id, F2 UU, U U_id, F3 UT){",
            "\tauto _T_init = [T_id](B, B){ return T_id; };",
            "\treturn make_QU_segment_tree_dynamic<B, T, U, decltype(_T_init), F1, F2, F3>(low, high, _T_init, TT, T_id, UU, U_id, UT);",
            "}"
        ],
        "description": "tranxuanbach"
    }
}