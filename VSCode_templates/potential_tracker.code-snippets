{
    "tranxuanbach": {
        "prefix": "potential_tracker",
        "body": [
            "// Requires disjoint_set",
            "template<class T>",
            "struct potential_tracker{",
            "\tdisjoint_set<true> dsu;",
            "\tbool globally_valid;",
            "\tvector<int> valid;",
            "\tvector<T> potential;",
            "\tvector<list<int>> has;",
            "\tpotential_tracker(int n): dsu(n), potential(n), globally_valid(true), valid(n, true), has(n){",
            "\t\tfor(auto u = 0; u < n; ++ u) has[u].push_back(u);",
            "\t}",
            "\tvoid add_variable(){",
            "\t\tdsu.make_set();",
            "\t\tvalid.push_back(true);",
            "\t\tpotential.push_back({});",
            "\t\thas.push_back({(int)has.size()});",
            "\t}",
            "\t// Declare that value[v] - value[u] = delta",
            "\tvoid set_difference(int u, int v, T delta){",
            "\t\tassert(0 <= min(u, v) && max(u, v) < (int)valid.size());",
            "\t\tif(!dsu.merge(u, v, [&](int x, int y, bool swapped){",
            "\t\t\tif(!valid[x] || !valid[y]){",
            "\t\t\t\tvalid[x] = false;",
            "\t\t\t\thas[x].splice(has[x].end(), has[y]);",
            "\t\t\t\treturn;",
            "\t\t\t}",
            "\t\t\tdelta = swapped ? potential[v] - delta - potential[u] : potential[u] + delta - potential[v];",
            "\t\t\tfor(auto z: has[y]) potential[z] += delta;",
            "\t\t\thas[x].splice(has[x].end(), has[y]);",
            "\t\t}) && potential[u] + delta != potential[v]) globally_valid = valid[dsu.root(u)] = false;",
            "\t}",
            "\t// u and v is related iff a path",
            "\tbool related(int u, int v){",
            "\t\tassert(0 <= min(u, v) && max(u, v) < (int)valid.size());",
            "\t\treturn dsu.share(u, v);",
            "\t}",
            "\t// If u = -1, returns whether a valid assignment to all variables exists.",
            "\t// Else, returns whether a valid assignment to all variables related to u exists.",
            "\tbool is_valid(int u = -1){",
            "\t\tassert(-1 <= u && u < (int)valid.size());",
            "\t\treturn ~u ? valid[dsu.root(u)] : globally_valid;",
            "\t}",
            "\t// Assume that u and v are related.",
            "\toptional<T> dist(int u, int v){",
            "\t\tassert(0 <= min(u, v) && max(u, v) < (int)valid.size() && dsu.share(u, v));",
            "\t\treturn valid[dsu.root(u)] ? potential[v] - potential[u] : optional<T>();",
            "\t}",
            "};"
        ],
        "description": "tranxuanbach"
    }
}