{
    "tranxuanbach": {
        "prefix": "tree_decomposition_halin_graph",
        "body": [
            "// g must be a tree",
            "// Given is a graph where a cycle joining all nodes of degree 1 in dfs tree is attached to g.",
            "// Returns a tree decomposition {bags, edges} where |bag| <= 4 and (# of bags) <= 4*n",
            "// O(n)",
            "// Requires graph",
            "template<class T>",
            "pair<vector<vector<int>>, vector<array<int, 2>>> tree_decomposition_halin_graph(const graph<T> &g){",
            "\tint n = g.n;",
            "\tassert(n >= 2);",
            "\tif(n <= 4){",
            "\t\tvector<int> bag(n);",
            "\t\tiota(bag.begin(), bag.end(), 0);",
            "\t\treturn {{bag}, {}};",
            "\t}",
            "\tvector<int> order, pe(n, -1);",
            "\tvector<array<int, 2>> leaf(n, {-1, -1});",
            "\tauto dfs = [&](auto self, int u)->void{",
            "\t\torder.push_back(u);",
            "\t\tfor(auto id: g.adj[u]){",
            "\t\t\tif(g.ignore && g.ignore(id) || id == pe[u]) continue;",
            "\t\t\tint v = g(u, id);",
            "\t\t\tpe[v] = id;",
            "\t\t\tself(self, v);",
            "\t\t\tauto [l, r] = leaf[v];",
            "\t\t\tif(!~leaf[u][0]) leaf[u][0] = l;",
            "\t\t\tleaf[u][1] = r;",
            "\t\t}",
            "\t\tif(!~leaf[u][0]) leaf[u] = {u, u};",
            "\t};",
            "\tdfs(dfs, 0);",
            "\tassert((int)order.size() == n);",
            "\tvector<int> index_d(n), child;",
            "\tvector<vector<int>> bag;",
            "\tvector<array<int, 2>> edge;",
            "\tbag.push_back({0, leaf[0][0], leaf[0][1]});",
            "\tfor(auto u: order){",
            "\t\tauto [l, r] = leaf[u];",
            "\t\tint u_d = index_d[u];",
            "\t\tchild.clear();",
            "\t\tfor(auto id: g.adj[u]){",
            "\t\t\tif(g.ignore && g.ignore(id) || id == pe[u]) continue;",
            "\t\t\tchild.push_back(g(u, id));",
            "\t\t}",
            "\t\tif(child.empty()) continue;",
            "\t\tfor(auto i = 0; i < (int)child.size() - 1; ++ i){",
            "\t\t\tint v = child[i], w = child[i + 1];",
            "\t\t\tarray<int, 3> v_d;",
            "\t\t\tiota(v_d.begin(), v_d.end(), (int)bag.size());",
            "\t\t\tindex_d[v] = v_d[1];",
            "\t\t\tbag.push_back({u, leaf[v][0], leaf[v][1], leaf[u][1]});",
            "\t\t\tbag.push_back({u, v, leaf[v][0], leaf[v][1]});",
            "\t\t\tbag.push_back({u, leaf[v][1], leaf[w][0], leaf[u][1]});",
            "\t\t\tedge.push_back({u_d, v_d[0]});",
            "\t\t\tedge.push_back({v_d[0], v_d[1]});",
            "\t\t\tedge.push_back({v_d[0], v_d[2]});",
            "\t\t\tu_d = v_d[2];",
            "\t\t}",
            "\t\tint v = child.back(), v_d = (int)bag.size();",
            "\t\tindex_d[v] = v_d;",
            "\t\tbag.push_back({u, v, leaf[v][0], leaf[v][1]});",
            "\t\tedge.push_back({u_d, v_d});",
            "\t}",
            "\tfor(auto &b: bag){",
            "\t\tsort(b.begin(), b.end());",
            "\t\tb.erase(unique(b.begin(), b.end()), b.end());",
            "\t}",
            "\treturn {bag, edge};",
            "}"
        ],
        "description": "tranxuanbach"
    }
}