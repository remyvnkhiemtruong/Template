{
    "tranxuanbach": {
        "prefix": "permutation",
        "body": [
            "struct permutation: vector<int>{",
            "\tusing vector<int>::size;",
            "\tpermutation(){ }",
            "\tpermutation(int n): vector<int>(n){",
            "\t\tiota(this->begin(), this->end(), 0);",
            "\t}",
            "\tpermutation(const vector<int> &a){",
            "\t\tcopy(a.begin(), a.end(), back_inserter(*this));",
            "\t}",
            "\tpermutation operator+(const permutation &otr) const{",
            "\t\tpermutation res(size());",
            "\t\tfor(auto i = 0; i < (int)size(); ++ i) res[i] = (*this)[otr[i]];",
            "\t\treturn res;",
            "\t}",
            "\tpermutation &operator+=(const permutation &otr){",
            "\t\treturn *this = *this + otr;",
            "\t}",
            "\tpermutation operator-() const{",
            "\t\tpermutation res(size());",
            "\t\tfor(auto i = 0; i < (int)size(); ++ i) res[(*this)[i]] = i;",
            "\t\treturn res;",
            "\t}",
            "\tpermutation operator-(const permutation &otr) const{",
            "\t\tpermutation res(size());",
            "\t\tfor(auto i = 0; i < (int)size(); ++ i) res[otr[i]] = (*this)[i];",
            "\t\treturn res;",
            "\t}",
            "\tpermutation &operator-=(const permutation &otr){",
            "\t\treturn *this = *this - otr;",
            "\t}",
            "\tvector<vector<int>> decompose() const{",
            "\t\tvector<bool> vis(size());",
            "\t\tvector<vector<int>> res;",
            "\t\tfor(auto i = 0; i < (int)size(); ++ i) if(!vis[i]){",
            "\t\t\tvector<int> cycle;",
            "\t\t\tfor(auto j = i; !vis[j]; j = (*this)[j]) vis[j] = true, cycle.push_back(j);",
            "\t\t\tres.push_back(cycle);",
            "\t\t}",
            "\t\treturn res;",
            "\t}",
            "\tbool parity() const{",
            "\t\tbool res = false;",
            "\t\tfor(auto &c: decompose()) res ^= ~(int)c.size() & 1;",
            "\t\treturn res;",
            "\t}",
            "\ttemplate<class T>",
            "\tpermutation operator*(T n) const{",
            "\t\tif(!n) return permutation(size());",
            "\t\tif(n == 1) return *this;",
            "\t\tif(n == -1) return -*this;",
            "\t\tpermutation res(size());",
            "\t\tfor(auto cycle: decompose()) for(auto i = 0, j = (int)(n % cycle.size()); i < (int)cycle.size(); ++ i, ++ j){",
            "\t\t\tif(j < 0) j += (int)cycle.size();",
            "\t\t\tif(j >= (int)cycle.size()) j -= (int)cycle.size();",
            "\t\t\tres[cycle[i]] = cycle[j];",
            "\t\t}",
            "\t\treturn res;",
            "\t}",
            "\ttemplate<class T>",
            "\tpermutation &operator*=(T n){",
            "\t\treturn *this = *this * n;",
            "\t}",
            "\ttemplate<class T>",
            "\tfriend permutation operator*(T n, const permutation &p){",
            "\t\treturn p * n;",
            "\t}",
            "\ttemplate<class T>",
            "\tvector<T> permute(const vector<T> &a) const{",
            "\t\tassert((int)a.size() == (int)size());",
            "\t\tvector<T> b(size());",
            "\t\tfor(auto i = 0; i < (int)size(); ++ i) b[i] = a[(*this)[i]];",
            "\t\treturn b;",
            "\t}",
            "};"
        ],
        "description": "tranxuanbach"
    }
}