{
    "tranxuanbach": {
        "prefix": "li_chao_tree_order_statistic",
        "body": [
            "// Data structure maintaining functions [th_low, th_high]->X such that",
            "// any two functions f and g are either equal, one is strictly above the other, or has a point p \\in [th_low, th_high] satisfying either",
            "// (f(x) < g(x) for all x<p, f(p) = g(p), and f(y) > g(y) for all p<=y) or",
            "// (f(x) > g(x) for all x<p, f(p) = g(p), and f(y) < g(y) for all p<=y).",
            "template<class T, class X, class F, class Compare = less<>>",
            "struct li_chao_tree_order_statistic{",
            "\tT th_low, th_high;",
            "\tint th_order;",
            "\tvector<array<int, 2>> child{{-1, -1}};",
            "\tvector<vector<int>> data{{}};",
            "\tF evaluate; // evaluate(i, p): value of function i at p",
            "\tCompare cmp;",
            "\tX minf;",
            "\tli_chao_tree_order_statistic(T th_low, T th_high, int th_order, F evaluate, X _type_deducer, Compare cmp = less<>(), X minf = numeric_limits<X>::min()): th_low(th_low), th_high(th_high), th_order(th_order), evaluate(evaluate), cmp(cmp), minf(minf){ assert(th_order > 0); }",
            "\tli_chao_tree_order_statistic &operator=(const li_chao_tree_order_statistic &lct){",
            "\t\tth_low = lct.th_low;",
            "\t\tth_high = lct.th_high;",
            "\t\tth_order = lct.th_order;",
            "\t\tchild = lct.child;",
            "\t\tdata = lct.data;",
            "\t}",
            "\t// Insert the function i.",
            "\t// O(log(n) * k)",
            "\tvoid insert(int i){",
            "\t\tassert(i >= 0);",
            "\t\tint u = 0;",
            "\t\tT l = th_low, r = th_high;",
            "\t\twhile(true){",
            "\t\t\tT m = l + r >> 1;",
            "\t\t\tdata[u].insert(lower_bound(data[u].begin(), data[u].end(), evaluate(i, m), [&](int j, const auto &x){ return !cmp(evaluate(j, m), x); }), i);",
            "\t\t\tif((int)data[u].size() < th_order << 1) break;",
            "\t\t\ti = data[u].back();",
            "\t\t\tdata[u].pop_back();",
            "\t\t\tint cnt_l = 0, cnt_r = 0;",
            "\t\t\tfor(auto j: data[u]){",
            "\t\t\t\tif(!cmp(evaluate(j, l), evaluate(i, l))){",
            "\t\t\t\t\t++ cnt_l;",
            "\t\t\t\t\tif(!cmp(evaluate(j, r), evaluate(i, r))) ++ cnt_r;",
            "\t\t\t\t}",
            "\t\t\t\telse if(!cmp(evaluate(j, r), evaluate(i, r))) ++ cnt_r;",
            "\t\t\t}",
            "\t\t\tif(cnt_l < th_order){",
            "\t\t\t\tif(!~child[u][0]){",
            "\t\t\t\t\tchild[u][0] = (int)child.size();",
            "\t\t\t\t\tchild.push_back({-1, -1});",
            "\t\t\t\t\tdata.push_back({i});",
            "\t\t\t\t\tbreak;",
            "\t\t\t\t}",
            "\t\t\t\tu = child[u][0];",
            "\t\t\t\tr = m;",
            "\t\t\t}",
            "\t\t\telse if(cnt_r < th_order){",
            "\t\t\t\tif(!~child[u][1]){",
            "\t\t\t\t\tchild[u][1] = (int)child.size();",
            "\t\t\t\t\tchild.push_back({-1, -1});",
            "\t\t\t\t\tdata.push_back({i});",
            "\t\t\t\t\tbreak;",
            "\t\t\t\t}",
            "\t\t\t\tu = child[u][1];",
            "\t\t\t\tl = m;",
            "\t\t\t}",
            "\t\t\telse break;",
            "\t\t}",
            "\t}",
            "\t// Return the pair {evaluate(i, p), i} where i achieves the k-th maximum evaluation at p among all functions in the data structure.",
            "\t// O(log(n) * k * log(k))",
            "\tpair<X, int> query_max(T p, int k = 0) const{",
            "\t\tassert(th_low <= p && p <= th_high && k < th_order);",
            "\t\tvector<pair<X, int>> res;",
            "\t\tint u = 0;",
            "\t\tT l = th_low, r = th_high;",
            "\t\twhile(true){",
            "\t\t\tfor(auto i: data[u]) res.push_back({evaluate(i, p), i});",
            "\t\t\tsort(res.rbegin(), res.rend(), [&](const auto &x, const auto &y){ return cmp(x.first, y.first); });",
            "\t\t\tres.resize(min((int)res.size(), k + 1));",
            "\t\t\tT m = l + r >> 1;",
            "\t\t\tif(p < m){",
            "\t\t\t\tif(!~child[u][0]) break;",
            "\t\t\t\tu = child[u][0];",
            "\t\t\t\tr = m;",
            "\t\t\t}",
            "\t\t\telse{",
            "\t\t\t\tif(!~child[u][1]) break;",
            "\t\t\t\tu = child[u][1];",
            "\t\t\t\tl = m;",
            "\t\t\t}",
            "\t\t}",
            "\t\tassert((int)res.size() == k + 1);",
            "\t\treturn res[k];",
            "\t}",
            "\tfriend ostream &operator<<(ostream &out, const li_chao_tree_order_statistic &lct){",
            "\t\tauto recurse = [&](auto self, int u, T l, T r)->void{",
            "\t\t\tout << \"Node \" << u << \" for range [\" << l << \", \" << r << \"]: \";",
            "\t\t\tout << \"{\";",
            "\t\t\tfor(auto t = 0; t < (int)lct.data[u].size(); ++ t){",
            "\t\t\t\tout << \"{\" << lct.data[u][t] << \", \" << lct.evaluate(lct.data[u][t], l + r >> 1) << \"}\";",
            "\t\t\t\tif(t + 1 < (int)lct.data[u].size()) out << \", \";",
            "\t\t\t}",
            "\t\t\tout << \"}\\n\";",
            "\t\t\tif(~lct.child[u][0]) self(self, lct.child[u][0], l, l + r >> 1);",
            "\t\t\tif(~lct.child[u][1]) self(self, lct.child[u][1], l + r >> 1, r);",
            "\t\t};",
            "\t\trecurse(recurse, 0, lct.th_low, lct.th_high);",
            "\t\treturn out;",
            "\t}",
            "};"
        ],
        "description": "tranxuanbach"
    }
}