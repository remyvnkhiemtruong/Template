{
    "tranxuanbach": {
        "prefix": "min_cost_max_flow",
        "body": [
            "template<class T, class C>",
            "struct min_cost_max_flow{",
            "\tstatic constexpr T eps = (T) 1e-9;",
            "\tstruct Edge{",
            "\t\tint from, to;",
            "\t\tT capacity, flow;",
            "\t\tC cost;",
            "\t};",
            "\tvector<vector<int>> adj;",
            "\tvector<Edge> edge;",
            "\tvector<C> d;",
            "\tvector<bool> in_queue;",
            "\tvector<int> q, pe;",
            "\tint n, source, sink;",
            "\tT flow = 0;",
            "\tC cost = 0;",
            "\tmin_cost_max_flow(int n, int source, int sink): n(n), source(source), sink(sink), adj(n), d(n), in_queue(n), pe(n){ }",
            "\tvoid clear(){",
            "\t\tfor(auto &e: edge) e.flow = 0;",
            "\t\tflow = 0;",
            "\t}",
            "\tint insert(int from, int to, T forward_cap, T backward_cap, C cost){",
            "\t\tassert(0 <= from && from < n && 0 <= to && to < n);",
            "\t\tint ind = int(edge.size());",
            "\t\tadj[from].push_back((int)edge.size());",
            "\t\tedge.push_back({from, to, forward_cap, 0, cost});",
            "\t\tadj[to].push_back((int)edge.size());",
            "\t\tedge.push_back({to, from, backward_cap, 0, -cost});",
            "\t\treturn ind;",
            "\t}",
            "\tbool expath(){",
            "\t\tfill(d.begin(), d.end(), numeric_limits<C>::max());",
            "\t\tq.clear();",
            "\t\tq.push_back(source);",
            "\t\td[source] = 0;",
            "\t\tin_queue[source] = true;",
            "\t\tint beg = 0;",
            "\t\tbool found = false;",
            "\t\twhile(beg < (int)q.size()){",
            "\t\t\tint i = q[beg ++];",
            "\t\t\tif(i == sink) found = true;",
            "\t\t\tin_queue[i] = false;",
            "\t\t\tfor(int id : adj[i]){",
            "\t\t\t\tconst auto &e = edge[id];",
            "\t\t\t\tif(e.capacity - e.flow > eps && d[i] + e.cost < d[e.to]){",
            "\t\t\t\t\td[e.to] = d[i] + e.cost;",
            "\t\t\t\t\tpe[e.to] = id;",
            "\t\t\t\t\tif(!in_queue[e.to]){",
            "\t\t\t\t\t\tq.push_back(e.to);",
            "\t\t\t\t\t\tin_queue[e.to] = true;",
            "\t\t\t\t\t}",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t}",
            "\t\tif(found){",
            "\t\t\tT push = numeric_limits<T>::max();",
            "\t\t\tint v = sink;",
            "\t\t\twhile(v != source){",
            "\t\t\t\tconst auto &e = edge[pe[v]];",
            "\t\t\t\tpush = min(push, e.capacity - e.flow);",
            "\t\t\t\tv = e.from;",
            "\t\t\t}",
            "\t\t\tv = sink;",
            "\t\t\twhile(v != source){",
            "\t\t\t\tauto &e = edge[pe[v]];",
            "\t\t\t\te.flow += push;",
            "\t\t\t\tauto &back = edge[pe[v] ^ 1];",
            "\t\t\t\tback.flow -= push;",
            "\t\t\t\tv = e.from;",
            "\t\t\t}",
            "\t\t\tflow += push;",
            "\t\t\tcost += push * d[sink];",
            "\t\t}",
            "\t\treturn found;",
            "\t}",
            "\tpair<T, C> solve(){ // O(Augmenting Paths) * O(SPFA)",
            "\t\twhile(expath()){ }",
            "\t\treturn {flow, cost};",
            "\t}",
            "};"
        ],
        "description": "tranxuanbach"
    }
}