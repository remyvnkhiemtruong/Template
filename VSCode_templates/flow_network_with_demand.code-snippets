{
    "tranxuanbach": {
        "prefix": "flow_network_with_demand",
        "body": [
            "// Requires flow_network",
            "template<class T, class Flow_Solver>",
            "struct flow_network_with_demand{",
            "\tflow_network_with_demand(int n): n(n), F(n + 2), D(F), demand(n){}",
            "\tint orient(int from, int to, T d, T c){",
            "\t\tassert(0 <= min(from, to) && max(from, to) < n && 0 <= d && d <= c);",
            "\t\t++ m;",
            "\t\tint id = F.orient(from, to, c - d);",
            "\t\tdemand[from] -= d;",
            "\t\tdemand[to] += d;",
            "\t\tedge_id.push_back(id);",
            "\t\tedge_demand.push_back(d);",
            "\t\treturn id;",
            "\t}",
            "\tT _setup(){",
            "\t\tT req = 0;",
            "\t\tfor(auto u = 0; u < n; ++ u){",
            "\t\t\tif(demand[u] > 0) F.orient(n, u, demand[u]), req += demand[u];",
            "\t\t\telse if(demand[u] < 0) F.orient(u, n + 1, -demand[u]);",
            "\t\t}",
            "\t\treturn req;",
            "\t}",
            "\tvector<T> _get_edge_flow() const{",
            "\t\tvector<T> w = edge_demand;",
            "\t\tfor(auto i = 0; i < m; ++ i) w[i] += F.edge[edge_id[i]].flow;",
            "\t\treturn w;",
            "\t}",
            "\t// Destroys the network after getting called",
            "\toptional<vector<T>> feasible_circulation(){",
            "\t\tif(T req = _setup(); req != D.maximum_flow(n, n + 1)) return {};",
            "\t\treturn _get_edge_flow();",
            "\t}",
            "\t// Destroys the network after getting called",
            "\toptional<pair<T, vector<T>>> feasible_flow(int s, int t){",
            "\t\tassert(0 <= min(s, t) && max(s, t) < n && s != t);",
            "\t\tint id = F.orient(t, s, numeric_limits<T>::max());",
            "\t\tif(!feasible_circulation()) return {};",
            "\t\treturn pair{F.edge[id].flow, _get_edge_flow()};",
            "\t}",
            "\t// Destroys the network after getting called",
            "\toptional<pair<T, vector<T>>> maximum_feasible_flow(int s, int t){",
            "\t\tassert(0 <= min(s, t) && max(s, t) < n && s != t);",
            "\t\tint id = F.orient(t, s, numeric_limits<T>::max());",
            "\t\tif(!feasible_circulation()) return {};",
            "\t\tT flow = F.edge[id].flow;",
            "\t\tF.edge[id].capacity = F.edge[id].flow = F.edge[id ^ 1].flow = 0;",
            "\t\tflow += D.maximum_flow(s, t);",
            "\t\treturn pair{flow, _get_edge_flow()};",
            "\t}",
            "\t// Destroys the network after getting called",
            "\toptional<pair<T, vector<T>>> minimum_feasible_flow(int s, int t){",
            "\t\tassert(0 <= min(s, t) && max(s, t) < n && s != t);",
            "\t\tint id = F.orient(t, s, numeric_limits<T>::max());",
            "\t\tif(!feasible_circulation()) return {};",
            "\t\tT flow = F.edge[id].flow;",
            "\t\tF.edge[id].capacity = F.edge[id].flow = F.edge[id ^ 1].flow = 0;",
            "\t\tflow -= D.maximum_flow(t, s);",
            "\t\treturn pair{flow, _get_edge_flow()};",
            "\t}",
            "\tint n, m = 0;",
            "\tflow_network<T> F;",
            "\tFlow_Solver D;",
            "\tvector<T> demand;",
            "\tvector<int> edge_id;",
            "\tvector<T> edge_demand;",
            "};"
        ],
        "description": "tranxuanbach"
    }
}