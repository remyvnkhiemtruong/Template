{
    "tranxuanbach": {
        "prefix": "circle_common_tangents",
        "body": [
            "// As a directed line, it touches c first",
            "// First L(resp. R) denotes that c lies on the left(resp. right)",
            "// Second L(resp. R) denotes that d lies on the left(resp. right)",
            "// Order of lines: LL, RR, LR, RL",
            "// Requires point, line, and circle",
            "template<class T>",
            "vector<lined> circle_common_tangents(const circle<T> &c, const circle<T> &d){",
            "\tassert(c != d);",
            "\tif(abs(c.radius) <= T(1e-9) && abs(d.radius) <= T(1e-9)) return {lined(c.center, d.center)};",
            "\tif(c.strictly_contains(d) || d.strictly_contains(c)) return {};",
            "\tif(c.contains(d) || d.contains(c)) return {lined((-d.radius * pointd(c.center) + c.radius * pointd(d.center)) / (c.radius - d.radius), (c.contains(d) ? d.center - c.center : c.center - d.center).perp(), false)};",
            "\tdouble xdif = d.center.x - c.center.x;",
            "\tdouble ydif = d.center.y - c.center.y;",
            "\tdouble rdif = c.radius - d.radius;",
            "\tdouble sqdist = xdif * xdif + ydif * ydif;",
            "\tdouble sqrtdet = sqrt(max(sqdist - rdif * rdif, 0.0));",
            "\tvector<lined> res = {",
            "\t\tlined(",
            "\t\t\t(rdif * xdif + ydif * sqrtdet) / sqdist,",
            "\t\t\t(rdif * ydif - xdif * sqrtdet) / sqdist,",
            "\t\t\t-c.radius",
            "\t\t),",
            "\t\tlined(",
            "\t\t\t(rdif * xdif - ydif * sqrtdet) / sqdist,",
            "\t\t\t(rdif * ydif + xdif * sqrtdet) / sqdist,",
            "\t\t\t-c.radius",
            "\t\t)",
            "\t};",
            "\tres[0].p += c.center;",
            "\tres[1].p += c.center;",
            "\tif(abs(c.radius) <= T(1e-9) || abs(d.radius) <= T(1e-9) || c.intersect_at_two_points(d));",
            "\telse if(c.intersect_at_one_point(d)) res.push_back(lined((d.radius * pointd(c.center) + c.radius * pointd(d.center)) / (c.radius + d.radius), (d.center - c.center).perp(), false));",
            "\telse{",
            "\t\tdouble rsum = c.radius + d.radius;",
            "\t\tdouble sqrtdet = sqrt(max(sqdist - rsum * rsum, 0.0));",
            "\t\tres.push_back(",
            "\t\t\tlined(",
            "\t\t\t\t(rsum * xdif + ydif * sqrtdet) / sqdist,",
            "\t\t\t\t(rsum * ydif - xdif * sqrtdet) / sqdist,",
            "\t\t\t\t-c.radius",
            "\t\t\t)",
            "\t\t);",
            "\t\tres.push_back(",
            "\t\t\tlined(",
            "\t\t\t\t(rsum * xdif - ydif * sqrtdet) / sqdist,",
            "\t\t\t\t(rsum * ydif + xdif * sqrtdet) / sqdist,",
            "\t\t\t\t-c.radius",
            "\t\t\t)",
            "\t\t);",
            "\t\tres[2].p += c.center;",
            "\t\tres[3].p += c.center;",
            "\t}",
            "\tif((int)res.size() >= 2) for(auto i = 0; i < 2; ++ i) res[i] = {res[i].projection(c.center), res[i].projection(d.center)};",
            "\tif((int)res.size() >= 4) for(auto i = 2; i < 4; ++ i) res[i] = {res[i].projection(c.center), res[i].projection(d.center)};",
            "\treturn res;",
            "}"
        ],
        "description": "tranxuanbach"
    }
}