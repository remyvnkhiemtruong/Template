{
    "tranxuanbach": {
        "prefix": "aho_corasic_automaton_fixed",
        "body": [
            "template<class Char_Type, int sigma>",
            "struct aho_corasic_automaton_fixed{",
            "\tvector<int> len{0};",
            "\tvector<int> link{-1};",
            "\tvector<int> exit_link{-1};",
            "\tvector<int> is_terminal{false};",
            "\tvector<pair<int, Char_Type>> pv{{-1, {}}};",
            "\tvector<array<int, sigma>> next{{}};",
            "\tint new_state(){",
            "\t\tlen.push_back(0);",
            "\t\tlink.push_back(-1);",
            "\t\texit_link.push_back(-1);",
            "\t\tis_terminal.push_back(false);",
            "\t\tpv.push_back({-1, {}});",
            "\t\tnext.push_back({});",
            "\t\treturn (int)len.size() - 1;",
            "\t}",
            "\taho_corasic_automaton_fixed(){ }",
            "\t// O(sigma * (sum of length)) where sigma is the size of alphabets",
            "\t// All alphabets must be within [0, sigma)",
            "\taho_corasic_automaton_fixed(const vector<vector<Char_Type>> &patterns){",
            "\t\tfor(auto s: patterns){",
            "\t\t\tint u = 0;",
            "\t\t\tfor(auto c: s){",
            "\t\t\t\tassert(0 <= c && c < sigma);",
            "\t\t\t\tif(!next[u][c]){",
            "\t\t\t\t\tnext[u][c] = new_state();",
            "\t\t\t\t\tlen[next[u][c]] = len[u] + 1;",
            "\t\t\t\t\tpv[next[u][c]] = {u, c};",
            "\t\t\t\t}",
            "\t\t\t\tu = next[u][c];",
            "\t\t\t}",
            "\t\t\tis_terminal[u] = true;",
            "\t\t}",
            "\t\tdeque<int> dq{0};",
            "\t\twhile(!dq.empty()){",
            "\t\t\tint u = dq.front(); dq.pop_front();",
            "\t\t\tfor(auto c = 0; c < sigma; ++ c){",
            "\t\t\t\tint v = next[u][c];",
            "\t\t\t\tif(!v) continue;",
            "\t\t\t\tlink[v] = ~link[u] ? next[link[u]][c] : 0;",
            "\t\t\t\texit_link[v] = is_terminal[link[v]] ? link[v] : exit_link[link[v]];",
            "\t\t\t\tdq.push_back(v); ",
            "\t\t\t}",
            "\t\t\tif(u) for(auto c = 0; c < sigma; ++ c) if(!next[u][c]) next[u][c] = next[link[u]][c];",
            "\t\t}",
            "\t}",
            "\tint next_state(int u, Char_Type c) const{",
            "\t\treturn next[u][c];",
            "\t}",
            "\tint next_state(int u, const vector<Char_Type> &s) const{",
            "\t\tfor(auto c: s) u = next[u][c];",
            "\t\treturn u;",
            "\t}",
            "\tint size() const{ // # of states",
            "\t\treturn (int)len.size();",
            "\t}",
            "\tvector<Char_Type> restore(int u) const{",
            "\t\tassert(0 <= u && u < (int)next.size());",
            "\t\tvector<Char_Type> res;",
            "\t\tfor(; u; u = pv[u].first) res.push_back(pv[u].second);",
            "\t\treverse(res.begin(), res.end());",
            "\t\treturn res;",
            "\t}",
            "};"
        ],
        "description": "tranxuanbach"
    }
}