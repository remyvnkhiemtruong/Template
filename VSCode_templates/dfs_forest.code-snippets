{
    "tranxuanbach": {
        "prefix": "dfs_forest",
        "body": [
            "// Requires graph",
            "template<class T>",
            "struct dfs_forest{",
            "\tint n;",
            "\tT base_dist;",
            "\tvector<T> dist;",
            "\tvector<int> pv;",
            "\tvector<int> pe;",
            "\tvector<int> order;",
            "\tvector<int> pos;",
            "\tvector<int> end;",
            "\tvector<int> size;",
            "\tvector<int> root_of;",
            "\tvector<int> root;",
            "\tvector<int> depth;",
            "\tvector<int> min_depth;",
            "\tvector<int> min_depth_origin;",
            "\tvector<int> min_depth_spanning_edge;",
            "\t// extra_edge[u]: adjacent edges of u which is not part of the spanning forest found during the last dfs-like run.",
            "\tvector<vector<int>> extra_edge;",
            "\tvector<int> was;",
            "\tdfs_forest(T base_dist = 0): base_dist(base_dist){ }",
            "\tvoid init(int n){",
            "\t\tthis->n = n;",
            "\t\tpv.assign(n, -1);",
            "\t\tpe.assign(n, -1);",
            "\t\torder.clear();",
            "\t\tpos.assign(n, -1);",
            "\t\tend.assign(n, -1);",
            "\t\tsize.assign(n, 0);",
            "\t\troot_of.assign(n, -1);",
            "\t\troot.clear();",
            "\t\tdepth.assign(n, -1);",
            "\t\tmin_depth.assign(n, -1);",
            "\t\tmin_depth_origin.assign(n, -1);",
            "\t\tmin_depth_spanning_edge.assign(n, -1);",
            "\t\tdist.assign(n, base_dist);",
            "\t\textra_edge.assign(n, {});",
            "\t\twas.assign(n, -2);",
            "\t\tattempt = -1;",
            "\t}",
            "\tint attempt;",
            "\t// O(# of nodes reachable from u)",
            "\ttemplate<class U, class F = plus<>>",
            "\tvoid _dfs(const graph<U> &g, int u, F UT = plus<>()){",
            "\t\tdepth[u] = 0;",
            "\t\tdist[u] = base_dist;",
            "\t\troot_of[u] = u;",
            "\t\troot.push_back(u);",
            "\t\tpv[u] = pe[u] = -1;",
            "\t\tauto recurse = [&](auto self, int u)->void{",
            "\t\t\twas[u] = attempt;",
            "\t\t\tpos[u] = (int)order.size();",
            "\t\t\torder.push_back(u);",
            "\t\t\tsize[u] = 1;",
            "\t\t\tmin_depth[u] = depth[u];",
            "\t\t\tmin_depth_origin[u] = u;",
            "\t\t\tmin_depth_spanning_edge[u] = -1;",
            "\t\t\tfor(auto id: g.adj[u]){",
            "\t\t\t\tif(id == pe[u] || g.ignore && g.ignore(id)) continue;",
            "\t\t\t\tint v = g(u, id);",
            "\t\t\t\tif(was[v] == attempt){",
            "\t\t\t\t\tif(min_depth[u] > depth[v]){",
            "\t\t\t\t\t\tmin_depth[u] = depth[v];",
            "\t\t\t\t\t\tmin_depth_spanning_edge[u] = id;",
            "\t\t\t\t\t}",
            "\t\t\t\t\tif(pe[u] != id) extra_edge[u].push_back(id);",
            "\t\t\t\t\tcontinue;",
            "\t\t\t\t}",
            "\t\t\t\tdepth[v] = depth[u] + 1;",
            "\t\t\t\tdist[v] = UT(g.edge[id].cost, dist[u]);",
            "\t\t\t\tpv[v] = u;",
            "\t\t\t\tpe[v] = id;",
            "\t\t\t\troot_of[v] = root_of[u];",
            "\t\t\t\tself(self, v);",
            "\t\t\t\tsize[u] += size[v];",
            "\t\t\t\tif(min_depth[u] > min_depth[v]){",
            "\t\t\t\t\tmin_depth[u] = min_depth[v];",
            "\t\t\t\t\tmin_depth_origin[u] = min_depth_origin[v];",
            "\t\t\t\t\tmin_depth_spanning_edge[u] = min_depth_spanning_edge[v];",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t\tend[u] = (int)order.size();",
            "\t\t};",
            "\t\trecurse(recurse, u);",
            "\t}",
            "\t// O(# of nodes reachable from src)",
            "\ttemplate<class U, class F = plus<>>",
            "\tvoid dfs(const graph<U> &g, const vector<int> &src, F UT = plus<>()){",
            "\t\tassert(g.n <= n);",
            "\t\troot.clear(), order.clear();",
            "\t\t++ attempt;",
            "\t\tfor(auto u: src){",
            "\t\t\tassert(0 <= u && u < g.n);",
            "\t\t\tif(was[u] != attempt) _dfs(g, u, UT);",
            "\t\t}",
            "\t}",
            "\t// O(n + m)",
            "\ttemplate<class U, class F = plus<>>",
            "\tvoid dfs_all(const graph<U> &g, F UT = plus<>()){",
            "\t\tassert(g.n <= n);",
            "\t\troot.clear(), order.clear();",
            "\t\t++ attempt;",
            "\t\tfor(auto u = 0; u < g.n; ++ u) if(was[u] != attempt) _dfs(g, u, UT);",
            "\t}",
            "\t// Check if u is visited during the last dfs-like call.",
            "\tbool visited(int u) const{",
            "\t\tassert(0 <= u && u < n);",
            "\t\treturn was[u] == attempt;",
            "\t}",
            "\t// Check if u is an ancestor of v in some spanning tree.",
            "\tbool ancestor_of(int u, int v) const{",
            "\t\tassert(visited(u) && visited(v));",
            "\t\treturn pos[u] <= pos[v] && end[v] <= end[u];",
            "\t}",
            "\tvector<int> get_path(int u, int v) const{",
            "\t\tassert(visited(u) && visited(v) && root_of[u] == root_of[v]);",
            "\t\tvector<int> left, right;",
            "\t\twhile(u != v){",
            "\t\t\tif(depth[u] >= depth[v]){",
            "\t\t\t\tleft.push_back(u);",
            "\t\t\t\tu = pv[u];",
            "\t\t\t}",
            "\t\t\telse{",
            "\t\t\t\tright.push_back(v);",
            "\t\t\t\tv = pv[v];",
            "\t\t\t}",
            "\t\t}",
            "\t\tleft.push_back(u);",
            "\t\tleft.insert(left.end(), right.rbegin(), right.rend());",
            "\t\treturn left;",
            "\t}",
            "\t// Check if any cycle is found during the last dfs-like call.",
            "\t// If must_contain_root = true, the sought cycle is forced to contain one of the root of the trees.",
            "\ttemplate<class U>",
            "\toptional<pair<int, vector<int>>> find_any_cycle(const graph<U> &g, bool must_contain_root = false) const{",
            "\t\tfor(auto u: order) for(auto id: extra_edge[u]){",
            "\t\t\tint v = g(u, id);",
            "\t\t\tif(!ancestor_of(v, u) || must_contain_root && root_of[v] != v) continue;",
            "\t\t\tvector<int> cycle_edge;",
            "\t\t\twhile(u != v) cycle_edge.push_back(pe[u]), u = pv[u];",
            "\t\t\treverse(cycle_edge.begin(), cycle_edge.end());",
            "\t\t\tcycle_edge.push_back(id);",
            "\t\t\treturn pair{v, cycle_edge};",
            "\t\t}",
            "\t\treturn {};",
            "\t}",
            "};"
        ],
        "description": "tranxuanbach"
    }
}