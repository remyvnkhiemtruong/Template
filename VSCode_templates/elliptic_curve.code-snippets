{
    "tranxuanbach": {
        "prefix": "elliptic_curve",
        "body": [
            "template<class T>",
            "struct elliptic_curve{",
            "\tstatic bool setup_flag;",
            "\t// Y^2 = X^3 + aX + b",
            "\t// Assumes that the characteristic of the field T is not 2 or 3.",
            "\tstatic T a, b;",
            "\tstatic void setup(T _a, T _b){",
            "\t\tsetup_flag = true;",
            "\t\ta = _a, b = _b;",
            "\t\tassert(T{4} * a * a * a + T{27} * b * b != T{0});",
            "\t}",
            "\tstatic optional<elliptic_curve> make(T x = 0, T y = 1, T z = 0){",
            "\t\tassert(setup_flag);",
            "\t\tif((z == T{0} && (x != T{0} || y == T{0})) || x * x * x + z * (-y * y + z * (a * x + z * b)) != T{0}) return {};",
            "\t\tif(z < T{0}) x = -x, y = -y, z = -z;",
            "\t\treturn elliptic_curve{x, y, z};",
            "\t}",
            "\tstatic optional<elliptic_curve> make(const array<T, 3> &a = {0, 1, 0}){",
            "\t\treturn make(a[0], a[1], a[2]);",
            "\t}",
            "\t// Assumes T is of modular type",
            "\ttemplate<class U>",
            "\tstatic elliptic_curve sample(auto &&rng, U low, U high, auto optional_sqrt){",
            "\t\tassert(setup_flag);",
            "\t\tassert(low < high);",
            "\t\tuniform_int_distribution<U> rint(low, high - 1);",
            "\t\twhile(true){",
            "\t\t\tT x = rint(rng);",
            "\t\t\tif(auto yptr = optional_sqrt(x * x * x + a * x + b)){",
            "\t\t\t\tT y = *yptr;",
            "\t\t\t\tif(y == 0){",
            "\t\t\t\t\tif(rng() & 1) return elliptic_curve();",
            "\t\t\t\t\telse return elliptic_curve(x, y, 1);",
            "\t\t\t\t}",
            "\t\t\t\telse return elliptic_curve(x, y * (rng() & 1 ? 1 : -1), 1);",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "\tT x = 0, y = 1, z = 0;",
            "\telliptic_curve(){ assert(setup_flag); }",
            "private:",
            "\t// use elliptic_curve<T>::make instead to construct a point",
            "\telliptic_curve(T x, T y, T z): x(x), y(y), z(z){ }",
            "public:",
            "\telliptic_curve &reduce(){",
            "\t\tif(z == T{0}) return *this = elliptic_curve();",
            "\t\telse return *this = elliptic_curve{x / z, y / z, T{1}};",
            "\t}",
            "\telliptic_curve reduced() const{",
            "\t\treturn elliptic_curve(*this).reduce();",
            "\t}",
            "\tfriend ostream &operator<<(ostream &out, const elliptic_curve &p){",
            "\t\treturn out << \"{\" << p.x << \", \" << p.y << \", \" << p.z << \"}\";",
            "\t}",
            "\toperator bool() const{",
            "\t\treturn z != T{0};",
            "\t}",
            "\tbool operator==(const elliptic_curve &p) const{",
            "\t\treturn x * p.z == p.x * z && y * p.z == p.y * z;",
            "\t}",
            "\telliptic_curve &double_up(){",
            "\t\tif(!*this) return *this;",
            "\t\tT t = T{3} * x * x + a * z * z, u = T{2} * y * z;",
            "\t\tT v = T{2} * u * x * y, w = t * t - T{2} * v;",
            "\t\treturn *this = {u * w, t * (v - w) - 2 * u * u * y * y, u * u * u};",
            "\t}",
            "\telliptic_curve doubled_up() const{",
            "\t\treturn elliptic_curve(*this).double_up();",
            "\t}",
            "\t// source: https://www.nayuki.io/page/elliptic-curve-point-addition-in-projective-coordinates",
            "\telliptic_curve &operator+=(const elliptic_curve &p){",
            "\t\tif(!p) return *this;",
            "\t\tif(!*this) return *this = p;",
            "\t\tT u0 = x * p.z, u1 = p.x * z, t0 = y * p.z, t1 = p.y * z;",
            "\t\tif(u0 == u1){",
            "\t\t\tif(t0 + t1 == T{0}) return *this = {};",
            "\t\t\treturn double_up();",
            "\t\t}",
            "\t\telse{",
            "\t\t\tT t = t0 - t1, u = u0 - u1;",
            "\t\t\tT u2 = u * u, v = z * p.z, w = t * t * v - u2 * (u0 + u1), u3 = u * u2;",
            "\t\t\treturn *this = {u * w, t * (u0 * u2 - w) - t0 * u3, u3 * v};",
            "\t\t}",
            "\t}",
            "\telliptic_curve &operator-=(const elliptic_curve &p){",
            "\t\treturn *this += -p;",
            "\t}",
            "\ttemplate<class U> elliptic_curve &operator*=(U e){",
            "\t\tif(e < 0){",
            "\t\t\t*this = -*this;",
            "\t\t\te = -e;",
            "\t\t}",
            "\t\telliptic_curve res{};",
            "\t\tfor(; e; e >>= 1, this->double_up()) if(e & 1) res += *this;",
            "\t\treturn *this = res;",
            "\t}",
            "\tbool operator!=(const elliptic_curve &p) const{",
            "\t\treturn !(*this == p);",
            "\t}",
            "\tbool operator<(const elliptic_curve &p) const{",
            "\t\tif(z == T{0}) return false;",
            "\t\tif(p.z == T{0}) return true;",
            "\t\tauto a = x / z, b = p.x / p.z;",
            "\t\treturn a != b ? a < b : y / z < p.y / p.z;",
            "\t}",
            "\telliptic_curve operator+(const elliptic_curve &p) const{",
            "\t\treturn elliptic_curve(*this) += p;",
            "\t}",
            "\telliptic_curve operator+() const{",
            "\t\treturn *this;",
            "\t}",
            "\telliptic_curve operator-(const elliptic_curve &p) const{",
            "\t\treturn elliptic_curve(*this) -= p;",
            "\t}",
            "\telliptic_curve operator-() const{",
            "\t\treturn {x, -y, z};",
            "\t}",
            "\ttemplate<class U> elliptic_curve operator*(U e) const{",
            "\t\treturn elliptic_curve(*this) *= e;",
            "\t}",
            "\ttemplate<class U> friend elliptic_curve operator*(U e, const elliptic_curve &p){",
            "\t\treturn elliptic_curve(p) *= e;",
            "\t}",
            "};",
            "template<class T> bool elliptic_curve<T>::setup_flag = false;",
            "template<class T> T elliptic_curve<T>::a;",
            "template<class T> T elliptic_curve<T>::b;",
            "",
            "using EC = elliptic_curve<modular>;"
        ],
        "description": "tranxuanbach"
    }
}