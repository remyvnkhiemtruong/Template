{
    "tranxuanbach": {
        "prefix": "bellman_ford",
        "body": [
            "// Requires graph",
            "template<class T>",
            "struct bellman_ford{",
            "\tint n;",
            "\tvector<T> dist;",
            "\tvector<int> pv, pe, was;",
            "\tbellman_ford(int n){ init(n); }",
            "\tvoid init(int n){",
            "\t\tthis->n = n;",
            "\t\tdist.assign(n, numeric_limits<T>::max());",
            "\t\tpv.assign(n, -1);",
            "\t\tpe.assign(n, -1);",
            "\t\twas.assign(n, -1);",
            "\t\tattempt = 0;",
            "\t}",
            "\tint attempt;",
            "\t// Returns a negative cycle reachable from src if found",
            "\t// O(|E_C| * |V_C|) where",
            "\t// V_C is the set of vertices reachable from src and",
            "\t// E_C is the set of edges reachable from src",
            "\ttemplate<class U>",
            "\toptional<vector<int>> run(const graph<U> &g, const vector<int> &src){",
            "\t\tassert(n == g.n);",
            "\t\t++ attempt;",
            "\t\tfor(auto u: src){",
            "\t\t\twas[u] = attempt;",
            "\t\t\tdist[u] = {};",
            "\t\t\tpv[u] = pe[u] = -1;",
            "\t\t}",
            "\t\tint x;",
            "\t\tfor(auto rep = 0; rep < n; ++ rep){",
            "\t\t\tx = -1;",
            "\t\t\tfor(auto id = 0; id < (int)g.edge.size(); ++ id){",
            "\t\t\t\tif(g.ignore && g.ignore(id)) continue;",
            "\t\t\t\tauto [u, v, w] = g.edge[id];",
            "\t\t\t\tif(was[u] == attempt && dist[u] + w < dist[v]){",
            "\t\t\t\t\twas[v] = attempt;",
            "\t\t\t\t\tdist[v] = max(dist[u] + w, numeric_limits<T>::min() / 2);",
            "\t\t\t\t\tpv[v] = u, pe[v] = id;",
            "\t\t\t\t\tx = v;",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t}",
            "\t\tif(!~x) return {};",
            "\t\tfor(auto i = 0; i < g.n; ++ i) x = pv[x];",
            "\t\tvector<int> cycle;",
            "\t\tfor(auto u = x; u != x || cycle.empty(); u = g.edge[pe[u]].from) cycle.push_back(pe[u]);",
            "\t\treturn {{cycle.rbegin(), cycle.rend()}};",
            "\t}",
            "};"
        ],
        "description": "tranxuanbach"
    }
}