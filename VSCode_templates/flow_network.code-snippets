{
    "tranxuanbach": {
        "prefix": "flow_network",
        "body": [
            "template<class T>",
            "struct flow_network{",
            "\tint n;",
            "\tvector<vector<int>> adj;",
            "\tstruct E{",
            "\t\tint from, to;",
            "\t\tT capacity, flow;",
            "\t};",
            "\tvector<E> edge;",
            "\tflow_network(int n): n(n), adj(n){ }",
            "\tvoid clear_flow(){",
            "\t\tfor(auto &e: edge) e.flow = 0;",
            "\t}",
            "\tint link(int from, int to, T cap){",
            "\t\tassert(0 <= min(from, to) && max(from, to) < n && cap >= 0);",
            "\t\tint ind = (int)edge.size();",
            "\t\tadj[from].push_back(ind);",
            "\t\tedge.push_back({from, to, cap, 0});",
            "\t\tadj[to].push_back(ind + 1);",
            "\t\tedge.push_back({to, from, cap, 0});",
            "\t\treturn ind;",
            "\t}",
            "\tint orient(int from, int to, T cap){",
            "\t\tassert(0 <= min(from, to) && max(from, to) < n && cap >= 0);",
            "\t\tint ind = (int)edge.size();",
            "\t\tadj[from].push_back(ind);",
            "\t\tedge.push_back({from, to, cap, 0});",
            "\t\tadj[to].push_back(ind + 1);",
            "\t\tedge.push_back({to, from, 0, 0});",
            "\t\treturn ind;",
            "\t}",
            "\tvoid add_flow(int i, T f){",
            "\t\tedge[i].flow += f;",
            "\t\tedge[i ^ 1].flow -= f;",
            "\t}",
            "\tfriend ostream &operator<<(ostream &out, const flow_network &F){",
            "\t\tout << \"\\n\";",
            "\t\tfor(auto &e: F.edge){",
            "\t\t\tout << \"{\" << e.from << \" -> \" << e.to << \", \" << e.flow << \"/\" << e.capacity << \"}\\n\";",
            "\t\t}",
            "\t\treturn out;",
            "\t}",
            "};"
        ],
        "description": "tranxuanbach"
    }
}