{
    "tranxuanbach": {
        "prefix": "value_range_query_solver_online_sqrt",
        "body": [
            "template<class T, int BX, class F = plus<>, bool GET_LESS = true>",
            "struct value_range_query_solver_online_sqrt{",
            "\tint n, sigma;",
            "\tvector<vector<T>> large;",
            "\tvector<vector<int>> small_mapping;",
            "\tvector<vector<vector<T>>> small;",
            "\tF TT; // Commutative monoid operation",
            "\tT T_id; // Commutative monoid identity",
            "\tvalue_range_query_solver_online_sqrt(const vector<int> &a, int sigma, F TT = plus<>(), T T_id = {}): value_range_query_solver_online_sqrt(a, sigma, vector<T>((int)a.size(), 1), TT, T_id){ }",
            "\t// O(n / BX * sigma + n * BX + n * log(n))",
            "\tvalue_range_query_solver_online_sqrt(const vector<int> &a, int sigma, const vector<T> &w, F TT = plus<>(), T T_id = {}): n((int)a.size()), sigma(sigma), large(n / BX + 2, vector<T>(sigma + 1, T_id)), small_mapping(n / BX + 1, vector<int>(sigma + 1)), small(n / BX + 1), TT(TT), T_id(T_id){",
            "\t\tassert(sigma >= 0);",
            "\t\tfor(auto &x: a) assert(0 <= x && x < sigma);",
            "\t\tassert((int)w.size() == n);",
            "\t\tvector<T> sum(sigma);",
            "\t\tfor(auto bi = 0; bi <= n / BX; ++ bi){",
            "\t\t\tint l = bi * BX, r = min(n, l + BX);",
            "\t\t\tfor(auto i = l; i < r; ++ i) sum[a[i]] = TT(sum[a[i]], w[i]);",
            "\t\t\tvector<int> order(r - l);",
            "\t\t\tiota(order.begin(), order.end(), l);",
            "\t\t\tsort(order.begin(), order.end(), [&](int i, int j){ return a[i] < a[j]; });",
            "\t\t\torder.erase(unique(order.begin(), order.end(), [&](int i, int j){ return a[i] == a[j]; }), order.end());",
            "\t\t\tsmall[bi].assign(r - l + 1, vector<T>(sigma + 1, T_id));",
            "\t\t\tlarge[bi + 1] = large[bi];",
            "\t\t\tif(GET_LESS){",
            "\t\t\t\tfor(auto x = 0; x < sigma; ++ x) large[bi + 1][x + 1] = TT(large[bi + 1][x], sum[x]);",
            "\t\t\t\tfor(auto i = 0; i < (int)order.size(); ++ i) small_mapping[bi][a[order[i]] + 1] = i + 1;",
            "\t\t\t\tfor(auto x = 0; x < sigma; ++ x) small_mapping[bi][x + 1] = max(small_mapping[bi][x], small_mapping[bi][x + 1]);",
            "\t\t\t\tfor(auto i = l; i < r; ++ i) small[bi][i + 1 - l][small_mapping[bi][a[i] + 1]] = TT(small[bi][i + 1 - l][small_mapping[bi][a[i] + 1]], w[i]);",
            "\t\t\t\tfor(auto i = 0; i <= r - l; ++ i) for(auto x = 1; x <= sigma; ++ x) small[bi][i][x] = TT(small[bi][i][x - 1], small[bi][i][x]);",
            "\t\t\t\tfor(auto i = 1; i <= r - l; ++ i) for(auto x = 0; x <= sigma; ++ x) small[bi][i][x] = TT(small[bi][i - 1][x], small[bi][i][x]);",
            "\t\t\t}",
            "\t\t\telse{",
            "\t\t\t\tfor(auto x = sigma - 1; x >= 0; -- x) large[bi + 1][x] = TT(large[bi + 1][x + 1], sum[x]);",
            "\t\t\t\tfill(small_mapping[bi].begin(), small_mapping[bi].end(), (int)order.size());",
            "\t\t\t\tfor(auto i = 0; i < (int)order.size(); ++ i) small_mapping[bi][a[order[i]]] = i;",
            "\t\t\t\tfor(auto x = sigma - 1; x >= 0; -- x) small_mapping[bi][x] = min(small_mapping[bi][x], small_mapping[bi][x + 1]);",
            "\t\t\t\tfor(auto i = l; i < r; ++ i) small[bi][i + 1 - l][small_mapping[bi][a[i]]] = TT(small[bi][i + 1 - l][small_mapping[bi][a[i]]], w[i]);",
            "\t\t\t\tfor(auto i = 0; i <= r - l; ++ i) for(auto x = sigma - 1; x >= 0; -- x) small[bi][i][x] = TT(small[bi][i][x + 1], small[bi][i][x]);",
            "\t\t\t\tfor(auto i = 1; i <= r - l; ++ i) for(auto x = 0; x <= sigma; ++ x) small[bi][i][x] = TT(small[bi][i - 1][x], small[bi][i][x]);",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "\tvalue_range_query_solver_online_sqrt &operator=(const value_range_query_solver_online_sqrt &vrq){",
            "\t\tn = vrq.n;",
            "\t\tsigma = vrq.sigma;",
            "\t\tlarge = vrq.large;",
            "\t\tsmall_mapping = vrq.small_mapping;",
            "\t\tsmall = vrq.small;",
            "\t\treturn *this;",
            "\t}",
            "\t// Find the sum of w[i] for all i with",
            "\t//  0 <= i < qr and (a[i] < k if GET_LESS else k <= a[i])",
            "\t// O(1)",
            "\tT query(int qr, int k) const{",
            "\t\tassert(0 <= qr && qr <= n);",
            "\t\tassert(0 <= k && k <= sigma);",
            "\t\tif(qr == 0) return T_id;",
            "\t\tint bi = (qr - 1) / BX;",
            "\t\treturn TT(large[bi][k], small[bi][qr - BX * bi][small_mapping[bi][k]]);",
            "\t}",
            "};"
        ],
        "description": "tranxuanbach"
    }
}