{
    "tranxuanbach": {
        "prefix": "strongly_connected_components",
        "body": [
            "// Requires graph",
            "struct strongly_connected_components{",
            "\tint n, attempt;",
            "\tvector<int> dp;",
            "\tvector<int> stack;",
            "\tvector<int> assigned;",
            "\tvector<int> was;",
            "\t// condensation descriptions",
            "\tvector<int> belongs; // vertex -> component",
            "\tvector<vector<int>> comp; // in topological order",
            "\tgraph<int> condensation; // edge weights are the original edge id",
            "\tstrongly_connected_components(){ }",
            "\tstrongly_connected_components(int n){ init(n); }",
            "\ttemplate<class T>",
            "\tstrongly_connected_components(const graph<T> &g){ init(g.n); run_all(g); }",
            "\tvoid init(int n){",
            "\t\tthis->n = n;",
            "\t\tdp.assign(n, -1);",
            "\t\tstack.reserve(n);",
            "\t\tassigned.assign(n, -1);",
            "\t\twas.assign(n, -2);",
            "\t\tattempt = -1;",
            "\t\tbelongs.assign(n, -1);",
            "\t\tcomp.clear();",
            "\t}",
            "\t// O(n + m) where n and m are the number of reachable nodes and edges respectively.",
            "\ttemplate<class T>",
            "\tvoid _run(const graph<T> &g, const vector<int> &src){",
            "\t\tint it = 0;",
            "\t\tauto dfs = [&](auto self, int u)->int{",
            "\t\t\tint low = dp[u] = ++ it;",
            "\t\t\twas[u] = attempt;",
            "\t\t\tstack.push_back(u);",
            "\t\t\tfor(auto id: g.adj[u]){",
            "\t\t\t\tif(g.ignore && g.ignore(id)) continue;",
            "\t\t\t\tint v = g.edge[id].to;",
            "\t\t\t\tif(assigned[v] != attempt){",
            "\t\t\t\t\tif(was[v] != attempt){",
            "\t\t\t\t\t\twas[v] = attempt;",
            "\t\t\t\t\t\tdp[v] = -1;",
            "\t\t\t\t\t}",
            "\t\t\t\t\tlow = min(low, ~dp[v] ? dp[v] : self(self, v));",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t\tif(low == dp[u]){",
            "\t\t\t\tvector<int> c;",
            "\t\t\t\twhile(true){",
            "\t\t\t\t\tint v = stack.back();",
            "\t\t\t\t\tstack.pop_back();",
            "\t\t\t\t\tassigned[v] = attempt;",
            "\t\t\t\t\tc.push_back(v);",
            "\t\t\t\t\tif(u == v) break;",
            "\t\t\t\t}",
            "\t\t\t\tcomp.push_back(move(c));",
            "\t\t\t}",
            "\t\t\treturn dp[u] = low;",
            "\t\t};",
            "\t\tfor(auto u: src) if(was[u] != attempt) dfs(dfs, u);",
            "\t\treverse(comp.begin(), comp.end());",
            "\t\tcondensation = {count()};",
            "\t\tfor(auto i = 0; i < count(); ++ i) for(auto u: comp[i]) belongs[u] = i;",
            "\t\tfor(auto i = 0; i < count(); ++ i) for(auto u: comp[i]) for(auto id: g.adj[u]){",
            "\t\t\tif(g.ignore && g.ignore(id)) continue;",
            "\t\t\tint v = g(u, id);",
            "\t\t\tif(i != belongs[v]){",
            "\t\t\t\tassert(i < belongs[v]);",
            "\t\t\t\tcondensation.orient(i, belongs[v], id);",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "\ttemplate<class T>",
            "\tvoid run(const graph<T> &g, const vector<int> &src){",
            "\t\tassert(g.n <= n);",
            "\t\tfor(auto u: src) assert(0 <= u && u < g.n);",
            "\t\tcomp.clear();",
            "\t\t++ attempt;",
            "\t\t_run(g, src);",
            "\t}",
            "\ttemplate<class T>",
            "\tvoid run_all(const graph<T> &g){",
            "\t\tassert(g.n <= n);",
            "\t\tcomp.clear();",
            "\t\t++ attempt;",
            "\t\tvector<int> src(n);",
            "\t\tiota(src.begin(), src.end(), 0);",
            "\t\t_run(g, src);",
            "\t}",
            "\t// Check if u is visited during the last run-like call",
            "\tbool visited(int u) const{",
            "\t\tassert(0 <= u && u < n);",
            "\t\treturn was[u] == attempt;",
            "\t}",
            "\t// # of strongly connected components",
            "\tint count() const{",
            "\t\treturn (int)comp.size();",
            "\t}",
            "};"
        ],
        "description": "tranxuanbach"
    }
}