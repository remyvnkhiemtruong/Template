{
    "tranxuanbach": {
        "prefix": "matrix_fixed",
        "body": [
            "template<class T, size_t N, size_t M>",
            "struct matrix_fixed_base{",
            "\tint n, m;",
            "\tarray<array<T, M>, N> data;",
            "\tarray<T, M> &operator[](int i){",
            "\t\tassert(0 <= i && i < n);",
            "\t\treturn data[i];",
            "\t}",
            "\tconst array<T, M> &operator[](int i) const{",
            "\t\tassert(0 <= i && i < n);",
            "\t\treturn data[i];",
            "\t}",
            "\tmatrix_fixed_base &inplace_slice(int il, int ir, int jl, int jr){",
            "\t\tassert(0 <= il && il <= ir && ir <= n);",
            "\t\tassert(0 <= jl && jl <= jr && jr <= m);",
            "\t\tn = ir - il, m = jr - jl;",
            "\t\tif(il > 0) for(auto i = 0; i < n; ++ i) swap(data[i], data[il + i]);",
            "\t\tdata.resize(n);",
            "\t\tfor(auto &row: data){",
            "\t\t\trow.erase(row.begin(), row.begin() + jl);",
            "\t\t\trow.resize(m);",
            "\t\t}",
            "\t\treturn *this;",
            "\t}",
            "\tmatrix_fixed_base slice(int il, int ir, int jl, int jr) const{",
            "\t\treturn matrix_fixed_base(*this).inplace_slice(il, ir, jl, jr);",
            "\t}",
            "\tmatrix_fixed_base &inplace_row_slice(int il, int ir){",
            "\t\tassert(0 <= il && il <= ir && ir <= n);",
            "\t\tn = ir - il;",
            "\t\tif(il > 0) for(auto i = 0; i < n; ++ i) swap(data[i], data[il + i]);",
            "\t\tdata.resize(n);",
            "\t\treturn *this;",
            "\t}",
            "\tmatrix_fixed_base row_slice(int il, int ir) const{",
            "\t\treturn matrix_fixed_base(*this).inplace_row_slice(il, ir);",
            "\t}",
            "\tmatrix_fixed_base &inplace_column_slice(int jl, int jr){",
            "\t\tassert(0 <= jl && jl <= jr && jr <= m);",
            "\t\tm = jr - jl;",
            "\t\tfor(auto &row: data){",
            "\t\t\trow.erase(row.begin(), row.begin() + jl);",
            "\t\t\trow.resize(m);",
            "\t\t}",
            "\t\treturn *this;",
            "\t}",
            "\tmatrix_fixed_base column_slice(int jl, int jr) const{",
            "\t\treturn matrix_fixed_base(*this).inplace_column_slice(jl, jr);",
            "\t}",
            "\tbool operator==(const matrix_fixed_base &a) const{",
            "\t\tassert(n == a.n && m == a.m);",
            "\t\treturn data == a.data;",
            "\t}",
            "\tbool operator!=(const matrix_fixed_base &a) const{",
            "\t\tassert(n == a.n && m == a.m);",
            "\t\treturn data != a.data;",
            "\t}",
            "\tmatrix_fixed_base &operator+=(const matrix_fixed_base &a){",
            "\t\tassert(n == a.n && m == a.m);",
            "\t\tfor(auto i = 0; i < n; ++ i) for(auto j = 0; j < m; ++ j) data[i][j] += a[i][j];",
            "\t\treturn *this;",
            "\t}",
            "\tmatrix_fixed_base operator+(const matrix_fixed_base &a) const{",
            "\t\treturn matrix_fixed_base(*this) += a;",
            "\t}",
            "\tmatrix_fixed_base &operator-=(const matrix_fixed_base &a){",
            "\t\tassert(n == a.n && m == a.m);",
            "\t\tfor(auto i = 0; i < n; ++ i) for(auto j = 0; j < m; ++ j) data[i][j] -= a[i][j];",
            "\t\treturn *this;",
            "\t}",
            "\tmatrix_fixed_base operator-(const matrix_fixed_base &a) const{",
            "\t\treturn matrix_fixed_base(*this) -= a;",
            "\t}",
            "\tmatrix_fixed_base operator*=(const matrix_fixed_base &a){",
            "\t\tassert(m == a.n);",
            "\t\tint l = a.m;",
            "\t\tmatrix_fixed_base res(n, l);",
            "\t\tfor(auto i = 0; i < n; ++ i) for(auto j = 0; j < m; ++ j) for(auto k = 0; k < l; ++ k) res[i][k] += data[i][j] * a[j][k];",
            "\t\treturn *this = res;",
            "\t}",
            "\tmatrix_fixed_base operator*(const matrix_fixed_base &a) const{",
            "\t\treturn matrix_fixed_base(*this) *= a;",
            "\t}",
            "\tmatrix_fixed_base &operator*=(T c){",
            "\t\tfor(auto i = 0; i < n; ++ i) for(auto j = 0; j < m; ++ j) data[i][j] *= c;",
            "\t\treturn *this;",
            "\t}",
            "\tmatrix_fixed_base operator*(T c) const{",
            "\t\treturn matrix_fixed_base(*this) *= c;",
            "\t}",
            "\ttemplate<class U, typename enable_if<is_integral<U>::value>::type* = nullptr>",
            "\tmatrix_fixed_base &inplace_power(U e){",
            "\t\tassert(n == m && e >= 0);",
            "\t\tmatrix_fixed_base res(n, n, T{1});",
            "\t\tfor(; e; *this *= *this, e >>= 1) if(e & 1) res *= *this;",
            "\t\treturn *this = res;",
            "\t}",
            "\ttemplate<class U>",
            "\tmatrix_fixed_base power(U e) const{",
            "\t\treturn matrix_fixed_base(*this).inplace_power(e);",
            "\t}",
            "\tmatrix_fixed_base &inplace_transpose(){",
            "\t\tassert(n == m);",
            "\t\tfor(auto i = 0; i < n; ++ i) for(auto j = i + 1; j < n; ++ j) swap(data[i][j], data[j][i]);",
            "\t\treturn *this;",
            "\t}",
            "\tmatrix_fixed_base transpose() const{",
            "\t\tif(n == m) return matrix_fixed_base(*this).inplace_transpose();",
            "\t\tmatrix_fixed_base res(m, n);",
            "\t\tfor(auto i = 0; i < n; ++ i) for(auto j = 0; j < m; ++ j) res[j][i] = data[i][j];",
            "\t\treturn res;",
            "\t}",
            "\tarray<T, N> operator*(const array<T, M> &v) const{",
            "\t\tassert(m == (int)v.size());",
            "\t\tarray<T, N> res;",
            "\t\tres.fill(T{0});",
            "\t\tfor(auto i = 0; i < n; ++ i) for(auto j = 0; j < m; ++ j) res[i] += data[i][j] * v[j];",
            "\t\treturn res;",
            "\t}",
            "\t// Assumes T is either a floating, integral, or a modular type.",
            "\t// If T is a floating type, O(up_to) divisions with O(n * m * up_to) additions, subtractions, and multiplications.",
            "\t// Otherwise, O(n * up_to * log(size)) divisions with O(n * m * up_to) additions, subtractions, and multiplications.",
            "\t// Returns {REF matrix_fixed_base, determinant, rank}",
            "\ttuple<matrix_fixed_base &, T, int> inplace_REF(int up_to = -1){",
            "\t\tif(n == 0) return {*this, T{1}, 0};",
            "\t\tif(!~up_to) up_to = m;",
            "\t\tT det = 1;",
            "\t\tint rank = 0;",
            "\t\tfor(auto j = 0; j < up_to; ++ j){",
            "\t\t\tif constexpr(is_floating_point_v<T>){",
            "\t\t\t\tstatic const T eps = 1e-9;",
            "\t\t\t\tint pivot = rank;",
            "\t\t\t\tfor(auto i = rank + 1; i < n; ++ i) if(abs(data[pivot][j]) < abs(data[i][j])) pivot = i;",
            "\t\t\t\tif(rank != pivot){",
            "\t\t\t\t\tswap(data[rank], data[pivot]);",
            "\t\t\t\t\tdet *= -1;",
            "\t\t\t\t}",
            "\t\t\t\tif(abs(data[rank][j]) <= eps) continue;",
            "\t\t\t\tdet *= data[rank][j];",
            "\t\t\t\tT inv = 1 / data[rank][j];",
            "\t\t\t\tfor(auto i = rank + 1; i < n; ++ i) if(abs(data[i][j]) > eps){",
            "\t\t\t\t\tT coef = data[i][j] * inv;",
            "\t\t\t\t\tfor(auto k = j; k < m; ++ k) data[i][k] -= coef * data[rank][k];",
            "\t\t\t\t}",
            "\t\t\t\t++ rank;",
            "\t\t\t}",
            "\t\t\telse{",
            "\t\t\t\tfor(auto i = rank + 1; i < n; ++ i) while(data[i][j]){",
            "\t\t\t\t\tT q;",
            "\t\t\t\t\tif constexpr(is_integral_v<T> || is_same_v<T, __int128_t> || is_same_v<T, __uint128_t>) q = data[rank][j] / data[i][j];",
            "\t\t\t\t\telse q = data[rank][j].data / data[i][j].data;",
            "\t\t\t\t\tif(q) for(auto k = j; k < m; ++ k) data[rank][k] -= q * data[i][k];",
            "\t\t\t\t\tswap(data[rank], data[i]);",
            "\t\t\t\t\tdet *= -1;",
            "\t\t\t\t}",
            "\t\t\t\tif(rank == j) det *= data[rank][j];",
            "\t\t\t\telse det = T(0);",
            "\t\t\t\tif(data[rank][j]) ++ rank;",
            "\t\t\t}",
            "\t\t\tif(rank == n) break;",
            "\t\t}",
            "\t\treturn {*this, det, rank};",
            "\t}",
            "\t// Assumes T is either a floating, integral, or a modular type.",
            "\t// If T is a floating type, O(up_to) divisions with O(n * m * up_to) additions, subtractions, and multiplications.",
            "\t// Otherwise, O(n * up_to * log(size)) divisions with O(n * m * up_to) additions, subtractions, and multiplications.",
            "\t// Returns {REF matrix_fixed_base, determinant, rank}",
            "\ttuple<matrix_fixed_base, T, int> REF(int up_to = -1) const{",
            "\t\treturn matrix_fixed_base(*this).inplace_REF(up_to);",
            "\t}",
            "\t// Assumes T is a field.",
            "\t// O(up_to) divisions with O(n * m * up_to) additions, subtractions, and multiplications.",
            "\t// Returns {REF matrix_fixed_base, determinant, rank}",
            "\ttuple<matrix_fixed_base &, T, int> inplace_REF_field(int up_to = -1){",
            "\t\tif(n == 0) return {*this, T{1}, 0};",
            "\t\tif(!~up_to) up_to = m;",
            "\t\tT det = T{1};",
            "\t\tint rank = 0;",
            "\t\tfor(auto j = 0; j < up_to; ++ j){",
            "\t\t\tint pivot = -1;",
            "\t\t\tfor(auto i = rank; i < n; ++ i) if(data[i][j] != T(0)){",
            "\t\t\t\tpivot = i;",
            "\t\t\t\tbreak;",
            "\t\t\t}",
            "\t\t\tif(!~pivot){",
            "\t\t\t\tdet = T(0);",
            "\t\t\t\tcontinue;",
            "\t\t\t}",
            "\t\t\tif(rank != pivot){",
            "\t\t\t\tswap(data[rank], data[pivot]);",
            "\t\t\t\tdet *= -1;",
            "\t\t\t}",
            "\t\t\tdet *= data[rank][j];",
            "\t\t\tT inv = 1 / data[rank][j];",
            "\t\t\tfor(auto i = rank + 1; i < n; ++ i) if(data[i][j] != T(0)){",
            "\t\t\t\tT coef = data[i][j] * inv;",
            "\t\t\t\tfor(auto k = j; k < m; ++ k) data[i][k] -= coef * data[rank][k];",
            "\t\t\t}",
            "\t\t\t++ rank;",
            "\t\t\tif(rank == n) break;",
            "\t\t}",
            "\t\treturn {*this, det, rank};",
            "\t}",
            "\t// Assumes T is a field.",
            "\t// O(up_to) divisions with O(n * m * up_to) additions, subtractions, and multiplications.",
            "\t// Returns {REF matrix_fixed_base, determinant, rank}",
            "\ttuple<matrix_fixed_base, T, int> REF_field(int up_to = -1) const{",
            "\t\treturn matrix_fixed_base(*this).inplace_REF_field(up_to);",
            "\t}",
            "\t// Assumes T is a field.",
            "\t// O(n) divisions with O(n^3) additions, subtractions, and multiplications.",
            "\toptional<matrix_fixed_base> inverse() const{",
            "\t\tassert(n == m);",
            "\t\tif(n == 0) return *this;",
            "\t\tauto a = data;",
            "\t\tauto res = multiplicative_identity();",
            "\t\tfor(auto j = 0; j < n; ++ j){",
            "\t\t\tint rank = j, pivot = -1;",
            "\t\t\tif constexpr(is_floating_point_v<T>){",
            "\t\t\t\tstatic const T eps = 1e-9;",
            "\t\t\t\tpivot = rank;",
            "\t\t\t\tfor(auto i = rank + 1; i < n; ++ i) if(abs(a[pivot][j]) < abs(a[i][j])) pivot = i;",
            "\t\t\t\tif(abs(a[pivot][j]) <= eps) return {};",
            "\t\t\t}",
            "\t\t\telse{",
            "\t\t\t\tfor(auto i = rank; i < n; ++ i) if(a[i][j] != T(0)){",
            "\t\t\t\t\tpivot = i;",
            "\t\t\t\t\tbreak;",
            "\t\t\t\t}",
            "\t\t\t\tif(!~pivot) return {};",
            "\t\t\t}",
            "\t\t\tswap(a[rank], a[pivot]), swap(res[rank], res[pivot]);",
            "\t\t\tT inv = 1 / a[rank][j];",
            "\t\t\tfor(auto k = 0; k < n; ++ k) a[rank][k] *= inv, res[rank][k] *= inv;",
            "\t\t\tfor(auto i = 0; i < n; ++ i){",
            "\t\t\t\tif constexpr(is_floating_point_v<T>){",
            "\t\t\t\t\tstatic const T eps = 1e-9;",
            "\t\t\t\t\tif(i != rank && abs(a[i][j]) > eps){",
            "\t\t\t\t\t\tT d = a[i][j];",
            "\t\t\t\t\t\tfor(auto k = 0; k < n; ++ k) a[i][k] -= d * a[rank][k], res[i][k] -= d * res[rank][k];",
            "\t\t\t\t\t}",
            "\t\t\t\t}",
            "\t\t\t\telse if(i != rank && a[i][j] != T(0)){",
            "\t\t\t\t\tT d = a[i][j];",
            "\t\t\t\t\tfor(auto k = 0; k < n; ++ k) a[i][k] -= d * a[rank][k], res[i][k] -= d * res[rank][k];",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t}",
            "\t\treturn res;",
            "\t}",
            "\t// Assumes T is either a floating, integral, or a modular type.",
            "\t// If T is a floating type, O(n) divisions with O(n^3) additions, subtractions, and multiplications.",
            "\t// Otherwise, O(n^2 * log(size)) divisions with O(n^3) additions, subtractions, and multiplications.",
            "\tT determinant() const{",
            "\t\tassert(n == m);",
            "\t\treturn get<1>(REF());",
            "\t}",
            "\t// Assumes T is a field.",
            "\t// O(n) divisions with O(n^3) additions, subtractions, and multiplications.",
            "\tT determinant_field() const{",
            "\t\tassert(n == m);",
            "\t\treturn get<1>(REF_field());",
            "\t}",
            "\t// Assumes T is either a floating, integral, or a modular type.",
            "\t// If T is a floating type, O(n) divisions with O(n^3) additions, subtractions, and multiplications.",
            "\t// Otherwise, O(n^2 * log(size)) divisions with O(n^3) additions, subtractions, and multiplications.",
            "\tint rank() const{",
            "\t\treturn get<2>(REF());",
            "\t}",
            "\t// Assumes T is a field.",
            "\t// O(n) divisions with O(n^3) additions, subtractions, and multiplications.",
            "\tint rank_field() const{",
            "\t\treturn get<2>(REF_field());",
            "\t}",
            "\t// Regarding the matrix_fixed_base as a system of linear equations by separating first m-1 columns, find a solution of the linear equation.",
            "\t// Assumes T is a field",
            "\t// O(n * m^2)",
            "\toptional<array<T, M - 1>> find_a_solution() const{",
            "\t\tassert(m >= 1);",
            "\t\tauto [ref, _, rank] = REF_field(m - 1);",
            "\t\tfor(auto i = rank; i < n; ++ i) if(ref[i][m - 1] != T{0}) return {};",
            "\t\tarray<T, M - 1> res;",
            "\t\tres.fill(T{0});",
            "\t\tfor(auto i = rank - 1; i >= 0; -- i){",
            "\t\t\tint pivot = 0;",
            "\t\t\twhile(pivot < m - 1 && ref[i][pivot] == T{0}) ++ pivot;",
            "\t\t\tassert(pivot < m - 1);",
            "\t\t\tres[pivot] = ref[i][m - 1];",
            "\t\t\tfor(auto j = pivot + 1; j < m - 1; ++ j) res[pivot] -= ref[i][j] * res[j];",
            "\t\t\tres[pivot] /= ref[i][pivot];",
            "\t\t}",
            "\t\treturn res;",
            "\t}",
            "\t// O(n * 2^n)",
            "\tT permanent() const{",
            "\t\tassert(n <= 30 && n == m);",
            "\t\tT perm = n ? 0 : 1;",
            "\t\tarray<T, N> sum;",
            "\t\tsum.fill(T{0});",
            "\t\tfor(auto order = 1; order < 1 << n; ++ order){",
            "\t\t\tint j = __lg(order ^ order >> 1 ^ order - 1 ^ order - 1 >> 1), sign = (order ^ order >> 1) & 1 << j ? 1 : -1;",
            "\t\t\tT prod = order & 1 ? -1 : 1;",
            "\t\t\tif((order ^ order >> 1) & 1 << j) for(auto i = 0; i < n; ++ i) prod *= sum[i] += data[i][j];",
            "\t\t\telse for(auto i = 0; i < n; ++ i) prod *= sum[i] -= data[i][j];",
            "\t\t\tperm += prod;",
            "\t\t}",
            "\t\treturn perm * (n & 1 ? -1 : 1);",
            "\t}",
            "\ttemplate<class output_stream>",
            "\tfriend output_stream &operator<<(output_stream &out, const matrix_fixed_base &a){",
            "\t\tout << \"\\n\";",
            "\t\tfor(auto i = 0; i < a.n; ++ i){",
            "\t\t\tfor(auto j = 0; j < a.m; ++ j) out << a[i][j] << \" \";",
            "\t\t\tout << \"\\n\";",
            "\t\t}",
            "\t\treturn out;",
            "\t}",
            "\tmatrix_fixed_base(int n, int m, T init_diagonal = T{0}, T init_off_diagonal = T{0}): n(n), m(m){",
            "\t\tassert(n >= 0 && m >= 0);",
            "\t\tfor(auto i = 0; i < n; ++ i) for(auto j = 0; j < m; ++ j) data[i][j] = i == j ? init_diagonal : init_off_diagonal;",
            "\t}",
            "\tmatrix_fixed_base(int n, int m, const array<array<T, M>, N> &a): n(n), m(m), data(a){ }",
            "\tstatic matrix_fixed_base additive_identity(int n, int m){",
            "\t\treturn matrix_fixed_base(n, m, T{0}, T{0});",
            "\t}",
            "\tstatic matrix_fixed_base multiplicative_identity(int n, int m){",
            "\t\treturn matrix_fixed_base(n, m, T{1}, T{0});",
            "\t}",
            "};",
            "template<class T, size_t N, size_t M>",
            "matrix_fixed_base<T, N, M> operator*(T c, matrix_fixed_base<T, N, M> a){",
            "\tfor(auto i = 0; i < a.n; ++ i) for(auto j = 0; j < a.m; ++ j) a[i][j] = c * a[i][j];",
            "\treturn a;",
            "}",
            "// Multiply a row vector v on the left",
            "template<class T, size_t N, size_t M>",
            "array<T, M> operator*(const array<T, N> &v, const matrix_fixed_base<T, N, M> &a){",
            "\tarray<T, M> res;",
            "\tres.fill(T{0});",
            "\tfor(auto i = 0; i < a.n; ++ i) for(auto j = 0; j < a.m; ++ j) res[j] += v[i] * a[i][j];",
            "\treturn res;",
            "}",
            "",
            "template<class T>",
            "using matrix = matrix_fixed_base<T, 20, 20>;"
        ],
        "description": "tranxuanbach"
    }
}