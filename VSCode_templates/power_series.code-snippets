{
    "tranxuanbach": {
        "prefix": "power_series",
        "body": [
            "// Specialized for FFT",
            "template<class T, class FFT>",
            "struct power_series_base: vector<T>{",
            "#define IS_INTEGRAL(T) (is_integral_v<T> || is_same_v<T, __int128_t> || is_same_v<T, __uint128_t>)",
            "#define data (*this)",
            "\tpower_series_base &_inplace_transform(bool invert = false){",
            "\t\tFFT::transform(data, invert);",
            "\t\treturn *this;",
            "\t}",
            "\tpower_series_base _transform(bool invert = false) const{",
            "\t\treturn power_series_base(*this)._inplace_transform(invert);",
            "\t}",
            "\ttemplate<class ...Args>",
            "\tpower_series_base(Args... args): vector<T>(args...){}",
            "\tpower_series_base(initializer_list<T> init): vector<T>(init){}",
            "\toperator bool() const{",
            "\t\treturn find_if(data.begin(), data.end(), [&](const T &x){ return x != T{0}; }) != data.end();",
            "\t}",
            "\t// Returns \\sum_{i=0}^{n-1} a_i/i! * X^i",
            "\tstatic power_series_base EGF(vector<T> a){",
            "\t\tint n = (int)a.size();",
            "\t\tT fact = 1;",
            "\t\tfor(auto x = 2; x < n; ++ x) fact *= x;",
            "\t\tfact = 1 / fact;",
            "\t\tfor(auto i = n - 1; i >= 0; -- i) a[i] *= fact, fact *= i;",
            "\t\treturn power_series_base(a);",
            "\t}",
            "\t// Returns exp(coef * X).take(n) = \\sum_{i=0}^{n-1} coef^i/i! * X^i",
            "\tstatic power_series_base EGF(int n, T coef = 1){",
            "\t\tvector<T> a(n, 1);",
            "\t\tfor(auto i = 1; i < n; ++ i) a[i] = a[i - 1] * coef;",
            "\t\treturn EGF(a);",
            "\t}",
            "\tvector<T> EGF_to_seq() const{",
            "\t\tint n = (int)data.size();",
            "\t\tvector<T> seq(n);",
            "\t\tT fact = 1;",
            "\t\tfor(auto i = 0; i < n; ++ i){",
            "\t\t\tseq[i] = data[i] * fact;",
            "\t\t\tfact *= i + 1;",
            "\t\t}",
            "\t\treturn seq;",
            "\t}",
            "\tstatic vector<T> _inv;",
            "\tstatic void _precalc_inverse(int obj){",
            "\t\twhile((int)_inv.size() < obj){",
            "\t\t\tT x{(int)_inv.size()};",
            "\t\t\tassert(x);",
            "\t\t\t_inv.push_back(1 / x);",
            "\t\t}",
            "\t}",
            "\tpower_series_base &inplace_reduce(){",
            "\t\twhile(!data.empty() && !data.back()) data.pop_back();",
            "\t\treturn *this;",
            "\t}",
            "\tpower_series_base reduce() const{",
            "\t\treturn power_series_base(*this).inplace_reduce();",
            "\t}",
            "\tfriend ostream &operator<<(ostream &out, const power_series_base &p){",
            "\t\tif(p.empty()) return out << \"{}\";",
            "\t\telse{",
            "\t\t\tout << \"{\";",
            "\t\t\tfor(auto i = 0; i < (int)p.size(); ++ i){",
            "\t\t\t\tout << p[i];",
            "\t\t\t\ti + 1 < (int)p.size() ? out << \", \" : out << \"}\";",
            "\t\t\t}",
            "\t\t\treturn out;",
            "\t\t}",
            "\t}",
            "\tpower_series_base &inplace_take(int n){",
            "\t\tdata.erase(data.begin() + min((int)data.size(), n), data.end());",
            "\t\tdata.resize(n, T{0});",
            "\t\treturn *this;",
            "\t}",
            "\tpower_series_base take(int n) const{",
            "\t\tauto res = vector<T>(data.begin(), data.begin() + min((int)data.size(), n));",
            "\t\tres.resize(n, T{0});",
            "\t\treturn res;",
            "\t}",
            "\tpower_series_base &inplace_drop(int n){",
            "\t\tdata.erase(data.begin(), data.begin() + min((int)data.size(), n));",
            "\t\treturn *this;",
            "\t}",
            "\tpower_series_base drop(int n) const{",
            "\t\treturn vector<T>(data.begin() + min((int)data.size(), n), data.end());",
            "\t}",
            "\tpower_series_base &inplace_slice(int l, int r){",
            "\t\tassert(0 <= l && l <= r);",
            "\t\tdata.erase(data.begin(), data.begin() + min((int)data.size(), l));",
            "\t\tdata.resize(r - l, T{0});",
            "\t\treturn *this;",
            "\t}",
            "\tpower_series_base slice(int l, int r) const{",
            "\t\tauto res = vector<T>(data.begin() + min((int)data.size(), l), data.begin() + min((int)data.size(), r));",
            "\t\tres.resize(r - l, T{0});",
            "\t\treturn res;",
            "\t}",
            "\tpower_series_base &inplace_reverse(int n){",
            "\t\tdata.resize(max(n, (int)data.size()), T{0});",
            "\t\tstd::reverse(data.begin(), data.begin() + n);",
            "\t\treturn *this;",
            "\t}",
            "\tpower_series_base reverse(int n) const{",
            "\t\treturn power_series_base(*this).inplace_reverse(n);",
            "\t}",
            "\tpower_series_base &inplace_shift(int n, T x = T{0}){",
            "\t\tdata.insert(data.begin(), n, x);",
            "\t\treturn *this;",
            "\t}",
            "\tpower_series_base shift(int n, T x = T{0}) const{",
            "\t\treturn power_series_base(*this).inplace_shift(n, x);",
            "\t}",
            "\tT evaluate(T x) const{",
            "\t\tT res = {};",
            "\t\tfor(auto i = (int)data.size() - 1; i >= 0; -- i) res = res * x + data[i];",
            "\t\treturn res;",
            "\t}",
            "\t// Takes mod x^n-1",
            "\tpower_series_base &inplace_circularize(int n){",
            "\t\tassert(n >= 1);",
            "\t\tfor(auto i = n; i < (int)data.size(); ++ i) data[i % n] += data[i];",
            "\t\tdata.resize(n, T{0});",
            "\t\treturn *this;",
            "\t}",
            "\t// Takes mod x^n-1",
            "\tpower_series_base circularize(int n) const{",
            "\t\treturn power_series_base(*this).inplace_circularize(n);",
            "\t}",
            "\tpower_series_base operator*(const power_series_base &p) const{",
            "\t\treturn FFT::convolute(data, p);",
            "\t}",
            "\tpower_series_base &operator*=(const power_series_base &p){",
            "\t\treturn *this = *this * p;",
            "\t}",
            "\ttemplate<class U>",
            "\tpower_series_base &operator*=(U x){",
            "\t\tfor(auto &c: data) c *= x;",
            "\t\treturn *this;",
            "\t}",
            "\ttemplate<class U>",
            "\tpower_series_base operator*(U x) const{",
            "\t\treturn power_series_base(*this) *= x;",
            "\t}",
            "\ttemplate<class U>",
            "\tfriend power_series_base operator*(U x, power_series_base p){",
            "\t\tfor(auto &c: p) c = x * c;",
            "\t\treturn p;",
            "\t}",
            "\t// Compute p^e mod x^n - 1.",
            "\ttemplate<class U, typename enable_if<IS_INTEGRAL(U)>::type* = nullptr>",
            "\tpower_series_base &inplace_power_circular(U e, int n){",
            "\t\tassert(n >= 1);",
            "\t\tpower_series_base p = *this;",
            "\t\tdata.assign(n, 0);",
            "\t\tdata[0] = 1;",
            "\t\tfor(; e; e >>= 1){",
            "\t\t\tif(e & 1) (*this *= p).inplace_circularize(n);",
            "\t\t\t(p *= p).inplace_circularize(n);",
            "\t\t}",
            "\t\treturn *this;",
            "\t}",
            "\ttemplate<class U, typename enable_if<IS_INTEGRAL(U)>::type* = nullptr>",
            "\tpower_series_base power_circular(U e, int len) const{",
            "\t\treturn power_series_base(*this).inplace_power_circular(e, len);",
            "\t}",
            "\tpower_series_base &operator+=(const power_series_base &p){",
            "\t\tdata.resize(max(data.size(), p.size()), T{0});",
            "\t\tfor(auto i = 0; i < (int)p.size(); ++ i) data[i] += p[i];",
            "\t\treturn *this;",
            "\t}",
            "\tpower_series_base operator+(const power_series_base &p) const{",
            "\t\treturn power_series_base(*this) += p;",
            "\t}",
            "\ttemplate<class U>",
            "\tpower_series_base &operator+=(const U &x){",
            "\t\tif(data.empty()) data.emplace_back();",
            "\t\tdata[0] += x;",
            "\t\treturn *this;",
            "\t}",
            "\ttemplate<class U>",
            "\tpower_series_base operator+(const U &x) const{",
            "\t\treturn power_series_base(*this) += x;",
            "\t}",
            "\ttemplate<class U>",
            "\tfriend power_series_base operator+(const U &x, const power_series_base &p){",
            "\t\treturn p + x;",
            "\t}",
            "\tpower_series_base &operator-=(const power_series_base &p){",
            "\t\tdata.resize(max(data.size(), p.size()), T{0});",
            "\t\tfor(auto i = 0; i < (int)p.size(); ++ i) data[i] -= p[i];",
            "\t\treturn *this;",
            "\t}",
            "\tpower_series_base operator-(const power_series_base &p) const{",
            "\t\treturn power_series_base(*this) -= p;",
            "\t}",
            "\ttemplate<class U>",
            "\tpower_series_base &operator-=(const U &x){",
            "\t\tif(data.empty()) data.emplace_back();",
            "\t\tdata[0] -= x;",
            "\t\treturn *this;",
            "\t}",
            "\ttemplate<class U>",
            "\tpower_series_base operator-(const U &x) const{",
            "\t\treturn power_series_base(*this) -= x;",
            "\t}",
            "\ttemplate<class U>",
            "\tfriend power_series_base operator-(const U &x, const power_series_base &p){",
            "\t\treturn -p + x;",
            "\t}",
            "\tpower_series_base operator-() const{",
            "\t\tpower_series_base res = *this;",
            "\t\tfor(auto i = 0; i < data.size(); ++ i) res[i] = T{0} - res[i];",
            "\t\treturn res;",
            "\t}",
            "\tpower_series_base &operator++(){",
            "\t\tif(data.empty()) data.push_back(1);",
            "\t\telse ++ data[0];",
            "\t\treturn *this;",
            "\t}",
            "\tpower_series_base &operator--(){",
            "\t\tif(data.empty()) data.push_back(-1);",
            "\t\telse -- data[0];",
            "\t\treturn *this;",
            "\t}",
            "\tpower_series_base operator++(int){",
            "\t\tpower_series_base result(*this);",
            "\t\tif(data.empty()) data.push_back(1);",
            "\t\telse ++ data[0];",
            "\t\treturn result;",
            "\t}",
            "\tpower_series_base operator--(int){",
            "\t\tpower_series_base result(*this);",
            "\t\tif(data.empty()) data.push_back(-1);",
            "\t\telse -- data[0];",
            "\t\treturn result;",
            "\t}",
            "\tpower_series_base &inplace_clear_range(int l, int r){",
            "\t\tassert(0 <= l && l <= r);",
            "\t\tfor(auto i = l; i < min(r, (int)data.size()); ++ i) data[i] = T{0};",
            "\t\treturn *this;",
            "\t}",
            "\tpower_series_base clear_range(int l, int r) const{",
            "\t\treturn power_series_base(*this).inplace_clear_range(l, r);",
            "\t}",
            "\tpower_series_base &inplace_dot_product(const power_series_base &p){",
            "\t\tfor(auto i = 0; i < min(data.size(), p.size()); ++ i) data[i] *= p[i];",
            "\t\treturn *this;",
            "\t}",
            "\tpower_series_base dot_product(const power_series_base &p) const{",
            "\t\treturn power_series_base(*this).inplace_power_series_product(p);",
            "\t}",
            "\tpower_series_base &_inverse_doubled_up(power_series_base &f, const power_series_base &freq) const{",
            "\t\tassert((f.size() & -f.size()) == f.size());",
            "\t\tint s = f.size();",
            "\t\tpower_series_base buffer = take(s << 1);",
            "\t\tbuffer._inplace_transform();",
            "\t\tbuffer.inplace_dot_product(freq);",
            "\t\tbuffer._inplace_transform(true);",
            "\t\tbuffer.inplace_clear_range(0, s);",
            "\t\tbuffer._inplace_transform();",
            "\t\tbuffer.inplace_dot_product(freq);",
            "\t\tbuffer._inplace_transform(true);",
            "\t\tf.resize(s << 1, T{0});",
            "\t\treturn f -= buffer.inplace_clear_range(0, s);",
            "\t}",
            "\tpower_series_base &_inverse_doubled_up(power_series_base &f) const{",
            "\t\tassert((f.size() & -f.size()) == f.size());",
            "\t\treturn _inverse_doubled_up(f, f.take(f.size() << 1)._transform());",
            "\t}",
            "\t// Returns the first n terms of the inverse series",
            "\t// O(n * log(n))",
            "\tpower_series_base inverse(int n) const{",
            "\t\tassert(!data.empty() && data[0] != T{0});",
            "\t\tauto inv = 1 / data[0];",
            "\t\tpower_series_base res{inv};",
            "\t\tfor(auto s = 1; s < n; s <<= 1) _inverse_doubled_up(res);",
            "\t\tres.resize(n, T{0});",
            "\t\treturn res;",
            "\t}",
            "\t// Returns the first n terms of the inverse series",
            "\t// O(n * log(n))",
            "\tpower_series_base &inplace_inverse(int n){",
            "\t\treturn *this = this->inverse(n);",
            "\t}",
            "\t// O(n * log(n))",
            "\tpower_series_base &inplace_power_series_division(power_series_base p, int n){",
            "\t\tint i = 0;",
            "\t\twhile(i < min(data.size(), p.size()) && !data[i] && !p[i]) ++ i;",
            "\t\tdata.erase(data.begin(), data.begin() + i);",
            "\t\tp.erase(p.begin(), p.begin() + i);",
            "\t\t(*this *= p.inverse(n)).resize(n, T{0});",
            "\t\treturn *this;",
            "\t}",
            "\t// O(n * log(n))",
            "\tpower_series_base power_series_division(const power_series_base &p, int n){",
            "\t\treturn power_series_base(*this).inplace_power_series_division(p, n);",
            "\t}",
            "\t// Euclidean division",
            "\t// O(min(n * log(n), # of non-zero indices))",
            "\tpower_series_base &operator/=(const power_series_base &p){",
            "\t\tint n = (int)p.size();",
            "\t\twhile(n && p[n - 1] == T{0}) -- n;",
            "\t\tassert(n >= 1);",
            "\t\tinplace_reduce();",
            "\t\tif(data.size() < n){",
            "\t\t\tdata.clear();",
            "\t\t\treturn *this;",
            "\t\t}",
            "\t\tif(n - count(p.begin(), p.begin() + n, T{0}) <= 100){",
            "\t\t\tT inv = 1 / p[n - 1];",
            "\t\t\tstatic vector<int> indices;",
            "\t\t\tfor(auto i = 0; i < n - 1; ++ i) if(p[i]) indices.push_back(i);",
            "\t\t\tpower_series_base res((int)data.size() - n + 1);",
            "\t\t\tfor(auto i = (int)data.size() - 1; i >= n - 1; -- i) if(data[i]){",
            "\t\t\t\tT x = data[i] * inv;",
            "\t\t\t\tres[i - n + 1] = x;",
            "\t\t\t\tfor(auto j: indices) data[i - (n - 1 - j)] -= x * p[j];",
            "\t\t\t}",
            "\t\t\tindices.clear();",
            "\t\t\treturn *this = res;",
            "\t\t}",
            "\t\tpower_series_base b;",
            "\t\tn = data.size() - p.size() + 1;",
            "\t\tb.assign(n, {});",
            "\t\tcopy(p.rbegin(), p.rbegin() + min(p.size(), b.size()), b.begin());",
            "\t\tstd::reverse(data.begin(), data.end());",
            "\t\tdata = FFT::convolute(data, b.inverse(n));",
            "\t\tdata.erase(data.begin() + n, data.end());",
            "\t\tstd::reverse(data.begin(), data.end());",
            "\t\treturn *this;",
            "\t}",
            "\tpower_series_base operator/(const power_series_base &p) const{",
            "\t\treturn power_series_base(*this) /= p;",
            "\t}",
            "\ttemplate<class U>",
            "\tpower_series_base &operator/=(U x){",
            "\t\tassert(x);",
            "\t\tT inv_x = T(1) / x;",
            "\t\tfor(auto &c: data) c *= inv_x;",
            "\t\treturn *this;",
            "\t}",
            "\ttemplate<class U>",
            "\tpower_series_base operator/(U x) const{",
            "\t\treturn power_series_base(*this) /= x;",
            "\t}",
            "\tpair<power_series_base, power_series_base> divrem(const power_series_base &p) const{",
            "\t\tauto q = *this / p, r = *this - q * p;",
            "\t\twhile(!r.empty() && r.back() == 0) r.pop_back();",
            "\t\treturn {q, r};",
            "\t}",
            "\tpower_series_base &operator%=(const power_series_base &p){",
            "\t\tint n = (int)p.size();",
            "\t\twhile(n && p[n - 1] == T{0}) -- n;",
            "\t\tassert(n >= 1);",
            "\t\tinplace_reduce();",
            "\t\tif(data.size() < n) return *this;",
            "\t\tif(n - count(p.begin(), p.begin() + n, 0) <= 100){",
            "\t\t\tT inv = 1 / p[n - 1];",
            "\t\t\tstatic vector<int> indices;",
            "\t\t\tfor(auto i = 0; i < n - 1; ++ i) if(p[i]) indices.push_back(i);",
            "\t\t\tfor(auto i = (int)data.size() - 1; i >= n - 1; -- i) if(data[i]){",
            "\t\t\t\tT x = data[i] * inv;",
            "\t\t\t\tdata[i] = 0;",
            "\t\t\t\tfor(auto j: indices) data[i - (n - 1 - j)] -= x * p[j];",
            "\t\t\t}",
            "\t\t\tindices.clear();",
            "\t\t\treturn inplace_reduce();",
            "\t\t}",
            "\t\treturn *this = this->divrem(p).second;",
            "\t}",
            "\tpower_series_base operator%(const power_series_base &p) const{",
            "\t\treturn power_series_base(*this) %= p;",
            "\t}",
            "\tpower_series_base &inplace_derivative(){",
            "\t\tif(!data.empty()){",
            "\t\t\tfor(auto i = 0; i < data.size(); ++ i) data[i] *= i;",
            "\t\t\tdata.erase(data.begin());",
            "\t\t}",
            "\t\treturn *this;",
            "\t}",
            "\t// p'",
            "\tpower_series_base derivative() const{",
            "\t\treturn power_series_base(*this).inplace_derivative();",
            "\t}",
            "\tpower_series_base &inplace_derivative_shift(){",
            "\t\tfor(auto i = 0; i < data.size(); ++ i) data[i] *= i;",
            "\t\treturn *this;",
            "\t}",
            "\t// xP'",
            "\tpower_series_base derivative_shift() const{",
            "\t\treturn power_series_base(*this).inplace_derivative_shift();",
            "\t}",
            "\tpower_series_base &inplace_antiderivative(){",
            "\t\t_precalc_inverse((int)data.size());",
            "\t\tdata.push_back(0);",
            "\t\tfor(auto i = (int)data.size() - 1; i >= 1; -- i) data[i] = data[i - 1] * _inv[i];",
            "\t\tdata[0] = 0;",
            "\t\treturn *this;",
            "\t}",
            "\t// Integral(P)",
            "\tpower_series_base antiderivative() const{",
            "\t\treturn power_series_base(*this).inplace_antiderivative();",
            "\t}",
            "\tpower_series_base &inplace_shifted_antiderivative(){",
            "\t\t_precalc_inverse((int)data.size());",
            "\t\tif(!data.empty()) data[0] = 0;",
            "\t\tfor(auto i = 1; i < data.size(); ++ i) data[i] *= _inv[i];",
            "\t\treturn *this;",
            "\t}",
            "\t// Integral(P/x)",
            "\tpower_series_base shifted_antiderivative() const{",
            "\t\treturn power_series_base(*this).inplace_shifted_antiderivative();",
            "\t}",
            "\t// O(n * log(n))",
            "\tpower_series_base &inplace_log(int n){",
            "\t\tassert(!data.empty() && data[0] == 1);",
            "\t\tif(!n){",
            "\t\t\tdata.clear();",
            "\t\t\treturn *this;",
            "\t\t}",
            "\t\t(*this = derivative() * inverse(n)).resize(n - 1, T{0});",
            "\t\tinplace_antiderivative();",
            "\t\treturn *this;",
            "\t}",
            "\t// O(n * log(n))",
            "\tpower_series_base log(int n) const{",
            "\t\treturn power_series_base(*this).inplace_log(n);",
            "\t}",
            "\t// O(n * log(n))",
            "\tpower_series_base exp(int n) const{",
            "\t\tassert(data.empty() || data[0] == 0);",
            "\t\tpower_series_base f{1}, g{1};",
            "\t\tfor(auto s = 1; s < n; s <<= 1){",
            "\t\t\tpower_series_base f2 = f.take(s << 1)._inplace_transform();",
            "\t\t\tpower_series_base g2 = g.take(s << 1)._inplace_transform();",
            "\t\t\tpower_series_base dt = take(s).inplace_derivative_shift();",
            "\t\t\tpower_series_base w = dt;",
            "\t\t\tw._inplace_transform();",
            "\t\t\tfor(auto i = 0; i < s; ++ i) w[i] *= f2[i << 1];",
            "\t\t\tw._inplace_transform(true);",
            "\t\t\tw -= f.derivative_shift();",
            "\t\t\tw.resize(s << 1, T{0});",
            "\t\t\tw._inplace_transform();",
            "\t\t\tw.inplace_dot_product(g2);",
            "\t\t\tw._inplace_transform(true);",
            "\t\t\tw.resize(s, T{0});",
            "\t\t\tw.insert(w.begin(), s, 0);",
            "\t\t\tw -= dt;",
            "\t\t\tpower_series_base z = take(s << 1);",
            "\t\t\tz += w.inplace_shifted_antiderivative();",
            "\t\t\tz._inplace_transform();",
            "\t\t\tz.inplace_dot_product(f2);",
            "\t\t\tz._inplace_transform(true);",
            "\t\t\tf.resize(s << 1, T{0});",
            "\t\t\tf += z.inplace_clear_range(0, s);",
            "\t\t\tif(s << 1 < n) f._inverse_doubled_up(g, g2);",
            "\t\t}",
            "\t\tf.resize(n, T{0});",
            "\t\treturn f;",
            "\t}",
            "\t// O(n * log(n))",
            "\tpower_series_base &inplace_exp(int n){",
            "\t\treturn *this = this->exp(n);",
            "\t}",
            "\t// O(n * log(n))",
            "\ttemplate<class U, typename enable_if<IS_INTEGRAL(U)>::type* = nullptr>",
            "\tpower_series_base &inplace_power(U e, int n){",
            "\t\tassert(n >= 0);",
            "\t\tdata.resize(n, T{0});",
            "\t\tif(n == 0) return *this;",
            "\t\tif(e == 0){",
            "\t\t\tfill(data.begin(), data.end(), T{0});",
            "\t\t\tdata[0] = T{1};",
            "\t\t\treturn *this;",
            "\t\t}",
            "\t\tif(e < 0) return inplace_inverse(n).inplace_power(-e, n);",
            "\t\tif(all_of(data.begin(), data.end(), [&](auto x){ return x == T{0}; })) return *this;",
            "\t\tint pivot = find_if(data.begin(), data.end(), [&](auto x){ return x; }) - data.begin();",
            "\t\tif(pivot && e >= (n + pivot - 1) / pivot){",
            "\t\t\tfill(data.begin(), data.end(), T{0});",
            "\t\t\treturn *this;",
            "\t\t}",
            "\t\tdata.erase(data.begin(), data.begin() + pivot);",
            "\t\tn -= pivot * e;",
            "\t\tT pivot_c = T{1}, base = data[0];",
            "\t\tfor(auto x = e; x; x >>= 1, base *= base) if(x & 1) pivot_c *= base;",
            "\t\t((*this /= data[0]).inplace_log(n) *= e).inplace_exp(n);",
            "\t\tdata.insert(data.begin(), pivot * e, T{0});",
            "\t\treturn *this *= pivot_c;",
            "\t}",
            "\t// O(n * log(n))",
            "\ttemplate<class U, typename enable_if<IS_INTEGRAL(U)>::type* = nullptr>",
            "\tpower_series_base power(U e, int n) const{",
            "\t\treturn power_series_base(*this).inplace_power(e, n);",
            "\t}",
            "\t// O(n * log(n) * log(e))",
            "\ttemplate<class U, typename enable_if<IS_INTEGRAL(U)>::type* = nullptr>",
            "\tpower_series_base &inplace_power_mod(U e, power_series_base mod){",
            "\t\tmod.inplace_reduce();",
            "\t\tassert(mod);",
            "\t\tif((int)mod.size() == 1){",
            "\t\t\tdata.clear();",
            "\t\t\treturn *this;",
            "\t\t}",
            "\t\tif(e == 0){",
            "\t\t\tdata = {T{1}};",
            "\t\t\treturn *this;",
            "\t\t}",
            "\t\tif(e < 0) return inplace_inverse((int)mod.size()).inplace_power_mod(-e, mod);",
            "\t\tif(!*this) return *this;",
            "\t\tpower_series_base res{1};",
            "\t\tfor(; e; e >>= 1, *this = *this * *this % mod) if(e & 1) res = res * *this % mod;",
            "\t\treturn *this = res;",
            "\t}",
            "\t// O(n * log(n) * log(e))",
            "\ttemplate<class U, typename enable_if<IS_INTEGRAL(U)>::type* = nullptr>",
            "\tpower_series_base power_mod(U e, const power_series_base &mod) const{",
            "\t\treturn power_series_base(*this).inplace_power_mod(e, mod);",
            "\t}",
            "\t// Suppose there are data[i] distinct objects with weight i.",
            "\t// Returns a power series where i-th coefficient represents # of ways to select a set of objects with sum of weight i.",
            "\t// O(n * log(n))",
            "\tpower_series_base &inplace_set(int n){",
            "\t\tassert(!data.empty() && data[0] == T{0});",
            "\t\t_precalc_inverse(n);",
            "\t\tdata.resize(n);",
            "\t\tfor(auto i = n - 1; i >= 1; -- i) for(auto j = 2 * i; j < n; j += i) data[j] += data[i];",
            "\t\tfor(auto i = 1; i < n; ++ i) (data[i] *= _inv[i]) *= (i & 1 ? 1 : -1);",
            "\t\treturn inplace_exp(n);",
            "\t}",
            "\tpower_series_base set(int n) const{",
            "\t\treturn power_series_base(*this).inplace_set(n);",
            "\t}",
            "\t// Suppose there are data[i] distinct objects with weight i.",
            "\t// Returns a power series where i-th coefficient represents # of ways to select a multiset of objects with sum of weight i.",
            "\t// O(n * log(n))",
            "\tpower_series_base &inplace_multiset(int n){",
            "\t\tassert(!data.empty() && data[0] == T{0});",
            "\t\t_precalc_inverse(n);",
            "\t\tdata.resize(n);",
            "\t\tfor(auto i = n - 1; i >= 1; -- i) for(auto j = 2 * i; j < n; j += i) data[j] += data[i] * _inv[j / i];",
            "\t\treturn inplace_exp(n);",
            "\t}",
            "\tpower_series_base multiset(int n) const{",
            "\t\treturn power_series_base(*this).inplace_multiset(n);",
            "\t}",
            "\tstatic power_series_base multiply_all(const vector<power_series_base> &a){",
            "\t\tif(a.empty()) return {1};",
            "\t\tauto solve = [&](auto self, int l, int r)->power_series_base{",
            "\t\t\tif(r - l == 1) return a[l];",
            "\t\t\tint m = l + (r - l >> 1);",
            "\t\t\treturn self(self, l, m) * self(self, m, r);",
            "\t\t};",
            "\t\treturn solve(solve, 0, (int)a.size());",
            "\t}",
            "\tfriend power_series_base gcd(power_series_base p, power_series_base q){",
            "\t\tp.inplace_reduce(), q.inplace_reduce();",
            "\t\twhile(q) p = exchange(q, (p % q).reduce());",
            "\t\treturn p;",
            "\t}",
            "\tfriend power_series_base lcm(power_series_base p, power_series_base q){",
            "\t\treturn p / gcd(p, q) * q;",
            "\t}",
            "#undef IS_INTEGRAL",
            "#undef data",
            "};",
            "template<class T, class FFT>",
            "vector<T> power_series_base<T, FFT>::_inv{T{1}};",
            "",
            "// Requires modular and number_theoric_transform",
            "using power_series = power_series_base<modular, ntt>;"
        ],
        "description": "tranxuanbach"
    }
}