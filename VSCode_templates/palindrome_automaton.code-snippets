{
    "tranxuanbach": {
        "prefix": "palindrome_automaton",
        "body": [
            "// Each node represents a unique palindromic substring plus 0 and 1 node representing empty even and odd string",
            "// Adjacency_Type: array<int, X> or map<Char_Type, int> where X is the size of the alphabet",
            "template<class Char_Type, class Adjacency_Type>",
            "struct palindrome_automaton{",
            "\t// Begin States",
            "\t// len: length of the palindrome",
            "\t// link: suffix link",
            "\t// serial_link[u]: longest proper suffix v with len[u] - len[link[u]] != len[v] - len[link[v]]",
            "\t// depth: # of suffix links till root",
            "\t// occurence: # of occurences of the palindrome as a longest proper palindromic suffix of a prefix",
            "\tvector<int> len{0, -1}, link{1, 0}, serial_link{0, 0}, depth{0, 0}, occurence{1, 0};",
            "\tvector<Adjacency_Type> next = vector<Adjacency_Type>(2);",
            "\t// End States",
            "\tvector<Char_Type> s{-1};",
            "\tvector<int> last{0};",
            "\tlong long palindromic_substring_count = 0;",
            "\tint new_state(int l, int u){",
            "\t\tlen.push_back(l);",
            "\t\tlink.push_back(u);",
            "\t\tserial_link.push_back(l - len[u] == len[u] - len[link[u]] ? serial_link[u] : u);",
            "\t\tdepth.push_back(depth[u] + 1);",
            "\t\tnext.emplace_back();",
            "\t\toccurence.push_back(0);",
            "\t\treturn (int)len.size() - 1;",
            "\t}",
            "\tvoid extend(const vector<Char_Type> &s){",
            "\t\tfor(auto c: s) extend(c);",
            "\t}",
            "\tvoid extend(Char_Type c){",
            "\t\ts.push_back(c);",
            "\t\tint l = last.back();",
            "\t\twhile(s[(int)s.size() - len[l] - 2] != s.back()) l = link[l];",
            "\t\tif(!next[l][c]){",
            "\t\t\tint u = link[l];",
            "\t\t\twhile(s[(int)s.size() - len[u] - 2] != s.back()) u = link[u];",
            "\t\t\tint v = new_state(len[l] + 2, next[u][c]);",
            "\t\t\tnext[l][c] = v; // Separated for UB in C++14 or below",
            "\t\t}",
            "\t\tlast.push_back(next[l][c]);",
            "\t\tpalindromic_substring_count += depth[last.back()];",
            "\t\t++ occurence[last.back()];",
            "\t}",
            "\tint size() const{ // # of states",
            "\t\treturn (int)len.size();",
            "\t}",
            "\t// count: # of occurences of the palindrome",
            "\tvector<int> count;",
            "\tvector<vector<int>> inv_link;",
            "\tvoid init_count(){",
            "\t\tcount = occurence, inv_link.assign(size(), {});",
            "\t\tfor(auto u = 2; u < (int)size(); ++ u) inv_link[link[u]].push_back(u);",
            "\t\tauto dfs = [&](auto self, int u)->void{",
            "\t\t\tfor(auto v: inv_link[u]) self(self, v), count[u] += count[v];",
            "\t\t};",
            "\t\tdfs(dfs, 0);",
            "\t}",
            "};"
        ],
        "description": "tranxuanbach"
    }
}