{
    "tranxuanbach": {
        "prefix": "tree_hasher",
        "body": [
            "// T must be a modular type",
            "// Requires graph",
            "template<class T>",
            "struct tree_hasher{",
            "\tmt19937 rng;",
            "\tvector<int> order;",
            "\tvector<T> base, hash;",
            "\ttree_hasher(): rng(chrono::high_resolution_clock::now().time_since_epoch().count()){}",
            "\tint attempt = 0;",
            "\tvector<int> was;",
            "\ttemplate<class U>",
            "\tvoid run(const graph<U> &g, const vector<int> &src = {0}, bool clear_order = true){",
            "\t\tint n = g.n;",
            "\t\t++ attempt;",
            "\t\tif(clear_order) order.clear();",
            "\t\twhile(base.size() < n) base.push_back(rng());",
            "\t\thash.resize(n);",
            "\t\twas.resize(n);",
            "\t\tauto dfs = [&](auto self, int u, int p)->int{",
            "\t\t\torder.push_back(u);",
            "\t\t\twas[u] = attempt;",
            "\t\t\thash[u] = 1;",
            "\t\t\tint d = 0;",
            "\t\t\tfor(auto id: g.adj[u]){",
            "\t\t\t\tif(g.ignore && g.ignore(id)) continue;",
            "\t\t\t\tint v = g(u, id);",
            "\t\t\t\tif(v == p) continue;",
            "\t\t\t\td = max(d, self(self, v, u) + 1);",
            "\t\t\t}",
            "\t\t\tfor(auto id: g.adj[u]){",
            "\t\t\t\tif(g.ignore && g.ignore(id)) continue;",
            "\t\t\t\tint v = g(u, id);",
            "\t\t\t\tif(v == p) continue;",
            "\t\t\t\thash[u] *= base[d] + hash[v];",
            "\t\t\t}",
            "\t\t\treturn d;",
            "\t\t};",
            "\t\tfor(auto s: src) if(was[s] != attempt) dfs(dfs, s, -1);",
            "\t}",
            "};"
        ],
        "description": "tranxuanbach"
    }
}