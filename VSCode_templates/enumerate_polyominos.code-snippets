{
    "tranxuanbach": {
        "prefix": "polyominos",
        "body": [
            "// Jeoron ORZ",
            "// act_while(polyomino_grid): process polyomino_grid represented by '.'(empty cell) and 'o'(filled cell), then indicate whether to exit to search or not",
            "template<bool FILTER_ISOMETRY = false>",
            "void enumerate_polyominos(int n, int th_h, int th_w, auto act_while){",
            "\tassert(n >= 1 && th_h >= 1 && th_w >= 1);",
            "\tif(n > 1LL * th_h * th_w) return;",
            "\tstatic const vector<pair<int, int>> dr4{{1, 0}, {0, 1}, {-1, 0}, {0, -1}};",
            "\tvector state(n, vector<int>(2 * n - 1));",
            "\tvector<int> min_col(n + 1, 2 * n - 1), max_col(n + 1, -1);",
            "\tvector<array<int, 2>> c{{0, n - 1}};",
            "\tauto recurse = [&](auto self, int i, int step)->bool{",
            "\t\tstate[c[i][0]][c[i][1]] = -1;",
            "\t\tint l = min_col[step + 1] = min(min_col[step], c[i][1]);",
            "\t\tint r = max_col[step + 1] = max(max_col[step], c[i][1] + 1);",
            "\t\tif(r - l > th_w){",
            "\t\t\tstate[c[i][0]][c[i][1]] = 1;",
            "\t\t\treturn true;",
            "\t\t}",
            "\t\tif(step == n - 1){",
            "\t\t\tvector<string> res;",
            "\t\t\tfor(auto i = 0; i < n; ++ i){",
            "\t\t\t\tstring layer(r - l, '.');",
            "\t\t\t\tfor(auto j = l; j < r; ++ j) if(!~state[i][j]) layer[j - l] = '#';",
            "\t\t\t\tif(layer == string(r - l, '.')) break;",
            "\t\t\t\tres.push_back(layer);",
            "\t\t\t}",
            "\t\t\tif constexpr(FILTER_ISOMETRY){",
            "\t\t\t\tint h = n, w = r - l;",
            "\t\t\t\twhile(none_of(state[h - 1].begin(), state[h - 1].end(), [&](int x){ return !~x; })) -- h;",
            "\t\t\t\tint opth = -1, optw = -1;",
            "\t\t\t\tstatic vector<string> opt;",
            "\t\t\t\topt.assign(n, string(n, '.'));",
            "\t\t\t\tfor(auto flip = 0; flip < 2; ++ flip){",
            "\t\t\t\t\tstatic vector<string> temp;",
            "\t\t\t\t\tfor(auto rot = 0; rot < 4; ++ rot){",
            "\t\t\t\t\t\tif(h <= th_h && w <= th_w){",
            "\t\t\t\t\t\t\ttemp = res;",
            "\t\t\t\t\t\t\ttemp.resize(n);",
            "\t\t\t\t\t\t\tfor(auto &s: temp) s.resize(n, '.');",
            "\t\t\t\t\t\t\tif(opt > temp){",
            "\t\t\t\t\t\t\t\topth = h, optw = w;",
            "\t\t\t\t\t\t\t\topt = temp;",
            "\t\t\t\t\t\t\t}",
            "\t\t\t\t\t\t}",
            "\t\t\t\t\t\ttemp.assign(w, string(h, '.'));",
            "\t\t\t\t\t\tfor(auto x = 0; x < h; ++ x) for(auto y = 0; y < w; ++ y) temp[w - 1 - y][x] = res[x][y];",
            "\t\t\t\t\t\tswap(h, w);",
            "\t\t\t\t\t\tswap(res, temp);",
            "\t\t\t\t\t}",
            "\t\t\t\t\ttemp.assign(w, string(h, '.'));",
            "\t\t\t\t\tfor(auto x = 0; x < h; ++ x) for(auto y = 0; y < w; ++ y) temp[y][x] = res[x][y];",
            "\t\t\t\t\tswap(h, w);",
            "\t\t\t\t\tswap(res, temp);",
            "\t\t\t\t}",
            "\t\t\t\topt.resize(opth);",
            "\t\t\t\tfor(auto &s: opt) s.resize(optw);",
            "\t\t\t\tif(opt != res){",
            "\t\t\t\t\tstate[c[i][0]][c[i][1]] = 1;",
            "\t\t\t\t\treturn true;",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t\tif(!act_while(res)) return false;",
            "\t\t\tstate[c[i][0]][c[i][1]] = 1;",
            "\t\t\treturn true;",
            "\t\t}",
            "\t\tint size = (int)c.size();",
            "\t\tfor(auto [dx, dy]: dr4){",
            "\t\t\tint nx = c[i][0] + dx, ny = c[i][1] + dy;",
            "\t\t\tif(nx < 0 || nx == 0 && ny < n - 1 || state[nx][ny]) continue;",
            "\t\t\tstate[nx][ny] = 1;",
            "\t\t\tc.push_back({nx, ny});",
            "\t\t}",
            "\t\tfor(auto j = i + 1; j < (int)c.size(); ++ j) self(self, j, step + 1);",
            "\t\twhile((int)c.size() > size){",
            "\t\t\tauto [x, y] = c.back();",
            "\t\t\tc.pop_back();",
            "\t\t\tstate[x][y] = 0;",
            "\t\t}",
            "\t\tstate[c[i][0]][c[i][1]] = 1;",
            "\t\treturn true;",
            "\t};",
            "\trecurse(recurse, 0, 0);",
            "}",
            "// act_while(polyomino_grid): process polyomino_grid represented by '.'(empty cell) and 'o'(filled cell), then indicate whether to exit to search or not",
            "// Enumerate all polynomios with n blocks while act_while() is true",
            "template<bool FILTER_ISOMETRY = false>",
            "void enumerate_polyominos(int n, auto act_while){",
            "\tconst int inf = numeric_limits<int>::max();",
            "\tenumerate_polyominos<FILTER_ISOMETRY>(n, inf, inf, act_while);",
            "}"
        ],
        "description": "tranxuanbach"
    }
}