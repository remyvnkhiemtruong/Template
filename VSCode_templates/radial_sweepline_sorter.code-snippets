{
    "tranxuanbach": {
        "prefix": "radial_sweepline_sorter",
        "body": [
            "struct radial_sweepline_sorter{",
            "\tvector<int> order;",
            "\tvector<int> pos;",
            "\tvector<int> was;",
            "\tradial_sweepline_sorter(){ }",
            "\tint it = -1;",
            "\t// Rotate the directed line in counterclockwise order by pi, starting from dir",
            "\t// Whenever linear order of points defined by dot product of each points with dir changes by i and j exchanging positions, process(i, j) gets called",
            "\t// O(n^2 * log(n))",
            "\t// Requires point",
            "\ttemplate<class T>",
            "\tvoid run(const point<T> &o, const vector<point<T>> &a, const point<T> &dir, auto process){",
            "\t\tassert(dir != point<T>{});",
            "\t\tint n = (int)a.size();",
            "\t\torder.resize(n);",
            "\t\tpos.resize(n);",
            "\t\twas.resize(n, -2);",
            "\t\tiota(order.begin(), order.end(), 0);",
            "\t\tsort(order.begin(), order.end(), [&](int i, int j){",
            "\t\t\tconst point<T> &p = a[i], &q = a[j];",
            "\t\t\treturn (p - o) * dir != (q - o) * dir ? (p - o) * dir < (q - o) * dir : (p - o ^ dir) < (q - o ^ dir);",
            "\t\t});",
            "\t\tfor(auto t = 0; t < n; ++ t) pos[order[t]] = t;",
            "\t\tauto compare = [&](const auto &x, const auto &y)->bool{",
            "\t\t\treturn clockwise(o, get<0>(x), get<0>(y));",
            "\t\t};",
            "\t\tpriority_queue<tuple<point<T>, int, int>, vector<tuple<point<T>, int, int>>, decltype(compare)> pq{compare};",
            "\t\t++ it;",
            "\t\tfill(was.begin(), was.end(), it);",
            "\t\tfor(auto t = 0; t < n - 1; ++ t){",
            "\t\t\tauto d = (a[order[t + 1]] - a[order[t]]).perp();",
            "\t\t\tassert(d != point<T>{});",
            "\t\t\tif((dir ^ d) > 0 || (dir ^ d) == 0 && dir * d > 0) pq.push({d, t, it});",
            "\t\t}",
            "\t\twhile(!pq.empty()){",
            "\t\t\tauto [d, t, timer] = pq.top();",
            "\t\t\tpq.pop();",
            "\t\t\tif(was[t] > timer || was[t + 1] > timer) continue;",
            "\t\t\tprocess(order[t], order[t + 1]);",
            "\t\t\tswap(order[t], order[t + 1]);",
            "\t\t\tint i = order[t], j = order[t + 1];",
            "\t\t\tswap(pos[i], pos[j]);",
            "\t\t\twas[t] = was[t + 1] = ++ it;",
            "\t\t\tif(t > 0){",
            "\t\t\t\tauto e = (a[order[t]] - a[order[t - 1]]).perp();",
            "\t\t\t\tassert(e != point<T>{});",
            "\t\t\t\tif((dir ^ e) > 0 || (dir ^ e) == 0 && dir * e > 0) pq.push({e, t - 1, it});",
            "\t\t\t}",
            "\t\t\tif(t + 2 < n){",
            "\t\t\t\tauto e = (a[order[t + 2]] - a[order[t + 1]]).perp();",
            "\t\t\t\tassert(e != point<T>{});",
            "\t\t\t\tif((dir ^ e) > 0 || (dir ^ e) == 0 && dir * e > 0) pq.push({e, t + 1, it});",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "\t// Same as above, but the memory usage is linear with the cost of higher constant factor",
            "\ttemplate<class T>",
            "\tvoid run_linear_memory(const point<T> &o, const vector<point<T>> &a, const point<T> &dir, auto process){",
            "\t\tassert(dir != point<T>{});",
            "\t\tint n = (int)a.size();",
            "\t\torder.resize(n);",
            "\t\tpos.resize(n);",
            "\t\tiota(order.begin(), order.end(), 0);",
            "\t\tsort(order.begin(), order.end(), [&](int i, int j){",
            "\t\t\tconst point<T> &p = a[i], &q = a[j];",
            "\t\t\treturn (p - o) * dir != (q - o) * dir ? (p - o) * dir < (q - o) * dir : (p - o ^ dir) < (q - o ^ dir);",
            "\t\t});",
            "\t\tfor(auto t = 0; t < n; ++ t) pos[order[t]] = t;",
            "\t\tauto compare = [&](const auto &x, const auto &y)->bool{",
            "\t\t\treturn !colinear(o, x.first, y.first) ? counterclockwise(o, x.first, y.first) : x.second < y.second;",
            "\t\t};",
            "\t\tset<pair<point<T>, int>, decltype(compare)> s{compare};",
            "\t\tfor(auto t = 0; t < n - 1; ++ t){",
            "\t\t\tauto d = (a[order[t + 1]] - a[order[t]]).perp();",
            "\t\t\tassert(d != point<T>{});",
            "\t\t\tif((dir ^ d) > 0 || (dir ^ d) == 0 && dir * d > 0) s.insert({d, t});",
            "\t\t}",
            "\t\twhile(!s.empty()){",
            "\t\t\tauto [d, t] = *s.begin();",
            "\t\t\ts.erase(s.begin());",
            "\t\t\tprocess(order[t], order[t + 1]);",
            "\t\t\tif(t > 0){",
            "\t\t\t\tauto e = (a[order[t]] - a[order[t - 1]]).perp();",
            "\t\t\t\tassert(e != point<T>{});",
            "\t\t\t\tif((dir ^ e) > 0 || (dir ^ e) == 0 && dir * e > 0) s.erase({e, t - 1});",
            "\t\t\t}",
            "\t\t\tif(t + 2 < n){",
            "\t\t\t\tauto e = (a[order[t + 2]] - a[order[t + 1]]).perp();",
            "\t\t\t\tassert(e != point<T>{});",
            "\t\t\t\tif((dir ^ e) > 0 || (dir ^ e) == 0 && dir * e > 0) s.erase({e, t + 1});",
            "\t\t\t}",
            "\t\t\tswap(order[t], order[t + 1]);",
            "\t\t\tint i = order[t], j = order[t + 1];",
            "\t\t\tswap(pos[i], pos[j]);",
            "\t\t\tif(t > 0){",
            "\t\t\t\tauto e = (a[order[t]] - a[order[t - 1]]).perp();",
            "\t\t\t\tassert(e != point<T>{});",
            "\t\t\t\tif((dir ^ e) > 0 || (dir ^ e) == 0 && dir * e > 0) s.insert({e, t - 1});",
            "\t\t\t}",
            "\t\t\tif(t + 2 < n){",
            "\t\t\t\tauto e = (a[order[t + 2]] - a[order[t + 1]]).perp();",
            "\t\t\t\tassert(e != point<T>{});",
            "\t\t\t\tif((dir ^ e) > 0 || (dir ^ e) == 0 && dir * e > 0) s.insert({e, t + 1});",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "};"
        ],
        "description": "tranxuanbach"
    }
}