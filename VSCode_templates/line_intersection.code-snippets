{
    "tranxuanbach": {
        "prefix": "line_intersection",
        "body": [
            "// endpoint type: 0(ray), 1(closed end), 2(open end)",
            "// type_mask % 3 for the left endpoint type of L",
            "// type_mask / 3 % 3 for the right endpoint type of L",
            "// type_mask / 9 % 3 for the left endpoint type of R",
            "// type_mask / 27 for the right endpoint type of R",
            "// Requires point and line",
            "#define CHECK(type, x, y) (type == 0 || x < y || x == y && type == 1)",
            "// Assumes parallel lines do not intersect",
            "template<class T>",
            "optional<pointd> intersect_no_parallel_overlap(int type_mask, const line<T> &L, const line<T> &M){",
            "\tassert(0 <= type_mask && type_mask < 81);",
            "\tT s = L.d ^ M.d;",
            "\tif(s == 0) return {};",
            "\tT ls = M.p - L.p ^ M.d, rs = M.p - L.p ^ L.d;",
            "\tif(s < 0) s = -s, ls = -ls, rs = -rs;",
            "\tif(CHECK(type_mask % 3, 0, ls) && CHECK(type_mask / 3 % 3, ls, s) && CHECK(type_mask / 9 % 3, 0, rs) && CHECK(type_mask / 27, rs, s)) return pointd(L.p) + 1.0 * ls / s * pointd(L.d);",
            "\telse return {};",
            "}",
            "// Assumes parallel lines do not intersect",
            "template<class T>",
            "optional<pointld> intersect_no_parallel_overlapl(int type_mask, const line<T> &L, const line<T> &M){",
            "\tassert(0 <= type_mask && type_mask < 81);",
            "\tT s = L.d ^ M.d;",
            "\tif(s == 0) return {};",
            "\tT ls = M.p - L.p ^ M.d, rs = M.p - L.p ^ L.d;",
            "\tif(s < 0) s = -s, ls = -ls, rs = -rs;",
            "\tif(CHECK(type_mask % 3, 0, ls) && CHECK(type_mask / 3 % 3, ls, s) && CHECK(type_mask / 9 % 3, 0, rs) && CHECK(type_mask / 27, rs, s)) return pointld(L.p) + 1.0L * ls / s * pointld(L.d);",
            "\telse return {};",
            "}",
            "#undef CHECK",
            "// Assumes parallel lines do not intersect",
            "template<class T>",
            "optional<pointd> intersect_closed_segments_no_parallel_overlap(const line<T> &L, const line<T> &M){",
            "\treturn intersect_no_parallel_overlap<T>(1 + 3 * 1 + 9 * 1 + 27 * 1, L, M);",
            "}",
            "// Assumes parallel lines do not intersect",
            "template<class T>",
            "optional<pointld> intersect_closed_segments_no_parallel_overlapl(const line<T> &L, const line<T> &M){",
            "\treturn intersect_no_parallel_overlapl<T>(1 + 3 * 1 + 9 * 1 + 27 * 1, L, M);",
            "}",
            "// Assumes parallel lines do not intersect",
            "template<class T>",
            "optional<pointd> intersect_open_segments_no_parallel_overlap(const line<T> &L, const line<T> &M){",
            "\treturn intersect_no_parallel_overlap<T>(2 + 3 * 2 + 9 * 2 + 27 * 2, L, M);",
            "}",
            "// Assumes parallel lines do not intersect",
            "template<class T>",
            "optional<pointld> intersect_open_segments_no_parallel_overlapl(const line<T> &L, const line<T> &M){",
            "\treturn intersect_no_parallel_overlapl<T>(2 + 3 * 2 + 9 * 2 + 27 * 2, L, M);",
            "}",
            "// Assumes nothing",
            "template<class T>",
            "optional<pair<pointd, pointd>> intersect_closed_segments(const line<T> &L, const line<T> &M){",
            "\tauto s = L.d ^ M.d, ls = M.p - L.p ^ M.d;",
            "\tif(!s){",
            "\t\tif(ls) return {};",
            "\t\tauto Lp = L.p, Lq = L.q(), Mp = M.p, Mq = M.q();",
            "\t\tif(Lp > Lq) swap(Lp, Lq);",
            "\t\tif(Mp > Mq) swap(Mp, Mq);",
            "\t\tpoint<T> p = max(Lp, Mp), q = min(Lq, Mq);",
            "\t\tif(p <= q) return pair<pointd, pointd>{p, q};",
            "\t\treturn {};",
            "\t}",
            "\tauto rs = M.p - L.p ^ L.d;",
            "\tif(s < 0) s = -s, ls = -ls, rs = -rs;",
            "\tif(0 <= ls && ls <= s && 0 <= rs && rs <= s){",
            "\t\tauto p = pointd(L.p) + 1.0 * ls / s * pointd(L.d);",
            "\t\treturn pair<pointd, pointd>{p, p};",
            "\t}",
            "\telse return {};",
            "}",
            "// Assumes nothing",
            "template<class T>",
            "optional<pair<pointld, pointld>> intersect_closed_segmentsl(const line<T> &L, const line<T> &M){",
            "\tauto s = L.d ^ M.d, ls = M.p - L.p ^ M.d;",
            "\tif(!s){",
            "\t\tif(ls) return {};",
            "\t\tauto Lp = L.p, Lq = L.q(), Mp = M.p, Mq = M.q();",
            "\t\tif(Lp > Lq) swap(Lp, Lq);",
            "\t\tif(Mp > Mq) swap(Mp, Mq);",
            "\t\tpoint<T> p = max(Lp, Mp), q = min(Lq, Mq);",
            "\t\tif(p <= q) return pair<pointld, pointld>{p, q};",
            "\t\treturn {};",
            "\t}",
            "\tauto rs = M.p - L.p ^ L.d;",
            "\tif(s < 0) s = -s, ls = -ls, rs = -rs;",
            "\tif(0 <= ls && ls <= s && 0 <= rs && rs <= s){",
            "\t\tauto p = pointld(L.p) + 1.0L * ls / s * pointld(L.d);",
            "\t\treturn pair<pointld, pointld>{p, p};",
            "\t}",
            "\telse return {};",
            "}",
            "// Assumes nothing",
            "template<class T>",
            "optional<pair<pointd, pointd>> intersect_open_segments(const line<T> &L, const line<T> &M){",
            "\tauto s = L.d ^ M.d, ls = M.p - L.p ^ M.d;",
            "\tif(!s){",
            "\t\tif(ls) return {};",
            "\t\tauto Lp = L.p, Lq = L.q(), Mp = M.p, Mq = M.q();",
            "\t\tif(Lp > Lq) swap(Lp, Lq);",
            "\t\tif(Mp > Mq) swap(Mp, Mq);",
            "\t\tpoint<T> p = max(Lp, Mp), q = min(Lq, Mq);",
            "\t\tif(p < q) return pair<pointd, pointd>{p, q};",
            "\t\treturn {};",
            "\t}",
            "\tauto rs = (M.p - L.p) ^ L.d;",
            "\tif(s < 0) s = -s, ls = -ls, rs = -rs;",
            "\tif(0 < ls && ls < s && 0 < rs && rs < s){",
            "\t\tauto p = pointd(L.p) + 1.0 * ls / s * pointd(L.d);",
            "\t\treturn pair<pointd, pointd>{p, p};",
            "\t}",
            "\telse return {};",
            "}",
            "// Assumes nothing",
            "template<class T>",
            "optional<pair<pointld, pointld>> intersect_open_segmentsl(const line<T> &L, const line<T> &M){",
            "\tauto s = L.d ^ M.d, ls = M.p - L.p ^ M.d;",
            "\tif(!s){",
            "\t\tif(ls) return {};",
            "\t\tauto Lp = L.p, Lq = L.q(), Mp = M.p, Mq = M.q();",
            "\t\tif(Lp > Lq) swap(Lp, Lq);",
            "\t\tif(Mp > Mq) swap(Mp, Mq);",
            "\t\tpoint<T> p = max(Lp, Mp), q = min(Lq, Mq);",
            "\t\tif(p < q) return pair<pointld, pointld>{p, q};",
            "\t\treturn {};",
            "\t}",
            "\tauto rs = (M.p - L.p) ^ L.d;",
            "\tif(s < 0) s = -s, ls = -ls, rs = -rs;",
            "\tif(0 < ls && ls < s && 0 < rs && rs < s){",
            "\t\tauto p = pointld(L.p) + 1.0L * ls / s * pointld(L.d);",
            "\t\treturn pair<pointld, pointld>{p, p};",
            "\t}",
            "\telse return {};",
            "}"
        ],
        "description": "tranxuanbach"
    }
}