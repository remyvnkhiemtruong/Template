{
    "tranxuanbach": {
        "prefix": "disjoint_set",
        "body": [
            "template<bool Enable_small_to_large = true>",
            "struct disjoint_set{",
            "\tint n, _group_count;",
            "\tvector<int> p;",
            "\tvector<list<int>> group;",
            "\tdisjoint_set(){ }",
            "\tdisjoint_set(int n): n(n), _group_count(n), p(n, -1), group(n){ assert(n >= 0);",
            "\t\tfor(auto i = 0; i < n; ++ i) group[i] = {i};",
            "\t}",
            "\tint make_set(){",
            "\t\tp.push_back(-1);",
            "\t\tgroup.push_back(list<int>{n});",
            "\t\t++ _group_count;",
            "\t\treturn n ++;",
            "\t}",
            "\tint root(int u){",
            "\t\treturn p[u] < 0 ? u : p[u] = root(p[u]);",
            "\t}",
            "\tbool share(int a, int b){",
            "\t\treturn root(a) == root(b);",
            "\t}",
            "\tint size(int u){",
            "\t\treturn -p[root(u)];",
            "\t}",
            "\tbool merge(int u, int v){",
            "\t\tu = root(u), v = root(v);",
            "\t\tif(u == v) return false;",
            "\t\t-- _group_count;",
            "\t\tif constexpr(Enable_small_to_large) if(p[u] > p[v]) swap(u, v);",
            "\t\tp[u] += p[v], p[v] = u;",
            "\t\tgroup[u].splice(group[u].end(), group[v]);",
            "\t\treturn true;",
            "\t}",
            "\tbool merge(int u, int v, auto act){",
            "\t\tu = root(u), v = root(v);",
            "\t\tif(u == v) return false;",
            "\t\t-- _group_count;",
            "\t\tbool swapped = false;",
            "\t\tif constexpr(Enable_small_to_large) if(p[u] > p[v]) swap(u, v), swapped = true;",
            "\t\tact(u, v, swapped);",
            "\t\tp[u] += p[v], p[v] = u;",
            "\t\tgroup[u].splice(group[u].end(), group[v]);",
            "\t\treturn true;",
            "\t}",
            "\tint group_count() const{",
            "\t\treturn _group_count;",
            "\t}",
            "\tconst list<int> &group_of(int u){",
            "\t\treturn group[root(u)];",
            "\t}",
            "\tvector<vector<int>> group_up(){",
            "\t\tvector<vector<int>> g(n);",
            "\t\tfor(auto i = 0; i < n; ++ i) g[root(i)].push_back(i);",
            "\t\tg.erase(remove_if(g.begin(), g.end(), [&](auto &s){ return s.empty(); }), g.end());",
            "\t\treturn g;",
            "\t}",
            "\tvoid clear(){",
            "\t\t_group_count = n;",
            "\t\tfill(p.begin(), p.end(), -1);",
            "\t\tfor(auto i = 0; i < n; ++ i) group[i] = {i};",
            "\t}",
            "\tfriend ostream &operator<<(ostream &out, disjoint_set dsu){",
            "\t\tauto gs = dsu.group_up();",
            "\t\tout << \"{\";",
            "\t\tif(!gs.empty()) for(auto i = 0; i < (int)gs.size(); ++ i){",
            "\t\t\tout << \"{\";",
            "\t\t\tfor(auto j = 0; j < (int)gs[i].size(); ++ j){",
            "\t\t\t\tout << gs[i][j];",
            "\t\t\t\tif(j + 1 < (int)gs[i].size()) out << \", \";",
            "\t\t\t}",
            "\t\t\tout << \"}\";",
            "\t\t\tif(i + 1 < (int)gs.size()) out << \", \";",
            "\t\t}",
            "\t\treturn out << \"}\";",
            "\t}",
            "};"
        ],
        "description": "tranxuanbach"
    }
}