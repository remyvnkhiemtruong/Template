{
    "tranxuanbach": {
        "prefix": "fastio",
        "body": [
            "struct IOPre{",
            "\tstatic constexpr int TEN = 10, SZ = TEN * TEN * TEN * TEN;",
            "\tarray<char, 4 * SZ> num;",
            "\tconstexpr IOPre(): num{}{",
            "\t\tfor(auto i = 0; i < SZ; ++ i){",
            "\t\t\tint n = i;",
            "\t\t\tfor(auto j = 3; j >= 0; -- j){",
            "\t\t\t\tnum[i * 4 + j] = static_cast<char>(n % TEN + '0');",
            "\t\t\t\tn /= TEN;",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "};",
            "struct IO{",
            "#if !HAVE_DECL_FREAD_UNLOCKED",
            "\t#define fread_unlocked fread",
            "#endif",
            "#if !HAVE_DECL_FWRITE_UNLOCKED",
            "\t#define fwrite_unlocked fwrite",
            "#endif",
            "\tstatic constexpr int SZ = 1 << 17, LEN = 32, TEN = 10, HUNDRED = TEN * TEN, THOUSAND = HUNDRED * TEN, TENTHOUSAND = THOUSAND * TEN, MAGIC_MULTIPLY = 205, MAGIC_SHIFT = 11, MASK = 15, TWELVE = 12, SIXTEEN = 16;",
            "\tstatic constexpr IOPre io_pre = {};",
            "\tarray<char, SZ> input_buffer, output_buffer;",
            "\tint input_ptr_left, input_ptr_right, output_ptr_right;",
            "\tIO() :input_buffer{}, output_buffer{}, input_ptr_left{}, input_ptr_right{}, output_ptr_right{} {}",
            "\tIO(const IO&) = delete;",
            "\tIO(IO&&) = delete;",
            "\tIO& operator=(const IO&) = delete;",
            "\tIO& operator=(IO&&) = delete;",
            "\t~IO(){ flush(); }",
            "\ttemplate<class T>",
            "\tstruct is_char{",
            "\t\tstatic constexpr bool value = is_same_v<T, char>;",
            "\t};",
            "\ttemplate<class T>",
            "\tstruct is_bool{",
            "\t\tstatic constexpr bool value = is_same_v<T, bool>;",
            "\t};",
            "\ttemplate<class T>",
            "\tstruct is_string{",
            "\t\tstatic constexpr bool value = is_same_v<T, string> || is_same_v<T, const char*> || is_same_v<T, char*> || is_same_v<decay_t<T>, char*>;",
            "\t};",
            "\t\ttemplate<class T, class D = void>",
            "\tstruct is_custom{",
            "\t\tstatic constexpr bool value = false;",
            "\t};",
            "\t\ttemplate<class T>",
            "\tstruct is_custom<T, void_t<typename T::internal_value_type>>{",
            "\t\tstatic constexpr bool value = true;",
            "\t};",
            "\t\ttemplate<class T>",
            "\tstruct is_default{",
            "\t\tstatic constexpr bool value = is_char<T>::value || is_bool<T>::value || is_string<T>::value || is_integral_v<T>;",
            "\t};",
            "\t\ttemplate<class T, class D = void>",
            "\tstruct is_iterable{",
            "\t\tstatic constexpr bool value = false;",
            "\t};",
            "\t\ttemplate <class T>",
            "\tstruct is_iterable<",
            "\t\tT, typename std::void_t<decltype(std::begin(std::declval<T>()))>>{",
            "\t\tstatic constexpr bool value = true;",
            "\t};",
            "\t\ttemplate<class T, class D = void, class E = void>",
            "\tstruct is_applyable{",
            "\t\tstatic constexpr bool value = false;",
            "\t};",
            "\t\ttemplate<class T>",
            "\tstruct is_applyable<T, void_t<typename tuple_size<T>::type>,",
            "\t\t\t\t\t\tvoid_t<decltype(get<0>(declval<T>()))>>{",
            "\t\tstatic constexpr bool value = true;",
            "\t};",
            "\t\ttemplate<class T>",
            "\tstatic constexpr bool needs_newline = (is_iterable<T>::value ||",
            "\t\t\t\t\t\t\t\t\t\t   is_applyable<T>::value) &&",
            "\t\t\t\t\t\t\t\t\t\t  (!is_default<T>::value);",
            "\t\t\t\t\t\t\t\t\t\t  \ttemplate<typename T, typename U>",
            "\tstruct any_needs_newline{",
            "\t\tstatic constexpr bool value = false;",
            "\t};",
            "\ttemplate<typename T>",
            "\tstruct any_needs_newline<T, index_sequence<>>{",
            "\t\tstatic constexpr bool value = false;",
            "\t};",
            "\ttemplate<typename T, size_t I, size_t... Is>",
            "\tstruct any_needs_newline<T, index_sequence<I, Is...>>{",
            "\t\tstatic constexpr bool value =",
            "\t\t\tneeds_newline<decltype(get<I>(declval<T>()))> ||",
            "\t\t\tany_needs_newline<T, index_sequence<Is...>>::value;",
            "\t};",
            "\tinline void load(){",
            "\t\tmemmove(begin(input_buffer), begin(input_buffer) + input_ptr_left, input_ptr_right - input_ptr_left);",
            "\t\tinput_ptr_right = input_ptr_right - input_ptr_left + static_cast<int>(fread_unlocked(begin(input_buffer) + input_ptr_right - input_ptr_left, 1, SZ - input_ptr_right + input_ptr_left, stdin));",
            "\t\tinput_ptr_left = 0;",
            "\t}",
            "\tinline void read_char(char &c){",
            "\t\tif(input_ptr_left + LEN > input_ptr_right) load();",
            "\t\tc = input_buffer[input_ptr_left ++];",
            "\t}",
            "\tinline void read_string(string &x){",
            "\t\tchar c;",
            "\t\twhile(read_char(c), c < '!') continue;",
            "\t\tx = c;",
            "\t\twhile(read_char(c), c >= '!') x += c;",
            "\t}",
            "\ttemplate<class T>",
            "\tinline enable_if_t<is_integral_v<T>, void> read_int(T &x){",
            "\t\tif(input_ptr_left + LEN > input_ptr_right) load();",
            "\t\tchar c = 0;",
            "\t\tdo c = input_buffer[input_ptr_left ++];",
            "\t\twhile(c < '-');",
            "\t\t[[maybe_unused]] bool minus = false;",
            "\t\tif constexpr(is_signed<T>::value == true)",
            "\t\t\tif(c == '-') minus = true, c = input_buffer[input_ptr_left ++];",
            "\t\tx = 0;",
            "\t\twhile(c >= '0')",
            "\t\t\tx = x * TEN + (c & MASK), c = input_buffer[input_ptr_left ++];",
            "\t\tif constexpr(is_signed<T>::value == true)",
            "\t\t\tif(minus) x = -x;",
            "\t}",
            "\tinline void skip_space(){",
            "\t\tif(input_ptr_left + LEN > input_ptr_right) load();",
            "\t\twhile(input_buffer[input_ptr_left] <= ' ') input_ptr_left ++;",
            "\t}",
            "\tinline void flush(){",
            "\t\tfwrite_unlocked(begin(output_buffer), 1, output_ptr_right, stdout);",
            "\t\toutput_ptr_right = 0;",
            "\t}",
            "\tinline void write_char(char c){",
            "\t\tif(output_ptr_right > SZ - LEN) flush();",
            "\t\toutput_buffer[output_ptr_right ++] = c;",
            "\t}",
            "\tinline void write_bool(bool b){",
            "\t\tif(output_ptr_right > SZ - LEN) flush();",
            "\t\toutput_buffer[output_ptr_right ++] = b ? '1' : '0';",
            "\t}",
            "\tinline void write_string(const string &s){",
            "\t\tfor(auto x : s) write_char(x);",
            "\t}",
            "\tinline void write_string(const char *s){",
            "\t\twhile(*s) write_char(*s ++);",
            "\t}",
            "\tinline void write_string(char* s){",
            "\t\twhile(*s) write_char(*s ++);",
            "\t}",
            "\ttemplate<typename T>",
            "\tinline enable_if_t<is_integral_v<T>, void> write_int(T x){",
            "\t\tif(output_ptr_right > SZ - LEN) flush();",
            "\t\tif(!x){",
            "\t\t\toutput_buffer[output_ptr_right ++] = '0';",
            "\t\t\treturn;",
            "\t\t}",
            "\t\tif constexpr(is_signed<T>::value) if(x < 0) output_buffer[output_ptr_right ++] = '-', x = -x;",
            "\t\tint i = TWELVE;",
            "\t\tarray<char, SIXTEEN> buf{};",
            "\t\twhile(x >= TENTHOUSAND){",
            "\t\t\tmemcpy(begin(buf) + i, begin(io_pre.num) + (x % TENTHOUSAND) * 4, 4);",
            "\t\t\tx /= TENTHOUSAND;",
            "\t\t\ti -= 4;",
            "\t\t}",
            "\t\tif(x < HUNDRED){",
            "\t\t\tif(x < TEN) output_buffer[output_ptr_right ++] = static_cast<char>('0' + x);",
            "\t\t\telse{",
            "\t\t\t\tuint32_t q =",
            "\t\t\t\t\t(static_cast<uint32_t>(x) * MAGIC_MULTIPLY) >>",
            "\t\t\t\t\tMAGIC_SHIFT;",
            "\t\t\t\tuint32_t r = static_cast<uint32_t>(x) - q * TEN;",
            "\t\t\t\toutput_buffer[output_ptr_right] = static_cast<char>('0' + q);",
            "\t\t\t\toutput_buffer[output_ptr_right + 1] =",
            "\t\t\t\t\tstatic_cast<char>('0' + r);",
            "\t\t\t\toutput_ptr_right += 2;",
            "\t\t\t}",
            "\t\t}",
            "\t\telse{",
            "\t\t\tif(x < THOUSAND){",
            "\t\t\t\tmemcpy(begin(output_buffer) + output_ptr_right, begin(io_pre.num) + (x << 2) + 1, 3);",
            "\t\t\t\toutput_ptr_right += 3;",
            "\t\t\t}",
            "\t\t\telse{",
            "\t\t\t\tmemcpy(begin(output_buffer) + output_ptr_right, begin(io_pre.num) + (x << 2), 4);",
            "\t\t\t\toutput_ptr_right += 4;",
            "\t\t\t}",
            "\t\t}",
            "\t\tmemcpy(begin(output_buffer) + output_ptr_right, begin(buf) + i + 4, TWELVE - i);",
            "\t\toutput_ptr_right += TWELVE - i;",
            "\t}",
            "\ttemplate<typename T_>",
            "\tIO& operator<<(T_ &&x){",
            "\t\tusing T = typename remove_cv<typename remove_reference<T_>::type>::type;",
            "\t\tstatic_assert(is_custom<T>::value or is_default<T>::value or  is_iterable<T>::value or is_applyable<T>::value);",
            "\t\tif constexpr(is_custom<T>::value) write_int(x.get());",
            "\t\telse if constexpr(is_default<T>::value){",
            "\t\t\tif constexpr(is_bool<T>::value) write_bool(x);",
            "\t\t\telse if constexpr(is_string<T>::value) write_string(x);",
            "\t\t\telse if constexpr(is_char<T>::value) write_char(x);",
            "\t\t\telse if constexpr(is_integral_v<T>) write_int(x);",
            "\t\t}",
            "\t\telse if constexpr(is_iterable<T>::value){",
            "\t\t\t// strings are immune",
            "\t\t\tusing E = decltype(*begin(x));",
            "\t\t\tconstexpr char sep = needs_newline<E> ? '\\n' : ' ';",
            "\t\t\tint i = 0;",
            "\t\t\tfor(const auto& y : x){",
            "\t\t\t\tif(i ++) write_char(sep);",
            "\t\t\t\toperator<<(y);",
            "\t\t\t}",
            "\t\t}",
            "\t\telse if constexpr(is_applyable<T>::value){",
            "\t\t\t// strings are immune",
            "\t\t\tconstexpr char sep = (any_needs_newline<T, make_index_sequence<tuple_size_v<T>>>::value) ? '\\n' : ' ';",
            "\t\t\tint i = 0;",
            "\t\t\tapply([this, &sep, &i](auto const&... y){",
            "\t\t\t\t(((i ++ ? write_char(sep) : void()), this->operator<<(y)),",
            "\t\t\t\t\t ...);",
            "\t\t\t}, x);",
            "\t\t}",
            "\t\treturn *this;",
            "\t}",
            "\ttemplate<typename T>",
            "\tIO& operator>>(T& x){",
            "\t\tstatic_assert(is_custom<T>::value or is_default<T>::value or is_iterable<T>::value or is_applyable<T>::value);",
            "\t\tstatic_assert(!is_bool<T>::value);",
            "\t\tif constexpr(is_custom<T>::value){",
            "\t\t\ttypename T::internal_value_type y;",
            "\t\t\tread_int(y);",
            "\t\t\tx = y;",
            "\t\t}",
            "\t\telse if constexpr(is_default<T>::value){",
            "\t\t\tif constexpr(is_string<T>::value) read_string(x);",
            "\t\t\telse if constexpr(is_char<T>::value) read_char(x);",
            "\t\t\telse if constexpr(is_integral_v<T>) read_int(x);",
            "\t\t}",
            "\t\telse if constexpr(is_iterable<T>::value) for(auto& y : x) operator>>(y);",
            "\t\telse if constexpr(is_applyable<T>::value) apply([this](auto&... y){ ((this->operator>>(y)), ...); }, x);",
            "\t\treturn *this;",
            "\t}",
            "\tIO* tie(nullptr_t){ return this; }",
            "\tvoid sync_with_stdio(bool){}",
            "};",
            "IO io;",
            "#define cin io",
            "#define cout io"
        ],
        "description": "tranxuanbach"
    }
}