{
    "tranxuanbach": {
        "prefix": "modular",
        "body": [
            "template<typename T>",
            "struct Z_p{",
            "\tusing Type = typename decay<decltype(T::value)>::type;",
            "\tstatic vector<Type> mod_inv; ",
            "\tconstexpr Z_p(): value(){ }",
            "\ttemplate<typename U> Z_p(const U &x){ value = normalize(x); }",
            "\ttemplate<typename U> static Type normalize(const U &x){",
            "\t\tType v;",
            "\t\tif(-mod() <= x && x < mod()) v = static_cast<Type>(x);",
            "\t\telse v = static_cast<Type>(x % mod());",
            "\t\tif(v < 0) v += mod();",
            "\t\treturn v;",
            "\t}",
            "\tconst Type& operator()() const{ return value; }",
            "\ttemplate<typename U> explicit operator U() const{ return static_cast<U>(value); }",
            "\tconstexpr static Type mod(){ return T::value; }",
            "\tZ_p &operator+=(const Z_p &otr){ if((value += otr.value) >= mod()) value -= mod(); return *this; }",
            "\tZ_p &operator-=(const Z_p &otr){ if((value -= otr.value) < 0) value += mod(); return *this; }",
            "\ttemplate<typename U> Z_p &operator+=(const U &otr){ return *this += Z_p(otr); }",
            "\ttemplate<typename U> Z_p &operator-=(const U &otr){ return *this -= Z_p(otr); }",
            "\tZ_p &operator++(){ return *this += 1; }",
            "\tZ_p &operator--(){ return *this -= 1; }",
            "\tZ_p operator++(int){ Z_p result(*this); *this += 1; return result; }",
            "\tZ_p operator--(int){ Z_p result(*this); *this -= 1; return result; }",
            "\tZ_p operator-() const{ return Z_p(-value); }",
            "\ttemplate<typename U = T>",
            "\ttypename enable_if<is_same<typename Z_p<U>::Type, int>::value, Z_p>::type &operator*=(const Z_p& rhs){",
            "\t\t#ifdef _WIN32",
            "\t\tuint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);",
            "\t\tuint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;",
            "\t\tasm(",
            "\t\t\t\"divl %4; \\n\\t\"",
            "\t\t\t: \"=a\" (d), \"=d\" (m)",
            "\t\t\t: \"d\" (xh), \"a\" (xl), \"r\" (mod())",
            "\t\t);",
            "\t\tvalue = m;",
            "\t\t#else",
            "\t\tvalue = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));",
            "\t\t#endif",
            "\t\treturn *this;",
            "\t}",
            "\ttemplate<typename U = T>",
            "\ttypename enable_if<is_same<typename Z_p<U>::Type, int64_t>::value, Z_p>::type &operator*=(const Z_p &rhs){",
            "\t\tint64_t q = static_cast<int64_t>(static_cast<long double>(value) * rhs.value / mod());",
            "\t\tvalue = normalize(value * rhs.value - q * mod());",
            "\t\treturn *this;",
            "\t}",
            "\ttemplate<typename U = T>",
            "\ttypename enable_if<!is_integral<typename Z_p<U>::Type>::value, Z_p>::type &operator*=(const Z_p &rhs){",
            "\t\tvalue = normalize(value * rhs.value);",
            "\t\treturn *this;",
            "\t}",
            "\tZ_p operator^(long long e) const{",
            "\t\tZ_p b = *this, res = 1;",
            "\t\tif(e < 0) b = 1 / b, e = -e;",
            "\t\tfor(; e; b *= b, e >>= 1) if(e & 1) res *= b;",
            "\t\treturn res;",
            "\t}",
            "\tZ_p &operator^=(const long long &e){ return *this = *this ^ e; }",
            "\tZ_p &operator/=(const Z_p &otr){",
            "\t\tType a = otr.value, m = mod(), u = 0, v = 1;",
            "\t\tif(a < int(mod_inv.size())) return *this *= mod_inv[a];",
            "\t\twhile(a){",
            "\t\t\tType t = m / a;",
            "\t\t\tm -= t * a; swap(a, m);",
            "\t\t\tu -= t * v; swap(u, v);",
            "\t\t}",
            "\t\tassert(m == 1);",
            "\t\treturn *this *= u;",
            "\t}",
            "\ttemplate<typename U> friend const Z_p<U> &abs(const Z_p<U> &v){ return v; }",
            "\ttemplate<typename U> friend bool operator==(const Z_p<U> &lhs, const Z_p<U> &rhs);",
            "\ttemplate<typename U> friend bool operator<(const Z_p<U> &lhs, const Z_p<U> &rhs);",
            "\ttemplate<typename U> friend istream &operator>>(istream &in, Z_p<U> &number);",
            "\tType value;",
            "};",
            "template<typename T> bool operator==(const Z_p<T> &lhs, const Z_p<T> &rhs){ return lhs.value == rhs.value; }",
            "template<typename T, typename U, typename enable_if<is_integral<U>::value>::type* = nullptr> bool operator==(const Z_p<T>& lhs, U rhs){ return lhs == Z_p<T>(rhs); }",
            "template<typename T, typename U, typename enable_if<is_integral<U>::value>::type* = nullptr> bool operator==(U lhs, const Z_p<T> &rhs){ return Z_p<T>(lhs) == rhs; }",
            "template<typename T> bool operator!=(const Z_p<T> &lhs, const Z_p<T> &rhs){ return !(lhs == rhs); }",
            "template<typename T, typename U, typename enable_if<is_integral<U>::value>::type* = nullptr> bool operator!=(const Z_p<T> &lhs, U rhs){ return !(lhs == rhs); }",
            "template<typename T, typename U, typename enable_if<is_integral<U>::value>::type* = nullptr> bool operator!=(U lhs, const Z_p<T> &rhs){ return !(lhs == rhs); }",
            "template<typename T> bool operator<(const Z_p<T> &lhs, const Z_p<T> &rhs){ return lhs.value < rhs.value; }",
            "template<typename T> Z_p<T> operator+(const Z_p<T> &lhs, const Z_p<T> &rhs){ return Z_p<T>(lhs) += rhs; }",
            "template<typename T, typename U, typename enable_if<is_integral<U>::value>::type* = nullptr> Z_p<T> operator+(const Z_p<T> &lhs, U rhs){ return Z_p<T>(lhs) += rhs; }",
            "template<typename T, typename U, typename enable_if<is_integral<U>::value>::type* = nullptr> Z_p<T> operator+(U lhs, const Z_p<T> &rhs){ return Z_p<T>(lhs) += rhs; }",
            "template<typename T> Z_p<T> operator-(const Z_p<T> &lhs, const Z_p<T> &rhs){ return Z_p<T>(lhs) -= rhs; }",
            "template<typename T, typename U, typename enable_if<is_integral<U>::value>::type* = nullptr> Z_p<T> operator-(const Z_p<T>& lhs, U rhs){ return Z_p<T>(lhs) -= rhs; }",
            "template<typename T, typename U, typename enable_if<is_integral<U>::value>::type* = nullptr> Z_p<T> operator-(U lhs, const Z_p<T> &rhs){ return Z_p<T>(lhs) -= rhs; }",
            "template<typename T> Z_p<T> operator*(const Z_p<T> &lhs, const Z_p<T> &rhs){ return Z_p<T>(lhs) *= rhs; }",
            "template<typename T, typename U, typename enable_if<is_integral<U>::value>::type* = nullptr> Z_p<T> operator*(const Z_p<T>& lhs, U rhs){ return Z_p<T>(lhs) *= rhs; }",
            "template<typename T, typename U, typename enable_if<is_integral<U>::value>::type* = nullptr> Z_p<T> operator*(U lhs, const Z_p<T> &rhs){ return Z_p<T>(lhs) *= rhs; }",
            "template<typename T> Z_p<T> operator/(const Z_p<T> &lhs, const Z_p<T> &rhs) { return Z_p<T>(lhs) /= rhs; }",
            "template<typename T, typename U, typename enable_if<is_integral<U>::value>::type* = nullptr> Z_p<T> operator/(const Z_p<T>& lhs, U rhs) { return Z_p<T>(lhs) /= rhs; }",
            "template<typename T, typename U, typename enable_if<is_integral<U>::value>::type* = nullptr> Z_p<T> operator/(U lhs, const Z_p<T> &rhs) { return Z_p<T>(lhs) /= rhs; }",
            "template<typename T> istream &operator>>(istream &in, Z_p<T> &number){",
            "\ttypename common_type<typename Z_p<T>::Type, int64_t>::type x;",
            "\tin >> x;",
            "\tnumber.value = Z_p<T>::normalize(x);",
            "\treturn in;",
            "}",
            "template<typename T> ostream &operator<<(ostream &out, const Z_p<T> &number){ return out << number(); }",
            "",
            "/*",
            "using ModType = int;",
            "struct VarMod{ static ModType value; };",
            "ModType VarMod::value;",
            "ModType &mod = VarMod::value;",
            "using Zp = Z_p<VarMod>;",
            "*/",
            "",
            "constexpr int mod = 1e9 + 7;",
            "//constexpr int mod = (119 << 23) + 1;",
            "using Zp = Z_p<integral_constant<decay<decltype(mod)>::type, mod>>;",
            "",
            "template<typename T> vector<typename Z_p<T>::Type> Z_p<T>::mod_inv;",
            "template<typename T = integral_constant<decay<decltype(mod)>::type, mod>>",
            "void precalc_inverse(size_t SZ){",
            "\tauto &inv = Z_p<T>::mod_inv;",
            "\tif(inv.empty()) inv.assign(2, 1);",
            "\tfor(; inv.size() <= SZ; ) inv.push_back((mod - 1LL * mod / int(inv.size()) * inv[mod % int(inv.size())] % mod) % mod);",
            "}"
        ],
        "description": "tranxuanbach"
    }
}