{
    "tranxuanbach": {
        "prefix": "maximum_bipartite_matching_solver",
        "body": [
            "struct maximum_bipartite_matching_solver{",
            "\tint n, m;",
            "\tvector<vector<int>> adj;",
            "\tvector<int> pu, pv; // u is matched with pu[u] and v with pv[v], -1 if no match",
            "\tvirtual ~maximum_bipartite_matching_solver(){ }",
            "\tvirtual int insert(int u, int v){ return -1; };",
            "\tvirtual int maximum_matching(){ return -1; };",
            "\ttuple<int, vector<int>, vector<int>> minimum_vertex_cover(){",
            "\t\tint size = maximum_matching();",
            "\t\tvector<int> L, R, visL(n), visR(m), in_R(m);",
            "\t\tauto dfs = [&](auto self, int u)->void{",
            "\t\t\tvisL[u] = true;",
            "\t\t\tfor(auto v: adj[u]) if(v != pu[u] && !visR[v]){",
            "\t\t\t\tvisR[v] = true, in_R[v] = true;",
            "\t\t\t\tif(~pv[v]) self(self, pv[v]);",
            "\t\t\t}",
            "\t\t};",
            "\t\tfor(auto u = 0; u < n; ++ u) if(!visL[u] && !~pu[u]) dfs(dfs, u);",
            "\t\tfor(auto u = 0; u < n; ++ u) if(!visL[u]) L.push_back(u);",
            "\t\tfor(auto v = 0; v < m; ++ v) if(in_R[v]) R.push_back(v);",
            "\t\tassert(size == (int)L.size() + (int)R.size()); // KÅ‘nig's theorem.",
            "\t\treturn {(int)L.size() + (int)R.size(), L, R};",
            "\t}",
            "\ttuple<int, vector<int>, vector<int>> maximum_independent_set(){",
            "\t\tauto [cover_size, coverL, coverR] = minimum_vertex_cover();",
            "\t\tvector<int> indepL, indepR;",
            "\t\tfor(auto u = 0, i = 0; u < n; ++ u){",
            "\t\t\twhile(i < (int)coverL.size() && coverL[i] < u) ++ i;",
            "\t\t\tif(i == (int)coverL.size() || u < coverL[i]) indepL.push_back(u);",
            "\t\t}",
            "\t\tfor(auto v = 0, j = 0; v < m; ++ v){",
            "\t\t\twhile(j < (int)coverR.size() && coverR[j] < v) ++ j;",
            "\t\t\tif(j == (int)coverR.size() || v < coverR[j]) indepR.push_back(v);",
            "\t\t}",
            "\t\treturn {(int)indepL.size() + (int)indepR.size(), indepL, indepR};",
            "\t}",
            "};"
        ],
        "description": "tranxuanbach"
    }
}