{
    "tranxuanbach": {
        "prefix": "euler_decomopsition",
        "body": [
            "// Decompose the given loopless undirected graph into endpoint disjoint paths and cycles",
            "// O(|V| + |E|)",
            "template<class T>",
            "void euler_decomopsition(const graph<T> &g, auto process_path, auto process_cycle){",
            "\tint n = g.n, m = (int)g.edge.size();",
            "\tvector<array<int, 2>> edge;",
            "\tvector<vector<array<int, 2>>> adj(m);",
            "\tfor(auto u = 0; u < n; ++ u){",
            "\t\tint j = -1;",
            "\t\tfor(auto i: g.adj[u]){",
            "\t\t\tif(g.ignore && g.ignore(i)) continue;",
            "\t\t\tif(!~j) j = i;",
            "\t\t\telse{",
            "\t\t\t\tint id = (int)edge.size();",
            "\t\t\t\tadj[i].push_back({id, u}), adj[j].push_back({id, u});",
            "\t\t\t\tedge.push_back({i, j});",
            "\t\t\t\tj = -1;",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "\tvector<int> vis(m);",
            "\tauto update = [&](int u)->void{",
            "\t\tvis[u] = true;",
            "\t\tvector<int> path{u};",
            "\t\tint end = g.edge[u].from;",
            "\t\tfor(auto [id, w]: adj[u]){",
            "\t\t\treverse(path.begin(), path.end());",
            "\t\t\tfor(auto v = u ^ edge[id][0] ^ edge[id][1]; !vis[v]; ){",
            "\t\t\t\tvis[v] = true;",
            "\t\t\t\tpath.push_back(v);",
            "\t\t\t\tend = w ^= g.edge[v].from ^ g.edge[v].to;",
            "\t\t\t\tif((int)adj[v].size() == 1) break;",
            "\t\t\t\tid ^= adj[v][0][0] ^ adj[v][1][0];",
            "\t\t\t\tv ^= edge[id][0] ^ edge[id][1];",
            "\t\t\t}",
            "\t\t}",
            "\t\tint start = end;",
            "\t\tfor(auto it = path.rbegin(); it != path.rend(); ++ it) start ^= g.edge[*it].from ^ g.edge[*it].to;",
            "\t\tif(start != end) process_path(start, end, path);",
            "\t\telse process_cycle(start, path);",
            "\t};",
            "\tfor(auto u = 0; u < m; ++ u){",
            "\t\tif((int)adj[u].size() == 2 || vis[u] || g.ignore && g.ignore(u)) continue;",
            "\t\tupdate(u);",
            "\t}",
            "\tfor(auto u = 0; u < m; ++ u){",
            "\t\tif(vis[u] || g.ignore && g.ignore(u)) continue;",
            "\t\tupdate(u);",
            "\t}",
            "}"
        ],
        "description": "tranxuanbach"
    }
}