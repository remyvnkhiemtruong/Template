{
    "tranxuanbach": {
        "prefix": "minimum_spanning_arborescence",
        "body": [
            "// Returns {min_cost, parent_vertices}",
            "// O(E * log(V))",
            "// Requires graph and disjoint_set_rollback",
            "template<class U, class T>",
            "optional<pair<U, vector<int>>> minimum_spanning_arborescence(const graph<T> &g, int src){",
            "\tusing E = typename graph<T>::Edge_t;",
            "\tstruct node{ /// lazy skew heap node",
            "\t\tE key;",
            "\t\tshared_ptr<node> l, r;",
            "\t\tU delta;",
            "\t\tvoid prop(){",
            "\t\t\tkey.cost += delta;",
            "\t\t\tif(l) l->delta += delta;",
            "\t\t\tif(r) r->delta += delta;",
            "\t\t\tdelta = 0;",
            "\t\t}",
            "\t\tE top() { prop(); return key; }",
            "\t};",
            "\tauto merge = [&](auto self, shared_ptr<node> a, shared_ptr<node> b)->shared_ptr<node>{",
            "\t\tif(!a || !b) return a ?: b;",
            "\t\ta->prop(), b->prop();",
            "\t\tif(a->key.cost > b->key.cost) swap(a, b);",
            "\t\tswap(a->l, (a->r = self(self, b, a->r)));",
            "\t\treturn a;",
            "\t};",
            "\tauto pop = [&](shared_ptr<node> &a){",
            "\t\ta->prop(), a = merge(merge, a->l, a->r);",
            "\t};",
            "\tint n = g.n;",
            "\tU cost = {};",
            "\tvector<int> pv(n);",
            "\tdisjoint_set_rollback dsu(n);",
            "\tvector<shared_ptr<node>> heap(n);",
            "\tfor(auto e: g.edge) heap[e.to] = merge(merge, heap[e.to], shared_ptr<node>(new node{e}));",
            "\tvector<int> seen(n, -1), path(n);",
            "\tseen[src] = src;",
            "\tvector<E> Q(n), in(n, {-1, -1}), comp;",
            "\tdeque<tuple<int, int, vector<E>>> cycs;",
            "\tfor(auto s = 0; s < n; ++ s){",
            "\t\tint u = s, qi = 0, w;",
            "\t\twhile(seen[u] < 0){",
            "\t\t\tif(!heap[u]) return {};",
            "\t\t\tE e = heap[u]->top();",
            "\t\t\theap[u]->delta -= e.cost, pop(heap[u]);",
            "\t\t\tQ[qi] = e, path[qi ++] = u, seen[u] = s;",
            "\t\t\tcost += e.cost, u = dsu.root(e.from);",
            "\t\t\tif(seen[u] == s){ // found cycle, contract",
            "\t\t\t\tshared_ptr<node> cyc;",
            "\t\t\t\tint end = qi, state = dsu.state();",
            "\t\t\t\tdo cyc = merge(merge, cyc, heap[w = path[-- qi]]);",
            "\t\t\t\twhile(dsu.merge(u, w));",
            "\t\t\t\tu = dsu.root(u), heap[u] = cyc, seen[u] = -1;",
            "\t\t\t\tcycs.push_front({u, state, {&Q[qi], &Q[end]}});",
            "\t\t\t}",
            "\t\t}",
            "\t\tfor(auto i = 0; i < qi; ++ i) in[dsu.root(Q[i].to)] = Q[i];",
            "\t}",
            "\tfor(auto &[u, t, comp]: cycs){ // restore sol (optional)",
            "\t\tdsu.reverse_to(t);",
            "\t\tE ine = in[u];",
            "\t\tfor(auto &e: comp) in[dsu.root(e.to)] = e;",
            "\t\tin[dsu.root(ine.to)] = ine;",
            "\t}",
            "\tfor(auto u = 0; u < n; ++ u) pv[u] = in[u].from;",
            "\treturn {{cost, pv}};",
            "}"
        ],
        "description": "tranxuanbach"
    }
}