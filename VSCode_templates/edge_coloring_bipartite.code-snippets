{
    "tranxuanbach": {
        "prefix": "edge_coloring_bipartite",
        "body": [
            "struct edge_coloring_bipartite{",
            "\tint n, m;",
            "\tvector<array<int, 2>> edge;",
            "\tedge_coloring_bipartite(int n, int m): n(n), m(m){ assert(0 <= n && 0 <= m); }",
            "\tint insert(int u, int v){",
            "\t\tassert(0 <= u && u < n);",
            "\t\tassert(0 <= v && v < m);",
            "\t\tedge.push_back({u, v});",
            "\t\treturn (int)edge.size() - 1;",
            "\t}",
            "\tvoid clear(){",
            "\t\tedge.clear();",
            "\t}",
            "\t// Assign color to each edge so that",
            "\t// 1. two edges sharing an endpoint have different color, and",
            "\t// 2. each color is an integer in range [0, max_deg).",
            "\t// Returns {coloring, max_deg}",
            "\t// O(k * (n + m + max_deg))",
            "\tpair<vector<int>, int> color_exactly(){",
            "\t\tif(edge.empty()) return {{}, 0};",
            "\t\tint k = (int)edge.size();",
            "\t\tvector<int> degl(n), degr(m);",
            "\t\tfor(auto &[u, v]: edge) ++ degl[u], ++ degr[v];",
            "\t\tint max_deg = max(*max_element(degl.begin(), degl.end()), *max_element(degr.begin(), degr.end()));",
            "\t\tvector used_by_left(n, vector<int>(max_deg, -1)), used_by_right(m, vector<int>(max_deg, -1));",
            "\t\tvector<int> color(k, -1), order(k);",
            "\t\tiota(order.begin(), order.end(), 0);",
            "\t\tshuffle(order.begin(), order.end(), mt19937(12345));",
            "\t\tfor(auto i: order){",
            "\t\t\tauto [u, v] = edge[i];",
            "\t\t\tfor(auto c = 0; c < max_deg; ++ c) if(!~used_by_left[u][c] && !~used_by_right[v][c]){",
            "\t\t\t\tused_by_left[u][c] = used_by_right[v][c] = i;",
            "\t\t\t\tcolor[i] = c;",
            "\t\t\t\tgoto DONE;",
            "\t\t\t}",
            "\t\t\t{",
            "\t\t\t\tint c = 0, d = 0;",
            "\t\t\t\twhile(!~used_by_left[u][c] || ~used_by_right[v][c]) ++ c;",
            "\t\t\t\twhile(~used_by_left[u][d] || !~used_by_right[v][d]) ++ d;",
            "\t\t\t\twhile(true){",
            "\t\t\t\t\tint j = used_by_right[v][d];",
            "\t\t\t\t\tused_by_left[u][d] = used_by_right[v][d] = i;",
            "\t\t\t\t\tcolor[i] = d;",
            "\t\t\t\t\tif(!~j){",
            "\t\t\t\t\t\tused_by_right[v][c] = -1;",
            "\t\t\t\t\t\tbreak;",
            "\t\t\t\t\t}",
            "\t\t\t\t\ti = j;",
            "\t\t\t\t\tu = edge[i][0];",
            "\t\t\t\t\tj = used_by_left[u][c];",
            "\t\t\t\t\tused_by_left[u][c] = used_by_right[v][c] = i;",
            "\t\t\t\t\tcolor[i] = c;",
            "\t\t\t\t\tif(!~j){",
            "\t\t\t\t\t\tused_by_left[u][d] = -1;",
            "\t\t\t\t\t\tbreak;",
            "\t\t\t\t\t}",
            "\t\t\t\t\ti = j;",
            "\t\t\t\t\tv = edge[i][1];",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t\tDONE:;",
            "\t\t}",
            "\t\treturn {color, max_deg};",
            "\t}",
            "\t// Assign color to each edge so that",
            "\t// 1. two edges sharing an endpoint have different color, and",
            "\t// 2. each color is an integer in range [0, th) where th is the smallest power of two equal or greater than max_deg.",
            "\t// Returns {coloring, th}",
            "\t// O(log(max_deg) * (n + m + k))",
            "\tpair<vector<int>, int> color_with_power_of_two(){",
            "\t\tif(edge.empty()) return {{}, 0};",
            "\t\tint k = (int)edge.size();",
            "\t\tvector<int> degl(n), degr(m);",
            "\t\tfor(auto [u, v]: edge) ++ degl[u], ++ degr[v];",
            "\t\tint max_deg = max(*max_element(degl.begin(), degl.end()), *max_element(degr.begin(), degr.end()));",
            "\t\tint th = 1 << __lg(max_deg) + (max_deg != 1 << __lg(max_deg));",
            "\t\tvector<int> subset(k);",
            "\t\tiota(subset.begin(), subset.end(), 0);",
            "\t\tauto edge_recover = edge;",
            "\t\tvector<int> color(k, -1);",
            "\t\tvector<tuple<int, int, int, int, vector<int>>> stack{{n, m, th, 0, subset}};",
            "\t\tvector<vector<int>> adj(n + m + 2);",
            "\t\tvector<int> was(max(n + m, k), -1), oddl, oddr, appearL, appearR, on_L, on_R;",
            "\t\tfor(auto it = 0; !stack.empty(); ++ it){",
            "\t\t\tauto [n, m, th, base, subset] = stack.back();",
            "\t\t\tstack.pop_back();",
            "\t\t\tif(subset.empty()) continue;",
            "\t\t\t++ it;",
            "\t\t\tdegl.assign(n + 1, 0), degr.assign(m + 1, 0);",
            "\t\t\tfor(auto i: subset){",
            "\t\t\t\tauto [u, v] = edge[i];",
            "\t\t\t\t++ degl[u], ++ degr[v];",
            "\t\t\t}",
            "\t\t\tif(*max_element(degl.begin(), degl.end()) <= 2 && *max_element(degr.begin(), degr.end()) <= 2){",
            "\t\t\t\tfor(auto i: subset){",
            "\t\t\t\t\tauto [u, v] = edge[i];",
            "\t\t\t\t\tadj[u].push_back(i);",
            "\t\t\t\t\tadj[n + v].push_back(i);",
            "\t\t\t\t}",
            "\t\t\t\tfor(auto u = 0; u < n + m; ++ u){",
            "\t\t\t\t\tif(was[u] == it){",
            "\t\t\t\t\t\tcontinue;",
            "\t\t\t\t\t}",
            "\t\t\t\t\tfor(auto t = 0; t < (int)adj[u].size(); ++ t){",
            "\t\t\t\t\t\tint i = adj[u][t], c = base + t, v = u;",
            "\t\t\t\t\t\twhile(true){",
            "\t\t\t\t\t\t\twas[v] = it;",
            "\t\t\t\t\t\t\tcolor[i] = c;",
            "\t\t\t\t\t\t\tc ^= base ^ base + 1;",
            "\t\t\t\t\t\t\tv ^= edge[i][0] ^ n + edge[i][1];",
            "\t\t\t\t\t\t\tif(was[v] == it || (int)adj[v].size() != 2){",
            "\t\t\t\t\t\t\t\twas[v] = it;",
            "\t\t\t\t\t\t\t\tbreak;",
            "\t\t\t\t\t\t\t}",
            "\t\t\t\t\t\t\ti ^= adj[v][0] ^ adj[v][1];",
            "\t\t\t\t\t\t}",
            "\t\t\t\t\t}",
            "\t\t\t\t}",
            "\t\t\t\tfor(auto u = 0; u < n + m; ++ u) adj[u].clear();",
            "\t\t\t\tcontinue;",
            "\t\t\t}",
            "\t\t\toddl.clear(), oddr.clear();",
            "\t\t\tfor(auto u = 0; u < n; ++ u) if(degl[u] & 1) oddl.push_back(u);",
            "\t\t\tfor(auto v = 0; v < m; ++ v) if(degr[v] & 1) oddr.push_back(v);",
            "\t\t\tint kc = k;",
            "\t\t\twhile(!oddl.empty() && !oddr.empty()){",
            "\t\t\t\tsubset.push_back(kc ++);",
            "\t\t\t\t++ degl[oddl.back()], ++ degr[oddr.back()];",
            "\t\t\t\tedge.push_back({oddl.back(), oddr.back()});",
            "\t\t\t\toddl.pop_back(), oddr.pop_back();",
            "\t\t\t}",
            "\t\t\tfor(auto v = 0; !oddl.empty(); ){",
            "\t\t\t\twhile(v < m && degr[v] == th) ++ v;",
            "\t\t\t\tfor(auto rep = 0; rep < 2; ++ rep){",
            "\t\t\t\t\tsubset.push_back(kc ++);",
            "\t\t\t\t\tedge.push_back({oddl.back(), v});",
            "\t\t\t\t\toddl.pop_back();",
            "\t\t\t\t\t++ degr[v];",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t\tfor(auto u = 0; !oddr.empty(); ){",
            "\t\t\t\twhile(u < n && degl[u] == th) ++ u;",
            "\t\t\t\tfor(auto rep = 0; rep < 2; ++ rep){",
            "\t\t\t\t\tsubset.push_back(kc ++);",
            "\t\t\t\t\tedge.push_back({u, oddr.back()});",
            "\t\t\t\t\toddr.pop_back();",
            "\t\t\t\t\t++ degl[u];",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t\tfor(auto i: subset){",
            "\t\t\t\tauto [u, v] = edge[i];",
            "\t\t\t\tadj[u].push_back(i), adj[n + 1 + v].push_back(i);",
            "\t\t\t}",
            "\t\t\twas.resize(max((int)was.size(), kc), -1);",
            "\t\t\tarray<int, 2> subset_cnt{};",
            "\t\t\tarray<vector<int>, 2> subset_next;",
            "\t\t\tauto dfs = [&](auto self, int u)->void{",
            "\t\t\t\twhile(true){",
            "\t\t\t\t\twhile(!adj[u].empty() && was[adj[u].back()] == it) adj[u].pop_back();",
            "\t\t\t\t\tif(adj[u].empty()) break;",
            "\t\t\t\t\tint i = adj[u].back();",
            "\t\t\t\t\tadj[u].pop_back();",
            "\t\t\t\t\tauto [_u, _v] = edge[i];",
            "\t\t\t\t\t_v += n + 1;",
            "\t\t\t\t\twas[i] = it;",
            "\t\t\t\t\tself(self, u ^ _u ^ _v);",
            "\t\t\t\t\tint t = subset_cnt[0] != subset_cnt[1];",
            "\t\t\t\t\tif(i < k) subset_next[t].push_back(i);",
            "\t\t\t\t\t++ subset_cnt[t];",
            "\t\t\t\t}",
            "\t\t\t};",
            "\t\t\tfor(auto u = 0; u < n; ++ u) dfs(dfs, u);",
            "\t\t\tfor(auto u = 0; u < n + m + 2; ++ u) adj[u].clear();",
            "\t\t\tassert(subset_cnt[0] == subset_cnt[1]);",
            "\t\t\tedge.resize(k);",
            "\t\t\tfor(auto t = 0; t < 2; ++ t){",
            "\t\t\t\ton_L.assign(n, 0), on_R.assign(m, 0);",
            "\t\t\t\tfor(auto i: subset_next[t]){",
            "\t\t\t\t\tauto [u, v] = edge[i];",
            "\t\t\t\t\ton_L[u] = on_R[v] = true;",
            "\t\t\t\t}",
            "\t\t\t\tappearL.clear(), appearR.clear();",
            "\t\t\t\tfor(auto u = 0; u < n; ++ u) if(on_L[u]) appearL.push_back(u);",
            "\t\t\t\tint n = (int)appearL.size();",
            "\t\t\t\tfor(auto i = 0; i < n; ++ i) on_L[appearL[i]] = i;",
            "\t\t\t\tfor(auto v = 0; v < m; ++ v) if(on_R[v]) appearR.push_back(v);",
            "\t\t\t\tint m = (int)appearR.size();",
            "\t\t\t\tfor(auto j = 0; j < m; ++ j) on_R[appearR[j]] = j;",
            "\t\t\t\tfor(auto i: subset_next[t]){",
            "\t\t\t\t\tauto &[u, v] = edge[i];",
            "\t\t\t\t\tu = on_L[u], v = on_R[v];",
            "\t\t\t\t}",
            "\t\t\t\tstack.push_back({n, m, th / 2, base + th / 2 * t, subset_next[t]});",
            "\t\t\t}",
            "\t\t}",
            "\t\tedge_recover = edge;",
            "\t\treturn {color, th};",
            "\t}",
            "};"
        ],
        "description": "tranxuanbach"
    }
}