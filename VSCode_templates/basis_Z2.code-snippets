{
    "tranxuanbach": {
        "prefix": "basis_Z2",
        "body": [
            "template<size_t S>",
            "struct basis_Z2{",
            "\tint count = 0;",
            "\tvector<bitset<S>> data;",
            "\tvector<int> pivot;",
            "\tstruct modifier_type{",
            "\t\tint type;",
            "\t\t// 0: row[to] ^= row[from]",
            "\t\t// 2: insert row[from] into row[to]",
            "\t\tint from, to;",
            "\t};",
            "\tvector<modifier_type> log;",
            "\tbasis_Z2(const vector<bitset<S>> &a = {}){",
            "\t\tfor(auto &v: a) insert(v);",
            "\t}",
            "\tint rank() const{",
            "\t\treturn (int)data.size();",
            "\t}",
            "\t// O(rank * width / w)",
            "\tbitset<S> reduce(bitset<S> v) const{",
            "\t\tfor(auto i = 0; i < rank(); ++ i) if(v[pivot[i]]) v ^= data[i];",
            "\t\treturn v;",
            "\t}",
            "\t// Insert a row while maintaining the lower triangular form",
            "\t// O(rank * width / w)",
            "\tbool insert(bitset<S> v){",
            "\t\tfor(auto i = 0; i < rank(); ++ i) if(v[pivot[i]]){",
            "\t\t\tv ^= data[i];",
            "\t\t\tlog.push_back({0, i, count});",
            "\t\t}",
            "\t\tif(v.none()) return ++ count, false;",
            "\t\tint p = S - 1;",
            "\t\twhile(!v[p]) -- p;",
            "\t\tfor(auto i = 0; i < rank(); ++ i) if(data[i][p]){",
            "\t\t\tdata[i] ^= v;",
            "\t\t\tlog.push_back({0, count, i});",
            "\t\t}",
            "\t\tint t = lower_bound(pivot.begin(), pivot.end(), p) - pivot.begin();",
            "\t\tpivot.insert(pivot.begin() + t, p);",
            "\t\tdata.insert(data.begin() + t, v);",
            "\t\tlog.push_back({2, count, t});",
            "\t\treturn ++ count, true;",
            "\t}",
            "\t// Returns {",
            "\t//  lexicographically_smallest_sol,",
            "\t//  sol_basis_vector_1,",
            "\t//  ...,",
            "\t//  sol_basis_vector_k",
            "\t// }",
            "\t// O(rank * width / w)",
            "\ttemplate<bool construct_solution = true>",
            "\toptional<vector<bitset<S>>> solve(vector<int> b) const{",
            "\t\tassert(count == (int)b.size());",
            "\t\tfor(auto &m: log){",
            "\t\t\tif(m.type == 0) b[m.to] ^= b[m.from];",
            "\t\t\telse rotate(b.begin() + m.to, b.begin() + m.from, b.begin() + m.from + 1);",
            "\t\t}",
            "\t\tfor(auto i = rank(); i < count; ++ i) if(b[i]) return {};",
            "\t\tvector<bitset<S>> res(1);",
            "\t\tbitset<S> is_free;",
            "\t\tis_free.set();",
            "\t\tfor(auto i = 0; i < rank(); ++ i){",
            "\t\t\tif(b[i]) res[0].set(pivot[i]);",
            "\t\t\tis_free.reset(pivot[i]);",
            "\t\t}",
            "\t\tif(!construct_solution) return res;",
            "\t\tfor(auto j = 0; j < S; ++ j) if(is_free[j]){",
            "\t\t\tbitset<S> v;",
            "\t\t\tv.set(j);",
            "\t\t\tfor(auto i = rank() - 1; i >= 0 && pivot[i] > j; -- i){",
            "\t\t\t\tbitset<S> temp;",
            "\t\t\t\ttemp.set(pivot[i]);",
            "\t\t\t\tv |= data[i] & temp;",
            "\t\t\t}",
            "\t\t\tres.push_back(v);",
            "\t\t}",
            "\t\treturn res;",
            "\t}",
            "};"
        ],
        "description": "tranxuanbach"
    }
}