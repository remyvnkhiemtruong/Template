{
    "tranxuanbach": {
        "prefix": "flow_decomposition",
        "body": [
            "// Requires flow_network",
            "template<class T>",
            "struct flow_decomposition{",
            "\tflow_network<T> &F;",
            "\tvector<vector<int>> paths;",
            "\tvector<T> path_flows;",
            "\tvector<vector<int>> cycles;",
            "\tvector<T> cycle_flows;",
            "\tflow_decomposition(flow_network<T> &F): F(F){ }",
            "\tvoid decompose(int source, int sink){",
            "\t\tvector<T> fs(F.edge.size());",
            "\t\tfor(auto i = 0; i < (int)F.edge.size(); ++ i) fs[i] = F.edge[i].flow;",
            "\t\tpaths.clear();",
            "\t\tpath_flows.clear();",
            "\t\tcycles.clear();",
            "\t\tcycle_flows.clear();",
            "\t\tint n = F.n;",
            "\t\tstatic constexpr T eps = (T)1e-9;",
            "\t\tvector<int> ptr(n);",
            "\t\tfor(auto i = 0; i < n; ++ i) ptr[i] = (int)F.adj[i].size() - 1;",
            "\t\tvector<int> was(n, -1);",
            "\t\tint start = source;",
            "\t\tfor(auto iter = 0; ; ++ iter){",
            "\t\t\tbool found_start = false;",
            "\t\t\twhile(true){",
            "\t\t\t\tif(ptr[start] >= 0){",
            "\t\t\t\t\tint id = F.adj[start][ptr[start]];",
            "\t\t\t\t\tif(fs[id] > eps){",
            "\t\t\t\t\t\tfound_start = true;",
            "\t\t\t\t\t\tbreak;",
            "\t\t\t\t\t}",
            "\t\t\t\t\t-- ptr[start];",
            "\t\t\t\t\tcontinue;",
            "\t\t\t\t}",
            "\t\t\t\tstart = (start + 1) % n;",
            "\t\t\t\tif(start == source) break;",
            "\t\t\t}",
            "\t\t\tif(!found_start) break;",
            "\t\t\tvector<int> path;",
            "\t\t\tbool is_cycle = false;",
            "\t\t\tint u = start;",
            "\t\t\twhile(true){",
            "\t\t\t\tif(u == sink) break;",
            "\t\t\t\tif(was[u] == iter){",
            "\t\t\t\t\tbool found = false;",
            "\t\t\t\t\tfor(auto i = 0; i < (int)path.size(); ++ i){",
            "\t\t\t\t\t\tint id = path[i];",
            "\t\t\t\t\t\tauto &e = F.edge[id];",
            "\t\t\t\t\t\tif(e.from == u){",
            "\t\t\t\t\t\t\tpath.erase(path.begin(), path.begin() + i);",
            "\t\t\t\t\t\t\tfound = true;",
            "\t\t\t\t\t\t\tbreak;",
            "\t\t\t\t\t\t}",
            "\t\t\t\t\t}",
            "\t\t\t\t\tassert(found);",
            "\t\t\t\t\tis_cycle = true;",
            "\t\t\t\t\tbreak;",
            "\t\t\t\t}",
            "\t\t\t\twas[u] = iter;",
            "\t\t\t\tbool found = false;",
            "\t\t\t\twhile(ptr[u] >= 0){",
            "\t\t\t\t\tint id = F.adj[u][ptr[u]];",
            "\t\t\t\t\tif(fs[id] > eps){",
            "\t\t\t\t\t\tpath.push_back(id);",
            "\t\t\t\t\t\tu = F.edge[id].to;",
            "\t\t\t\t\t\tfound = true;",
            "\t\t\t\t\t\tbreak;",
            "\t\t\t\t\t}",
            "\t\t\t\t\t-- ptr[u];",
            "\t\t\t\t}",
            "\t\t\t\tassert(found);",
            "\t\t\t}",
            "\t\t\tT path_flow = numeric_limits<T>::max();",
            "\t\t\tfor(auto id : path) path_flow = min(path_flow, fs[id]);",
            "\t\t\tfor(auto id : path){",
            "\t\t\t\tfs[id] -= path_flow;",
            "\t\t\t\tfs[id ^ 1] += path_flow;",
            "\t\t\t}",
            "\t\t\tif(is_cycle){",
            "\t\t\t\tcycles.push_back(path);",
            "\t\t\t\tcycle_flows.push_back(path_flow);",
            "\t\t\t}",
            "\t\t\telse{",
            "\t\t\t\tpaths.push_back(path);",
            "\t\t\t\tpath_flows.push_back(path_flow);",
            "\t\t\t}",
            "\t\t}",
            "\t\tfor(const auto &f: fs) assert(-eps <= f && f <= eps);",
            "\t}",
            "};"
        ],
        "description": "tranxuanbach"
    }
}