{
    "tranxuanbach": {
        "prefix": "basis_Z2_small",
        "body": [
            "// V must be an integral type",
            "template<class V>",
            "struct basis_Z2_small{",
            "\tint count = 0;",
            "\tvector<V> data;",
            "\tvector<int> pivot;",
            "\tstruct modifier_type{",
            "\t\tint type;",
            "\t\t// Type 0: row[to] ^= row[from]",
            "\t\t// Type 2: insert row[from] into row[to]",
            "\t\tint from, to;",
            "\t};",
            "\tvector<modifier_type> log;",
            "\tbasis_Z2_small(const vector<V> &a = {}){",
            "\t\tfor(auto v: a) insert(v);",
            "\t}",
            "\tint rank() const{",
            "\t\treturn (int)data.size();",
            "\t}",
            "\t// O(rank * width / w)",
            "\tV reduce(V v) const{",
            "\t\tfor(auto u: data) v = min(v ^ u, v);",
            "\t\treturn v;",
            "\t}",
            "\t// Insert a row while maintaining the lower triangular form",
            "\t// O(rank * width / w)",
            "\tbool insert(V v){",
            "\t\tfor(auto i = 0; i < rank(); ++ i) if(v >> pivot[i] & 1){",
            "\t\t\tv ^= data[i];",
            "\t\t\tlog.push_back({0, i, count});",
            "\t\t}",
            "\t\tif(!v) return ++ count, false;",
            "\t\tint p = __lg(v);",
            "\t\tfor(auto i = 0; i < rank(); ++ i) if(data[i] >> p & 1){",
            "\t\t\tdata[i] ^= v;",
            "\t\t\tlog.push_back({0, count, i});",
            "\t\t}",
            "\t\tint t = lower_bound(pivot.begin(), pivot.end(), p) - pivot.begin();",
            "\t\tpivot.insert(pivot.begin() + t, p);",
            "\t\tdata.insert(data.begin() + t, v);",
            "\t\tlog.push_back({2, count, t});",
            "\t\treturn ++ count, true;",
            "\t}",
            "\t// Returns {",
            "\t//  lexicographically_smallest_sol,",
            "\t//  sol_basis_vector_1,",
            "\t//  ...,",
            "\t//  sol_basis_vector_k",
            "\t// }",
            "\t// O(rank * width / w)",
            "\ttemplate<bool construct_solution = true>",
            "\toptional<vector<V>> solve(vector<int> b) const{",
            "\t\tassert(count == (int)b.size());",
            "\t\tfor(auto &m: log){",
            "\t\t\tif(m.type == 0) b[m.to] ^= b[m.from];",
            "\t\t\telse rotate(b.begin() + m.to, b.begin() + m.from, b.begin() + m.from + 1);",
            "\t\t}",
            "\t\tfor(auto i = rank(); i < count; ++ i) if(b[i]) return {};",
            "\t\tvector<V> res({0});",
            "\t\tV is_free = ~(V)0;",
            "\t\tfor(auto i = 0; i < rank(); ++ i){",
            "\t\t\tres[0] |= (V)b[i] << pivot[i];",
            "\t\t\tis_free ^= (V)1 << pivot[i];",
            "\t\t}",
            "\t\tif(!construct_solution) return res;",
            "\t\tfor(auto j = 0; j <= __lg(numeric_limits<V>::max()); ++ j) if(is_free >> j & 1){",
            "\t\t\tV v = (V)1 << j;",
            "\t\t\tfor(auto i = rank() - 1; i >= 0 && pivot[i] > j; -- i) v |= data[i] & (V)1 << pivot[i];",
            "\t\t\tres.push_back(v);",
            "\t\t}",
            "\t\treturn res;",
            "\t}",
            "};"
        ],
        "description": "tranxuanbach"
    }
}