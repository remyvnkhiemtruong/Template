{
    "tranxuanbach": {
        "prefix": "circle_intersection",
        "body": [
            "// Returns the list of intersection points",
            "// In case of two intersections, the direction of list[0]->list[1] is equal to the direction you get after rotating c1->c2 by pi/4",
            "template<class T>",
            "pair<int, array<point<double>, 2>> circle_intersection(const circle<T> &c1, const circle<T> &c2){",
            "\tassert(c1 != c2);",
            "\tT d_sq = squared_distance(c1.center, c2.center);",
            "\tT l = (c1.radius - c2.radius) * (c1.radius - c2.radius);",
            "\tT r = (c1.radius + c2.radius) * (c1.radius + c2.radius);",
            "\tif(d_sq < l || r < d_sq) return {};",
            "\tif(l == d_sq) return {1, {(c2.radius * point<double>(c1.center) - c1.radius * point<double>(c2.center)) / (c2.radius - c1.radius)}};",
            "\tif(r == d_sq) return {1, {(c2.radius * point<double>(c1.center) + c1.radius * point<double>(c2.center)) / (c2.radius + c1.radius)}};",
            "\tdouble d = sqrt(d_sq);",
            "\tdouble x = (c1.radius * c1.radius - c2.radius * c2.radius + d * d) / (2 * d);",
            "\tdouble y = d - x;",
            "\tdouble h = sqrt(max(0.0, c1.radius * c1.radius - x * x));",
            "\tpointd m = (y * point<double>(c1.center) + x * point<double>(c2.center)) / (x + y);",
            "\tpointd p = (c2.center - c1.center).perp().unit() * h;",
            "\treturn {2, {m - p, m + p}};",
            "}",
            "template<class T>",
            "pair<int, array<point<long double>, 2>> circle_intersectionl(const circle<T> &c1, const circle<T> &c2){",
            "\tassert(c1 != c2);",
            "\tT d_sq = squared_distance(c1.center, c2.center);",
            "\tT l = (c1.radius - c2.radius) * (c1.radius - c2.radius);",
            "\tT r = (c1.radius + c2.radius) * (c1.radius + c2.radius);",
            "\tif(d_sq < l || r < d_sq) return {};",
            "\tif(l == d_sq) return {1, {(c2.radius * point<long double>(c1.center) - c1.radius * point<long double>(c2.center)) / (c2.radius - c1.radius)}};",
            "\tif(r == d_sq) return {1, {(c2.radius * point<long double>(c1.center) + c1.radius * point<long double>(c2.center)) / (c2.radius + c1.radius)}};",
            "\tlong double d = sqrtl(d_sq);",
            "\tlong double x = (c1.radius * c1.radius - c2.radius * c2.radius + d * d) / (2 * d);",
            "\tlong double y = d - x;",
            "\tlong double h = sqrtl(max(0.0L, c1.radius * c1.radius - x * x));",
            "\tpointd m = (y * point<long double>(c1.center) + x * point<long double>(c2.center)) / (x + y);",
            "\tpointd p = (c2.center - c1.center).perp().unit() * h;",
            "\treturn {2, {m - p, m + p}};",
            "}"
        ],
        "description": "tranxuanbach"
    }
}