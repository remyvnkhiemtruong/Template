{
    "tranxuanbach": {
        "prefix": "longest_k_increasing_subsequence_nr",
        "body": [
            "// k-increasing subsequence is a subsequence that is a union of k increasing subsequences",
            "// Source: An Extension of Schensted's Theorem (Curtis Greene)",
            "// Returns a 2d array representing a partition of k-increasing subsequence of maximum length into k increasing subsequences in the given array",
            "// p must be a permutation",
            "// O(n * (k * log(n) + r)) where r is the length of the answer",
            "vector<vector<int>> longest_k_increasing_subsequence_nr(const vector<int> &p, int k){",
            "\tint n = (int)p.size();",
            "\t{ // Check if p is a permutation",
            "\t\tvector<int> flag(n);",
            "\t\tfor(auto x: p){",
            "\t\t\tassert(0 <= x && x < n && !flag[x]);",
            "\t\t\tflag[x] = true;",
            "\t\t}",
            "\t}",
            "\tvector<array<int, 3>> swaps;",
            "\tvector<vector<int>> s;",
            "\tfor(auto x: p){",
            "\t\tbool found = false;",
            "\t\tfor(auto i = 0; i < min(k, (int)s.size()); ++ i){",
            "\t\t\tint j = upper_bound(s[i].begin(), s[i].end(), x) - s[i].begin();",
            "\t\t\tif(j == (int)s[i].size()){",
            "\t\t\t\ts[i].push_back(x);",
            "\t\t\t\tfound = true;",
            "\t\t\t\tbreak;",
            "\t\t\t}",
            "\t\t\tfor(auto jj = (int)s[i].size() - 1; jj > j; -- jj) swaps.push_back({x, s[i][jj - 1], s[i][jj]});",
            "\t\t\tswap(s[i][j], x);",
            "\t\t}",
            "\t\tif(!found && (int)s.size() < k) s.emplace_back(vector<int>{x});",
            "\t}",
            "\tvector<int> next(n + 1, -1), prev(n + 1, -1);",
            "\tfor(auto i = 0; i < (int)s.size(); ++ i){",
            "\t\tprev[s[i].front()] = n;",
            "\t\tfor(auto j = 0; j < (int)s[i].size() - 1; ++ j){",
            "\t\t\tnext[s[i][j]] = s[i][j + 1];",
            "\t\t\tprev[s[i][j + 1]] = s[i][j];",
            "\t\t}",
            "\t\tnext[s[i].back()] = n;",
            "\t}",
            "\treverse(swaps.begin(), swaps.end());",
            "\tfor(auto [x, y, z]: swaps){ // yxz->yzx",
            "\t\tif(next[x] != z) continue;",
            "\t\tif(!~next[y]){",
            "\t\t\tprev[y]= prev[x], next[prev[y]] = y;",
            "\t\t\tnext[y] = z, prev[z] = y;",
            "\t\t\tprev[x] = next[x] = -1;",
            "\t\t}",
            "\t\telse{",
            "\t\t\tnext[x] = next[y], prev[next[x]] = x;",
            "\t\t\tnext[y] = z, prev[z] = y;",
            "\t\t}",
            "\t}",
            "\tvector<vector<int>> res(k);",
            "\tvector<int> seq(n, -1);",
            "\tfor(auto x = 0, it = 0; x < n; ++ x) if(~prev[x]){",
            "\t\tseq[x] = prev[x] == n ? it ++ : seq[prev[x]];",
            "\t\tres[seq[x]].push_back(x);",
            "\t}",
            "\treturn res;",
            "}"
        ],
        "description": "tranxuanbach"
    }
}