{
    "tranxuanbach": {
        "prefix": "disjoint_set_rollback",
        "body": [
            "struct disjoint_set_rollback{",
            "\tint n, _group_count;",
            "\tvector<int> p;",
            "\tvector<pair<int, int>> recover;",
            "\tdisjoint_set_rollback(int n): n(n), _group_count(n), p(n, -1){ assert(n >= 0); }",
            "\t// O(log(n))",
            "\tint root(int u){",
            "\t\treturn p[u] < 0 ? u : root(p[u]);",
            "\t}",
            "\t// O(log(n))",
            "\tbool share(int a, int b){",
            "\t\treturn root(a) == root(b);",
            "\t}",
            "\t// O(log(n))",
            "\tint size(int u){",
            "\t\treturn -p[root(u)];",
            "\t}",
            "\t// O(log(n))",
            "\tbool merge(int u, int v){",
            "\t\tu = root(u), v = root(v);",
            "\t\tif(u == v) return false;",
            "\t\t-- _group_count;",
            "\t\tif(p[u] > p[v]) swap(u, v);",
            "\t\trecover.emplace_back(v, p[v]);",
            "\t\tp[u] += p[v], p[v] = u;",
            "\t\treturn true;",
            "\t}",
            "\t// O(log(n))",
            "\tbool merge(int u, int v, auto act){",
            "\t\tu = root(u), v = root(v);",
            "\t\tif(u == v) return false;",
            "\t\t-- _group_count;",
            "\t\tbool swapped = false;",
            "\t\tif(p[u] > p[v]) swap(u, v), swapped = true;",
            "\t\tact(u, v, swapped);",
            "\t\trecover.emplace_back(v, p[v]);",
            "\t\tp[u] += p[v], p[v] = u;",
            "\t\treturn true;",
            "\t}",
            "\t// O(1)",
            "\tint group_count() const{",
            "\t\treturn _group_count;",
            "\t}",
            "\t// Log the current state into recover",
            "\tvoid refresh(int signal){",
            "\t\trecover.push_back({-1, signal});",
            "\t}",
            "\t// O(1)",
            "\tint state(){",
            "\t\treturn (int)recover.size();",
            "\t}",
            "\t// O(size(recover) - s)",
            "\tvoid reverse_to(int s){",
            "\t\tassert(s <= (int)recover.size());",
            "\t\twhile((int)recover.size() > s){",
            "\t\t\t++ _group_count;",
            "\t\t\tauto [u, su] = recover.back();",
            "\t\t\trecover.pop_back();",
            "\t\t\tp[p[u]] -= su, p[u] = su;",
            "\t\t}",
            "\t}",
            "\t// O(size(recover) - s)",
            "\t// act(-1, signal): refresh() was called with signal",
            "\t// act(u, v): u has been split from the child v",
            "\tvoid reverse_to(int s, auto act){",
            "\t\twhile((int)recover.size() > s){",
            "\t\t\tauto [u, su] = recover.back();",
            "\t\t\trecover.pop_back();",
            "\t\t\tif(!~u) act(u, su);",
            "\t\t\telse{",
            "\t\t\t\t++ _group_count;",
            "\t\t\t\tint pu = p[u];",
            "\t\t\t\tp[p[u]] -= su, p[u] = su;",
            "\t\t\t\tact(pu, u);",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "\tvoid clear(){",
            "\t\t_group_count = n;",
            "\t\tfill(p.begin(), p.end(), -1);",
            "\t\trecover.clear();",
            "\t}",
            "\tvector<vector<int>> group_up(){",
            "\t\tvector<vector<int>> g(n);",
            "\t\tfor(auto i = 0; i < n; ++ i) g[root(i)].push_back(i);",
            "\t\tg.erase(remove_if(g.begin(), g.end(), [&](auto &s){ return s.empty(); }), g.end());",
            "\t\treturn g;",
            "\t}",
            "\tfriend ostream &operator<<(ostream &out, disjoint_set_rollback dsu){",
            "\t\tauto gs = dsu.group_up();",
            "\t\tout << \"{\";",
            "\t\tif(!gs.empty()) for(auto i = 0; i < (int)gs.size(); ++ i){",
            "\t\t\tout << \"{\";",
            "\t\t\tfor(auto j = 0; j < (int)gs[i].size(); ++ j){",
            "\t\t\t\tout << gs[i][j];",
            "\t\t\t\tif(j + 1 < (int)gs[i].size()) out << \", \";",
            "\t\t\t}",
            "\t\t\tout << \"}\";",
            "\t\t\tif(i + 1 < (int)gs.size()) out << \", \";",
            "\t\t}",
            "\t\treturn out << \"}\";",
            "\t}",
            "};"
        ],
        "description": "tranxuanbach"
    }
}