{
    "tranxuanbach": {
        "prefix": "kinetic_tournament",
        "body": [
            "template<bool GET_MAX = true>",
            "struct kinetic_tournament{",
            "\tconst long long inf = numeric_limits<long long>::max();",
            "\tusing line = pair<long long, long long>;",
            "\tlong long eval(const line& ln, long long t){",
            "\t\treturn ln.first * t + ln.second;",
            "\t}",
            "\tbool cmp(const line& line1, const line& line2){",
            "\t\tauto x = eval(line1, temp), y = eval(line2, temp);",
            "\t\tif(x != y) return x < y;",
            "\t\treturn line1.first < line2.first;",
            "\t}",
            "\tlong long next_isect(const line& line1, const line& line2){",
            "\t\tif(line1.first > line2.first){",
            "\t\t\tlong long delta = eval(line2, temp) - eval(line1, temp), delta_slope = line1.first - line2.first;",
            "\t\t\tassert(delta > 0);",
            "\t\t\tlong long mint = temp + (delta - 1) / delta_slope + 1;",
            "\t\t\treturn mint > temp ? mint : inf;  // prevent overflow",
            "\t\t}",
            "\t\treturn inf;",
            "\t}",
            "\tvoid rebuild(int u, int l, int r){",
            "\t\tif(r - l == 1 || melt[u] > temp) return;",
            "\t\tint m = l + (r - l >> 1), v = u + 1, w = u + (m - l << 1);",
            "\t\trebuild(v, l, m), rebuild(w, m, r);",
            "\t\tauto line1 = tree[v], line2 = tree[w];",
            "\t\tif(!cmp(line1, line2)) swap(line1, line2);",
            "\t\ttree[u] = line1, melt[u] = min(melt[v], melt[w]);",
            "\t\tif(line1 != line2){",
            "\t\t\tlong long t = next_isect(line1, line2);",
            "\t\t\tassert(t > temp);",
            "\t\t\tmelt[u] = min(melt[u], t);",
            "\t\t}",
            "\t}",
            "\t// line[p] = L",
            "\t// O(log n)",
            "\tvoid set(int p, line L){",
            "\t\tif(GET_MAX) L = {-L.first, -L.second};",
            "\t\tauto recurse = [&](auto self, int u, int l, int r)->void{",
            "\t\t\tif(p < l || r <= p) return;",
            "\t\t\tif(r - l == 1){",
            "\t\t\t\ttree[u] = L;",
            "\t\t\t\treturn;",
            "\t\t\t}",
            "\t\t\tint m = l + (r - l >> 1);",
            "\t\t\tself(self, u + 1, l, m), self(self, u + (m - l << 1), m, r);",
            "\t\t\tmelt[u] = 0, rebuild(u, l, r);",
            "\t\t};",
            "\t\trecurse(recurse, 0, 0, n);",
            "\t}",
            "\t// Find min{ql<=i<qr}( line[i].eval(temp) )",
            "\t// O(log n)",
            "\tlong long query(int ql, int qr){",
            "\t\tauto recurse = [&](auto self, int u, int l, int r)->long long{",
            "\t\t\tif(qr <= l || r <= ql) return inf;",
            "\t\t\tif(ql <= l && r <= qr) return eval(tree[u], temp);",
            "\t\t\tint m = l + (r - l >> 1);",
            "\t\t\treturn min(self(self, u + 1, l, m), self(self, u + (m - l << 1), m, r));",
            "\t\t};",
            "\t\treturn recurse(recurse, 0, 0, n) * (GET_MAX ? -1 : 1);",
            "\t}",
            "\t// Increase temperature to new_temp",
            "\t// O(m alpha(m) log^2 n) for m sequence of operations",
            "\tvoid heaten(long long new_temp){",
            "\t\tassert(new_temp >= temp);",
            "\t\ttemp = new_temp;",
            "\t\trebuild(0, 0, n);",
            "\t}",
            "\tkinetic_tournament(int n): kinetic_tournament(vector<line>(n, {0, inf})){ }",
            "\tkinetic_tournament(vector<line> lines): n((int)lines.size()), tree(n << 1, {0, inf}), melt(n << 1, inf){",
            "\t\tif(GET_MAX) for(auto &L: lines) L = {-L.first, -L.second};",
            "\t\tauto build = [&](auto self, int u, int l, int r)->void{",
            "\t\t\tif(r - l == 1){",
            "\t\t\t\ttree[u] = lines[l];",
            "\t\t\t\treturn;",
            "\t\t\t}",
            "\t\t\tint m = l + (r - l >> 1), v = u + 1, w = u + (m - l << 1);",
            "\t\t\tself(self, v, l, m), self(self, w, m, r);",
            "\t\t\tauto line1 = tree[v], line2 = tree[w];",
            "\t\t\tif(!cmp(line1, line2)) swap(line1, line2);",
            "\t\t\ttree[u] = line1, melt[u] = min(melt[v], melt[w]);",
            "\t\t\tif(line1 != line2){",
            "\t\t\t\tlong long t = next_isect(line1, line2);",
            "\t\t\t\tassert(t > temp);",
            "\t\t\t\tmelt[u] = min(melt[u], t);",
            "\t\t\t}",
            "\t\t};",
            "\t\tbuild(build, 0, 0, n);",
            "\t}",
            "\tint n; // size",
            "\tlong long temp = 0; // current temperature",
            "\tvector<line> tree; // tournament tree",
            "\tvector<long long> melt; // melting temperature of each subtree",
            "};"
        ],
        "description": "tranxuanbach"
    }
}