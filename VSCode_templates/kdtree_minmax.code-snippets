{
    "tranxuanbach": {
        "prefix": "kdtree_minmax",
        "body": [
            "// Requires point",
            "template<class T>",
            "struct kdtree_minmax{",
            "\tstruct node{ // represents a box [xlow, xhigh] * [ylow, yhigh]",
            "\t\tint id = -1; // if this is a leaf, the single point in it",
            "\t\tT xlow = numeric_limits<T>::max();",
            "\t\tT xhigh = numeric_limits<T>::min();",
            "\t\tT ylow = numeric_limits<T>::max();",
            "\t\tT yhigh = numeric_limits<T>::min();",
            "\t\tnode *left = 0, *right = 0;",
            "\t\tnode(vector<int> ind, const vector<point<T>> &a){",
            "\t\t\tfor(auto i: ind){",
            "\t\t\t\tconst auto &p = a[i];",
            "\t\t\t\txlow = min(xlow, p.x), xhigh = max(xhigh, p.x);",
            "\t\t\t\tylow = min(ylow, p.y), yhigh = max(yhigh, p.y);",
            "\t\t\t}",
            "\t\t\tif((int)ind.size() >= 2){",
            "\t\t\t\tif(xhigh - xlow >= yhigh - ylow) sort(ind.begin(), ind.end(), [&](int i, int j){ return a[i].x < a[j].x; });",
            "\t\t\t\telse sort(ind.begin(), ind.end(), [&](int i, int j){ return a[i].y < a[j].y; });",
            "\t\t\t\tint half = (int)ind.size() >> 1;",
            "\t\t\t\tleft = new node({ind.begin(), ind.begin() + half}, a);",
            "\t\t\t\tright = new node({ind.begin() + half, ind.end()}, a);",
            "\t\t\t}",
            "\t\t\telse id = ind[0];",
            "\t\t}",
            "\t\t~node(){",
            "\t\t\tdelete left, delete right;",
            "\t\t}",
            "\t\tT distance(const point<T> &p){ // min squared dist from the box to point p",
            "\t\t\tT x = min(max(p.x, xlow), xhigh), y = min(max(p.y, ylow), yhigh); ",
            "\t\t\treturn (x - p.x) * (x - p.x) + (y - p.y) * (y - p.y);",
            "\t\t}",
            "\t};",
            "\tnode *root = NULL;",
            "\tvector<point<T>> a;",
            "\tkdtree_minmax(){ }",
            "\tkdtree_minmax(const vector<point<T>> &a): a(a){",
            "\t\tvector<int> ind((int)a.size());",
            "\t\tiota(ind.begin(), ind.end(), 0);",
            "\t\troot = new node(ind, a);",
            "\t}",
            "\t~kdtree_minmax(){",
            "\t\tdelete root;",
            "\t}",
            "\t// returns {squared_distance, nearest point}",
            "\t// O(log(n)) on average for randomly distributed points",
            "\ttemplate<bool IGNORE_ITSELF = false>",
            "\tpair<T, int> nearest(const point<T> &p){",
            "\t\tauto search = [&](node *u, auto search)->pair<T, int>{",
            "\t\t\tif(!u->left){",
            "\t\t\t\tif(IGNORE_ITSELF && p == a[u->id]) return {numeric_limits<T>::max(), -1};",
            "\t\t\t\telse return {squared_distance(p, a[u->id]), u->id};",
            "\t\t\t}",
            "\t\t\tnode *left = u->left, *right = u->right;",
            "\t\t\tT bl = left->distance(p), br = right->distance(p);",
            "\t\t\tif(bl > br) swap(br, bl), swap(left, right);",
            "\t\t\tauto best = search(left, search); // search closest side, other side if needed",
            "\t\t\tif(br < best.first) best = min(best, search(right, search));",
            "\t\t\treturn best;",
            "\t\t};",
            "\t\treturn search(root, search);",
            "\t}",
            "\t// O(n^(1-1/dim) + m) where m is the number of reported points",
            "\tvector<int> points_within(T xlow, T xhigh, T ylow, T yhigh){",
            "\t\tauto search = [&](node *u, auto search)->vector<int>{",
            "\t\t\tif(!u || xhigh < u->xlow || u->xhigh < xlow || yhigh < u->ylow || u->yhigh < ylow) return {};",
            "\t\t\tif(!u->left) return {u->id};",
            "\t\t\tauto left = search(u->left, search), right = search(u->right, search);",
            "\t\t\tif((int)left.size() < (int)right.size()) swap(left, right);",
            "\t\t\tleft.insert(left.end(), right.begin(), right.end());",
            "\t\t\treturn left;",
            "\t\t};",
            "\t\treturn search(root, search);",
            "\t}",
            "};"
        ],
        "description": "tranxuanbach"
    }
}