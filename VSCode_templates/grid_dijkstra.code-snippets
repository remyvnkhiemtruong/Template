{
    "tranxuanbach": {
        "prefix": "grid_dijkstra",
        "body": [
            "template<class T>",
            "struct grid_dijkstra{",
            "\tint n, nr;",
            "\tvector<int> ncs;",
            "\tvector<vector<int>> index;",
            "\tvector<array<int, 2>> locate;",
            "\tvector<array<int, 2>> dr = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};",
            "\tvector<T> dist;",
            "\tvector<int> pv;",
            "\tvector<int> order;",
            "\tvector<int> pos;",
            "\tvector<int> root_of;",
            "\tvector<int> root;",
            "\tvector<int> depth;",
            "\tvector<int> was;",
            "\tvoid init(int nr, int nc){",
            "\t\tassert(0 <= nr && 0 <= nc);",
            "\t\tinit(nr, vector(nr, nc));",
            "\t}",
            "\tvoid init(int nr, const vector<int> &ncs){",
            "\t\tassert(nr == (int)ncs.size());",
            "\t\tthis->n = accumulate(ncs.begin(), ncs.end(), 0);",
            "\t\tthis->nr = nr;",
            "\t\tthis->ncs = ncs;",
            "\t\tindex.assign(nr, {});",
            "\t\tfor(auto x = 0; x < nr; ++ x){",
            "\t\t\tint nc = ncs[x];",
            "\t\t\tassert(0 <= nc);",
            "\t\t\tindex[x].assign(nc, -1);",
            "\t\t\tfor(auto y = 0; y < nc; ++ y){",
            "\t\t\t\tindex[x][y] = (int)locate.size();",
            "\t\t\t\tlocate.push_back({x, y});",
            "\t\t\t}",
            "\t\t}",
            "\t\tdist.assign(n, T{});",
            "\t\tpv.assign(n, -1);",
            "\t\torder.clear();",
            "\t\tpos.assign(n, -1);",
            "\t\troot_of.assign(n, -1);",
            "\t\troot.clear();",
            "\t\tdepth.assign(n, -1);",
            "\t\twas.assign(n, -2);",
            "\t\tattempt = -1;",
            "\t}",
            "\tvoid init_dr(const vector<array<int, 2>> &dr){",
            "\t\tthis->dr = dr;",
            "\t}",
            "\tvoid init_dr_8(){",
            "\t\tthis->dr = {{1, 0}, {1, 1}, {0, 1}, {-1, 1}, {-1, 0}, {-1, -1}, {0, -1}, {1, -1}};",
            "\t}",
            "\tvoid init_dr_diag(){",
            "\t\tthis->dr = {{1, 1}, {-1, 1}, {-1, -1}, {1, -1}};",
            "\t}",
            "\tint attempt;",
            "\tpriority_queue<pair<T, int>, vector<pair<T, int>>, greater<pair<T, int>>> pq;",
            "\t// O((# of reachable cells) * size(dr) * log((# of reachable cells) * size(dir)))",
            "\ttemplate<class Container, class Weight>",
            "\tvoid _run(const vector<Container> &grid, const vector<vector<Weight>> &cell_weight, const vector<int> &src){",
            "\t\tfor(auto u: src){",
            "\t\t\tif(was[u] == attempt) continue;",
            "\t\t\twas[u] = attempt;",
            "\t\t\tpq.push({dist[u] = cell_weight[locate[u][0]][locate[u][1]], u});",
            "\t\t\tdepth[u] = 0;",
            "\t\t\troot_of[u] = u;",
            "\t\t\troot.push_back(u);",
            "\t\t\tpv[u] = -1;",
            "\t\t}",
            "\t\twhile(!pq.empty()){",
            "\t\t\tauto [d, u] = pq.top();",
            "\t\t\tpq.pop();",
            "\t\t\tif(d != dist[u]) continue;",
            "\t\t\tpos[u] = (int)order.size();",
            "\t\t\torder.push_back(u);",
            "\t\t\tauto [x, y] = locate[u];",
            "\t\t\tfor(auto [dx, dy]: dr){",
            "\t\t\t\tint xn = x + dx, yn = y + dy;",
            "\t\t\t\tif(!(0 <= xn && xn < (int)grid.size() && 0 <= yn && yn <= (int)grid[xn].size()) || grid[x][y] != grid[xn][yn]) continue;",
            "\t\t\t\tint v = index[xn][yn];",
            "\t\t\t\tif(was[v] != attempt || dist[u] + cell_weight[xn][yn] < dist[v]){",
            "\t\t\t\t\twas[v] = attempt;",
            "\t\t\t\t\tdepth[v] = depth[u] + 1;",
            "\t\t\t\t\tpv[v] = u;",
            "\t\t\t\t\troot_of[v] = root_of[u];",
            "\t\t\t\t\tpq.push({dist[v] = dist[u] + cell_weight[xn][yn], v});",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "\t// O((# of reachable cells) * size(dr) * log((# of reachable cells) * size(dir)))",
            "\ttemplate<class Container, class Weight>",
            "\tvoid run(const vector<Container> &grid, const vector<vector<Weight>> &cell_weight, const vector<array<int, 2>> &src){",
            "\t\tassert((int)grid.size() <= nr && (int)grid.size() == (int)cell_weight.size());",
            "\t\tfor(auto x = 0; x < nr; ++ x){",
            "\t\t\tassert((int)grid[x].size() <= ncs[x] && (int)grid[x].size() == (int)cell_weight[x].size());",
            "\t\t\tfor(auto y = 0; y < (int)grid[x].size(); ++ y) assert(0 <= cell_weight[x][y]);",
            "\t\t}",
            "\t\troot.clear(), order.clear();",
            "\t\t++ attempt;",
            "\t\tvector<int> src_index((int)src.size());",
            "\t\tfor(auto i = 0; i < (int)src.size(); ++ i){",
            "\t\t\tauto [x, y] = src[i];",
            "\t\t\tassert(0 <= x && x < (int)grid.size());",
            "\t\t\tassert(0 <= y && y < (int)grid[x].size());",
            "\t\t\tsrc_index[i] = index[x][y];",
            "\t\t}",
            "\t\t_run(grid, cell_weight, src_index);",
            "\t}",
            "\t// Check if (x, y) is visited during the last dijkstra-like call.",
            "\tbool visited(int x, int y) const{",
            "\t\treturn was[index[x][y]] == attempt;",
            "\t}",
            "\t// Check if u is visited during the last dijkstra-like call.",
            "\tbool visited(int u) const{",
            "\t\treturn was[u] == attempt;",
            "\t}",
            "};"
        ],
        "description": "tranxuanbach"
    }
}