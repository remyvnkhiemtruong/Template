{
    "tranxuanbach": {
        "prefix": "functional_graph_processor",
        "body": [
            "struct functional_graph_processor{",
            "\tfunctional_graph_processor(){ }",
            "\tfunctional_graph_processor(const vector<int> &next){",
            "\t\tinit((int)next.size());",
            "\t\tbuild(next);",
            "\t}",
            "\ttemplate<class Graph_t>",
            "\tfunctional_graph_processor(const Graph_t &g){",
            "\t\tinit(g.n);",
            "\t\tbuild(g);",
            "\t}",
            "\tvoid init(int n){",
            "\t\tthis->n = n;",
            "\t\tcycle_id.assign(n, -1);",
            "\t\tcycle_pos.assign(n, -1);",
            "\t\tcycle_prev.assign(n, -1);",
            "\t\tcomponent_size.assign(n, -1);",
            "\t\troot_of.assign(n, -1);",
            "\t\tdepth.assign(n, -1);",
            "\t\torder.clear();",
            "\t\tpos.assign(n, -1);",
            "\t\tend.assign(n, -1);",
            "\t\tsize.assign(n, -1);",
            "\t\tabr.assign(n, {});",
            "\t\twas.assign(n, -2);",
            "\t\twas2.assign(n, -2);",
            "\t\tattempt = -1;",
            "\t}",
            "\tint attempt;",
            "\tvector<int> was, was2;",
            "\tvoid build(const vector<int> &next){",
            "\t\tfill(cycle_id.begin(), cycle_id.end(), -1);",
            "\t\tfill(cycle_pos.begin(), cycle_pos.end(), -1);",
            "\t\tfill(cycle_prev.begin(), cycle_prev.end(), -1);",
            "\t\t++ attempt;",
            "\t\tfor(auto u = 0; u < n; ++ u){",
            "\t\t\tif(was[u] == attempt) continue;",
            "\t\t\tint v = u;",
            "\t\t\twhile(was[v] != attempt){",
            "\t\t\t\twas[v] = attempt;",
            "\t\t\t\tv = next[v];",
            "\t\t\t}",
            "\t\t\tif(was2[v] != attempt){",
            "\t\t\t\tint w = v;",
            "\t\t\t\tvector<int> c;",
            "\t\t\t\twhile(was2[w] != attempt){",
            "\t\t\t\t\twas2[w] = attempt;",
            "\t\t\t\t\tcycle_id[w] = (int)cycle.size();",
            "\t\t\t\t\tcycle_pos[w] = (int)c.size();",
            "\t\t\t\t\tc.push_back(w);",
            "\t\t\t\t\troot_of[w] = w;",
            "\t\t\t\t\tdepth[w] = 0;",
            "\t\t\t\t\tw = next[w];",
            "\t\t\t\t}",
            "\t\t\t\tcycle.push_back(c);",
            "\t\t\t}",
            "\t\t\tauto dfs = [&](auto self, int u)->void{",
            "\t\t\t\tif(was2[u] == attempt) return;",
            "\t\t\t\twas2[u] = attempt;",
            "\t\t\t\tint v = next[u];",
            "\t\t\t\tself(self, v);",
            "\t\t\t\troot_of[u] = root_of[v];",
            "\t\t\t\tdepth[u] = depth[v] + 1;",
            "\t\t\t\tabr[v].push_back(u);",
            "\t\t\t};",
            "\t\t\tdfs(dfs, u);",
            "\t\t}",
            "\t\tfor(auto u = 0; u < n; ++ u) if(~cycle_pos[u]) cycle_prev[next[u]] = u;",
            "\t\tfor(auto c: cycle){",
            "\t\t\tauto dfs = [&](auto self, int u)->void{",
            "\t\t\t\tsize[u] = 1;",
            "\t\t\t\tpos[u] = (int)order.size();",
            "\t\t\t\torder.push_back(u);",
            "\t\t\t\tfor(auto v: abr[u]){",
            "\t\t\t\t\tself(self, v);",
            "\t\t\t\t\tsize[u] += size[v];",
            "\t\t\t\t}",
            "\t\t\t\tend[u] = (int)order.size();",
            "\t\t\t};",
            "\t\t\tint csize = 0;",
            "\t\t\tfor(auto u: c){",
            "\t\t\t\tdfs(dfs, u);",
            "\t\t\t\tcsize += size[u];",
            "\t\t\t}",
            "\t\t\tfor(auto u: c) for(auto i = pos[u]; i < end[u]; ++ i){",
            "\t\t\t\tint v = order[i];",
            "\t\t\t\tcomponent_size[v] = csize;",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "\t// Requires graph",
            "\ttemplate<class Graph>",
            "\tvoid build(const Graph &g){",
            "\t\tint n = g.n;",
            "\t\tassert(n == (int)g.edge.size());",
            "\t\tvector<int> pv(n, -1), state(n), on_cycle(n);",
            "\t\tvector<vector<int>> cycle;",
            "\t\tauto dfs = [&](auto self, int u, int p)->void{",
            "\t\t\tstate[u] = 1;",
            "\t\t\tfor(auto id: g.adj[u]){",
            "\t\t\t\tif(g.ignore && g.ignore(id)) continue;",
            "\t\t\t\tauto &e = g.edge[id];",
            "\t\t\t\tint v = g(u, id);",
            "\t\t\t\tif(v == p) continue;",
            "\t\t\t\tif(state[v] == 1){",
            "\t\t\t\t\tcycle.emplace_back();",
            "\t\t\t\t\tfor(auto w = u; w != v; w = pv[w]){",
            "\t\t\t\t\t\tcycle.back().push_back(w);",
            "\t\t\t\t\t\ton_cycle[w] = true;",
            "\t\t\t\t\t}",
            "\t\t\t\t\tcycle.back().push_back(v);",
            "\t\t\t\t\ton_cycle[v] = true;",
            "\t\t\t\t}",
            "\t\t\t\telse if(state[v] == 0){",
            "\t\t\t\t\tpv[v] = u;",
            "\t\t\t\t\tself(self, v, u);",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t\tstate[u] = 2;",
            "\t\t};",
            "\t\tfor(auto u = 0; u < n; ++ u){",
            "\t\t\tif(state[u] != 2){",
            "\t\t\t\tassert(state[u] == 0);",
            "\t\t\t\tdfs(dfs, u, -1);",
            "\t\t\t}",
            "\t\t}",
            "\t\tvector<int> next(n, -1);",
            "\t\tauto dfs2 = [&](auto self, int u, int p)->void{",
            "\t\t\tfor(auto id: g.adj[u]){",
            "\t\t\t\tif(g.ignore && g.ignore(id)) continue;",
            "\t\t\t\tauto &e = g.edge[id];",
            "\t\t\t\tint v = g(u, id);",
            "\t\t\t\tif(v == p || on_cycle[v]) continue;",
            "\t\t\t\tnext[v] = u;",
            "\t\t\t\tself(self, v, u);",
            "\t\t\t}",
            "\t\t};",
            "\t\tfor(auto &c: cycle){",
            "\t\t\tfor(auto i = 0; i < (int)c.size(); ++ i) next[c[i]] = c[(i + 1) % (int)c.size()];",
            "\t\t\tfor(auto u: c) dfs2(dfs2, u, -1);",
            "\t\t}",
            "\t\tbuild(next);",
            "\t}",
            "\tfriend ostream &operator<<(ostream &out, const functional_graph_processor &fgp){",
            "\t\tout << \"\\nCycles: {\\n\";",
            "\t\tfor(auto i = 0; i < (int)fgp.cycle.size(); ++ i){",
            "\t\t\tout << \" {\";",
            "\t\t\tfor(auto j = 0; j < (int)fgp.cycle[i].size(); ++ j){",
            "\t\t\t\tout << fgp.cycle[i][j];",
            "\t\t\t\tif(j + 1 < (int)fgp.cycle[i].size()) out << \", \";",
            "\t\t\t}",
            "\t\t\tout << \"}\";",
            "\t\t\tif(i + 1 < (int)fgp.cycle.size()) out << \",\";",
            "\t\t\tout << \"\\n\";",
            "\t\t}",
            "\t\tout << \"}\\n\";",
            "\t\tout << \"Abr: {\\n\";",
            "\t\tfor(auto u = 0; u < (int)fgp.abr.size(); ++ u){",
            "\t\t\tout << u << \": {\";",
            "\t\t\tfor(auto i = 0; i < (int)fgp.abr[u].size(); ++ i){",
            "\t\t\t\tout << fgp.abr[u][i];",
            "\t\t\t\tif(i + 1 < (int)fgp.abr[u].size()) out << \", \";",
            "\t\t\t}",
            "\t\t\tout << \"}\";",
            "\t\t\tif(u + 1 < (int)fgp.abr.size()) out << \",\";",
            "\t\t\tout << \"\\n\";",
            "\t\t}",
            "\t\tout << \"}\\n\";",
            "\t\tout << \"Order: {\";",
            "\t\tfor(auto i = 0; i < (int)fgp.order.size(); ++ i){",
            "\t\t\tout << fgp.order[i];",
            "\t\t\tif(i + 1 < (int)fgp.order.size()) out << \", \";",
            "\t\t}",
            "\t\tout << \"}\\n\";",
            "\t\treturn out;",
            "\t}",
            "\tint n;",
            "\tvector<vector<int>> cycle;",
            "\tvector<int> cycle_id; // id of the cycle it belongs to, -1 if not part of one",
            "\tvector<int> cycle_pos; // position in its cycle, -1 if not part of one",
            "\tvector<int> cycle_prev; // previous vertex in its cycle, -1 if not part of one",
            "\tvector<int> component_size; // size of its weakly connected component",
            "\tvector<int> root_of; // first reachable node in a cycle",
            "\tvector<int> depth; // distance to its root",
            "\tvector<vector<int>> abr; // forest of arborescences of reversed edges not on the cycles",
            "\tvector<int> order; // dfs order of abr",
            "\tvector<int> pos; // pos in the dfs order",
            "\tvector<int> end; // [pos[u], end[u]) denotes the subtree",
            "\tvector<int> size; // size of the subtree in abr",
            "};"
        ],
        "description": "tranxuanbach"
    }
}