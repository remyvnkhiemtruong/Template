{
    "tranxuanbach": {
        "prefix": "longest_k_increasing_subsequence_nklogn_nk2",
        "body": [
            "// k-increasing subsequence is a subsequence that is a union of k increasing subsequences",
            "// Source: MIPT-2015 ACM-ICPC Workshop Round 1 Problem E Solution",
            "// Returns a 2d array representing a partition of k-increasing subsequence of maximum length into k increasing subsequences in the given array",
            "// p must be a permutation",
            "// O(n * (k * log(n) + k^2))",
            "vector<vector<int>> longest_k_increasing_subsequence_nklogn_nk2(const vector<int> &p, int k){",
            "\tint n = (int)p.size();",
            "\t{ // Check if p is a permutation",
            "\t\tvector<int> flag(n);",
            "\t\tfor(auto x: p){",
            "\t\t\tassert(0 <= x && x < n && !flag[x]);",
            "\t\t\tflag[x] = true;",
            "\t\t}",
            "\t}",
            "\tvector<vector<int>> s(k);",
            "\tvector<int> final_level(n, -1), final_value(n, -1);",
            "\tfor(auto ind = 0; ind < n; ++ ind){",
            "\t\tint x = p[ind];",
            "\t\tbool found = false;",
            "\t\tfor(auto i = 0; i < k; ++ i){",
            "\t\t\tint j = upper_bound(s[i].begin(), s[i].end(), x) - s[i].begin();",
            "\t\t\tif(j == (int)s[i].size()){",
            "\t\t\t\tfinal_level[ind] = i;",
            "\t\t\t\tfinal_value[ind] = x;",
            "\t\t\t\ts[i].push_back(x);",
            "\t\t\t\tfound = true;",
            "\t\t\t\tbreak;",
            "\t\t\t}",
            "\t\t\tswap(s[i][j], x);",
            "\t\t}",
            "\t\tif(!found){",
            "\t\t\tfinal_level[ind] = k;",
            "\t\t\tfinal_value[ind] = x;",
            "\t\t}",
            "\t}",
            "\tvector<vector<int>> from(k, vector<int>(k));",
            "\tvector<vector<int>> to(k, vector<int>(k));",
            "\tvector<vector<int>> res(k);",
            "\tfor(auto i = 0; i < k; ++ i){",
            "\t\tint size = (int)s[i].size();",
            "\t\tto[i][i] = size;",
            "\t\tfill(from[i].begin() + i + 1, from[i].end(), size);",
            "\t\tfill(to[i].begin() + i + 1, to[i].end(), size);",
            "\t}",
            "\tfor(auto ind = n - 1; ind >= 0; -- ind){",
            "\t\tint i = final_level[ind], x = final_value[ind], seq = k;",
            "\t\tif(i < k){",
            "\t\t\tseq = 0;",
            "\t\t\twhile(seq < k && (to[i][seq] < (int)s[i].size() || (int)s[i].size() <= from[i][seq])) ++ seq;",
            "\t\t\ts[i].pop_back();",
            "\t\t\tint size = (int)s[i].size();",
            "\t\t\tfor(auto j = 0; j < k; ++ j){",
            "\t\t\t\tfrom[i][j] = min(from[i][j], size);",
            "\t\t\t\tto[i][j] = min(to[i][j], size);",
            "\t\t\t}",
            "\t\t}",
            "\t\twhile(i){",
            "\t\t\t-- i;",
            "\t\t\tint pos = lower_bound(s[i].begin(), s[i].end(), x) - s[i].begin() - 1, y = s[i][pos], seq2 = 0;",
            "\t\t\twhile(seq2 < k && (to[i][seq2] <= pos || pos < from[i][seq2])) ++ seq2;",
            "\t\t\tif(seq < k && seq2 == k){",
            "\t\t\t\tif(from[i][seq] == to[i][seq]){",
            "\t\t\t\t\tfrom[i][seq] = pos;",
            "\t\t\t\t\tto[i][seq] = pos + 1;",
            "\t\t\t\t}",
            "\t\t\t\telse{",
            "\t\t\t\t\tassert(from[i][seq] > pos);",
            "\t\t\t\t\tfor(auto j = 0; j < k; ++ j){",
            "\t\t\t\t\t\tif(pos < from[i][j] && to[i][j] <= from[i][seq]){",
            "\t\t\t\t\t\t\tfrom[i][j] = pos;",
            "\t\t\t\t\t\t\tto[i][j] = pos;",
            "\t\t\t\t\t\t}",
            "\t\t\t\t\t}",
            "\t\t\t\t\tfrom[i][seq] = pos;",
            "\t\t\t\t}",
            "\t\t\t\tseq = k;",
            "\t\t\t}",
            "\t\t\telse if(seq == k && seq2 < k){",
            "\t\t\t\tif(pos + 1 < to[i][seq2]) seq = k;",
            "\t\t\t\telse{",
            "\t\t\t\t\t-- to[i][seq2];",
            "\t\t\t\t\tseq = seq2;",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t\telse if(seq < k && seq2 < k){",
            "\t\t\t\tif(from[i][seq] < to[i][seq]){",
            "\t\t\t\t\tassert(to[i][seq2] <= from[i][seq]);",
            "\t\t\t\t\tfor(auto j = 0; j < k; ++ j){",
            "\t\t\t\t\t\tif(to[i][seq2] <= from[i][j] && to[i][j] <= from[i][seq]){",
            "\t\t\t\t\t\t\tfrom[i][j] = pos;",
            "\t\t\t\t\t\t\tto[i][j] = pos;",
            "\t\t\t\t\t\t}",
            "\t\t\t\t\t}",
            "\t\t\t\t\tfrom[i][seq] = pos;",
            "\t\t\t\t\tto[i][seq2] = pos;",
            "\t\t\t\t\tseq = seq2;",
            "\t\t\t\t}",
            "\t\t\t\telse{",
            "\t\t\t\t\tif(pos + 1 < to[i][seq2]){",
            "\t\t\t\t\t\tfrom[i][seq] = pos;",
            "\t\t\t\t\t\tto[i][seq] = to[i][seq2];",
            "\t\t\t\t\t\tfor(auto j = i - 1; j >= 0; -- j){",
            "\t\t\t\t\t\t\tswap(from[j][seq], from[j][seq2]);",
            "\t\t\t\t\t\t\tswap(to[j][seq], to[j][seq2]);",
            "\t\t\t\t\t\t}",
            "\t\t\t\t\t\tswap(res[seq], res[seq2]);",
            "\t\t\t\t\t\tto[i][seq2] = pos;",
            "\t\t\t\t\t\tseq = seq2;",
            "\t\t\t\t\t}",
            "\t\t\t\t\telse{",
            "\t\t\t\t\t\tfrom[i][seq] = pos;",
            "\t\t\t\t\t\tto[i][seq] = pos + 1;",
            "\t\t\t\t\t\t-- to[i][seq2];",
            "\t\t\t\t\t\tseq = seq2;",
            "\t\t\t\t\t}",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t\ts[i][pos] = x;",
            "\t\t\tx = y;",
            "\t\t}",
            "\t\tassert(x == p[ind]);",
            "\t\tif(seq < k){",
            "\t\t\tif(!res[seq].empty()) assert(x < res[seq].back());",
            "\t\t\tres[seq].push_back(x);",
            "\t\t}",
            "\t}",
            "\tfor(auto i = 0; i < k; ++ i) reverse(res[i].begin(), res[i].end());",
            "\treturn res;",
            "}"
        ],
        "description": "tranxuanbach"
    }
}