{
    "tranxuanbach": {
        "prefix": "dial",
        "body": [
            "// Requires graph",
            "struct dial{",
            "\tint n, base_dist;",
            "\tvector<int> dist;",
            "\tvector<int> pv;",
            "\tvector<int> pe;",
            "\tvector<int> order;",
            "\tvector<int> pos;",
            "\tvector<int> root_of;",
            "\tvector<int> root;",
            "\tvector<int> depth;",
            "\tvector<int> was;",
            "\tdial(int base_dist = 0): base_dist(base_dist){ }",
            "\tvoid init(int n){",
            "\t\tthis->n = n;",
            "\t\tdist.assign(n, base_dist);",
            "\t\tpv.assign(n, -1);",
            "\t\tpe.assign(n, -1);",
            "\t\torder.clear();",
            "\t\tpos.assign(n, -1);",
            "\t\troot_of.assign(n, -1);",
            "\t\troot.clear();",
            "\t\tdepth.assign(n, -1);",
            "\t\twas.assign(n, -2);",
            "\t\tattempt = -1;",
            "\t}",
            "\tint attempt;",
            "\t// Edge weights must be integers in range [0, C)",
            "\t// O(|E| + min(|V| * C, (sum of edge weights))) where",
            "\t// V is the set of vertices reachable from src and",
            "\t// E is the set of edges reachable from src",
            "\ttemplate<class Graph>",
            "\tvoid _run(const Graph &g, int C, const vector<int> &src){",
            "\t\tint it = 0;",
            "\t\tvector<vector<array<int, 2>>> dq(C);",
            "\t\tvector<int> beg(C);",
            "\t\tfor(auto u: src){",
            "\t\t\tif(was[u] == attempt) continue;",
            "\t\t\twas[u] = attempt;",
            "\t\t\tdq[it].push_back({dist[u] = base_dist, u});",
            "\t\t\tdepth[u] = 0;",
            "\t\t\troot_of[u] = u;",
            "\t\t\troot.push_back(u);",
            "\t\t\tpv[u] = -1;",
            "\t\t\tpe[u] = -1;",
            "\t\t}",
            "\t\twhile(true){",
            "\t\t\tfor(auto th = C; th && beg[it] == (int)dq[it].size(); -- th) it = (it + 1) % C;",
            "\t\t\tif(beg[it] == (int)dq[it].size()) break;",
            "\t\t\tauto [d, u] = dq[it][beg[it] ++];",
            "\t\t\tif(d != dist[u]) continue;",
            "\t\t\tfor(auto id: g.adj[u]){",
            "\t\t\t\tif(g.ignore && g.ignore(id)) continue;",
            "\t\t\t\tauto &e = g.edge[id];",
            "\t\t\t\tassert(0 <= e.cost && e.cost < C);",
            "\t\t\t\tint v = g(u, id);",
            "\t\t\t\tif(was[v] != attempt || d + e.cost < dist[v]){",
            "\t\t\t\t\twas[v] = attempt;",
            "\t\t\t\t\tdepth[v] = depth[u] + 1;",
            "\t\t\t\t\tpv[v] = u;",
            "\t\t\t\t\tpe[v] = id;",
            "\t\t\t\t\troot_of[v] = root_of[u];",
            "\t\t\t\t\tdq[(d + e.cost) % C].push_back({dist[v] = d + e.cost, v});",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "\ttemplate<class Graph>",
            "\tvoid run(const Graph &g, int C, const vector<int> &src){",
            "\t\tassert(g.n <= n);",
            "\t\tfor(auto u: src) assert(0 <= u && u < g.n);",
            "\t\troot.clear(), order.clear();",
            "\t\t++ attempt;",
            "\t\t_run(g, C, src);",
            "\t}",
            "\t// Check if u is visited during the last dial-like call.",
            "\tbool visited(int u) const{",
            "\t\treturn was[u] == attempt;",
            "\t}",
            "};"
        ],
        "description": "tranxuanbach"
    }
}