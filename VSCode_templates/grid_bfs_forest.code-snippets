{
    "tranxuanbach": {
        "prefix": "grid_bfs_forest",
        "body": [
            "struct grid_bfs_forest{",
            "\tint n, nr;",
            "\tvector<int> ncs;",
            "\tvector<vector<int>> index;",
            "\tvector<array<int, 2>> locate;",
            "\tvector<array<int, 2>> dr = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};",
            "\tvector<int> pv;",
            "\tvector<int> order;",
            "\tvector<int> pos;",
            "\tvector<int> root_of;",
            "\tvector<int> root;",
            "\tvector<int> depth;",
            "\tvector<int> was;",
            "\tvoid init(int nr, int nc){",
            "\t\tassert(0 <= nr && 0 <= nc);",
            "\t\tinit(nr, vector(nr, nc));",
            "\t}",
            "\tvoid init(int nr, const vector<int> &ncs){",
            "\t\tassert(nr == (int)ncs.size());",
            "\t\tthis->n = accumulate(ncs.begin(), ncs.end(), 0);",
            "\t\tthis->nr = nr;",
            "\t\tthis->ncs = ncs;",
            "\t\tlocate.clear();",
            "\t\tindex.assign(nr, {});",
            "\t\tfor(auto x = 0; x < nr; ++ x){",
            "\t\t\tint nc = ncs[x];",
            "\t\t\tassert(0 <= nc);",
            "\t\t\tindex[x].assign(nc, -1);",
            "\t\t\tfor(auto y = 0; y < nc; ++ y){",
            "\t\t\t\tindex[x][y] = (int)locate.size();",
            "\t\t\t\tlocate.push_back({x, y});",
            "\t\t\t}",
            "\t\t}",
            "\t\tpv.assign(n, -1);",
            "\t\torder.clear();",
            "\t\tpos.assign(n, -1);",
            "\t\troot_of.assign(n, -1);",
            "\t\troot.clear();",
            "\t\tdepth.assign(n, -1);",
            "\t\twas.assign(n, -2);",
            "\t\tattempt = -1;",
            "\t}",
            "\tvoid init_dr(const vector<array<int, 2>> &dr){",
            "\t\tthis->dr = dr;",
            "\t}",
            "\tvoid init_dr_8(){",
            "\t\tthis->dr = {{1, 0}, {1, 1}, {0, 1}, {-1, 1}, {-1, 0}, {-1, -1}, {0, -1}, {1, -1}};",
            "\t}",
            "\tvoid init_dr_diag(){",
            "\t\tthis->dr = {{1, 1}, {-1, 1}, {-1, -1}, {1, -1}};",
            "\t}",
            "\tint attempt;",
            "\tvector<int> q;",
            "\t// O((# of cells reachable from src) * size(dr))",
            "\ttemplate<class Container>",
            "\tvoid _bfs(const vector<Container> &grid, const vector<int> &src){",
            "\t\tq = src;",
            "\t\tfor(auto u: src){",
            "\t\t\tassert(was[u] != attempt);",
            "\t\t\twas[u] = attempt;",
            "\t\t\tdepth[u] = 0;",
            "\t\t\troot_of[u] = u;",
            "\t\t\troot.push_back(u);",
            "\t\t\tpv[u] = -1;",
            "\t\t}",
            "\t\tfor(auto it = 0; it < (int)q.size(); ++ it){",
            "\t\t\tint u = q[it];",
            "\t\t\tauto [x, y] = locate[u];",
            "\t\t\tpos[u] = (int)order.size();",
            "\t\t\torder.push_back(u);",
            "\t\t\tfor(auto [dx, dy]: dr){",
            "\t\t\t\tint xn = x + dx, yn = y + dy;",
            "\t\t\t\tif(!(0 <= xn && xn < (int)grid.size() && 0 <= yn && yn < (int)grid[x].size()) || grid[x][y] != grid[xn][yn]) continue;",
            "\t\t\t\tint v = index[xn][yn];",
            "\t\t\t\tif(was[v] == attempt) continue;",
            "\t\t\t\twas[v] = attempt;",
            "\t\t\t\tdepth[v] = depth[u] + 1;",
            "\t\t\t\tpv[v] = u;",
            "\t\t\t\troot_of[v] = root_of[u];",
            "\t\t\t\tq.push_back(v);",
            "\t\t\t}",
            "\t\t}",
            "\t\tq.clear();",
            "\t}",
            "\t// O((# of cells reachable from src) * size(dr))",
            "\ttemplate<class Container>",
            "\tvoid bfs(const vector<Container> &grid, const vector<array<int, 2>> &src){",
            "\t\tassert((int)grid.size() <= nr);",
            "\t\tfor(auto x = 0; x < nr; ++ x) assert((int)grid[x].size() <= ncs[x]);",
            "\t\troot.clear(), order.clear();",
            "\t\t++ attempt;",
            "\t\tvector<int> src_index((int)src.size());",
            "\t\tfor(auto i = 0; i < (int)src.size(); ++ i){",
            "\t\t\tauto [x, y] = src[i];",
            "\t\t\tassert(0 <= x && x < (int)grid.size());",
            "\t\t\tassert(0 <= y && y < (int)grid[x].size());",
            "\t\t\tsrc_index[i] = index[x][y];",
            "\t\t}",
            "\t\t_bfs(grid, src_index);",
            "\t}",
            "\t// O(nr * nc * size(dr))",
            "\ttemplate<class Container>",
            "\tvoid bfs_all(const vector<Container> &grid){",
            "\t\tassert((int)grid.size() <= nr);",
            "\t\tfor(auto x = 0; x < nr; ++ x) assert((int)grid[x].size() <= ncs[x]);",
            "\t\troot.clear(), order.clear();",
            "\t\t++ attempt;",
            "\t\tfor(auto x = 0; x < (int)grid.size(); ++ x) for(auto y = 0; y < (int)grid[x].size(); ++ y) if(was[index[x][y]] != attempt) _bfs(grid, {index[x][y]});",
            "\t}",
            "\t// Check if (x, y) is visited during the last bfs-like call.",
            "\tbool visited(int x, int y) const{",
            "\t\treturn was[index[x][y]] == attempt;",
            "\t}",
            "\t// Check if u is visited during the last bfs-like call.",
            "\tbool visited(int u) const{",
            "\t\treturn was[u] == attempt;",
            "\t}",
            "};"
        ],
        "description": "tranxuanbach"
    }
}