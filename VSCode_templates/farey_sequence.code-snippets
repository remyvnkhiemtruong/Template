{
    "tranxuanbach": {
        "prefix": "farey_sequence",
        "body": [
            "// The sequcne of all non-negative irreducible fractions with numerator and denominator <= th, along with 1/0 representing infinity",
            "// T must be able to hold the square of the square of MAXVAL",
            "template<class T>",
            "struct farey_sequence{",
            "\tusing F = array<T, 2>;",
            "\tT th;",
            "\tfarey_sequence(T th): th(th){ assert(th >= 1); }",
            "\t// Given a binary predicate pred such that pred(0)=true and pred(inf)=false, and for all rational 0 <= p/q < r/s, pred(r/s) implies pred(p/q),",
            "\t// find the largest rational p/q and the smallest rational r/s such that gcd(p,q) = 1, gcd(r, s) = 1, q <= th, and s <= th",
            "\t// O(log(MAXVAL)^2)",
            "\tarray<F, 2> rational_binary_search(auto pred) const{",
            "\t\tassert(th >= 1);",
            "\t\tF f_low{0, 1}, f_high{1, 0};",
            "\t\tassert(pred(f_low) && !pred(f_high));",
            "\t\twhile(f_low[0] + f_high[0] <= th && f_low[1] + f_high[1] <= th){",
            "\t\t\tT l = 1, r = min((th - f_low[0]) / f_high[0], (th - f_high[1]) / f_low[1]) + 1;",
            "\t\t\tif(pred(F{f_low[0] + f_high[0], f_low[1] + f_high[1]})){",
            "\t\t\t\twhile(r - l >= 2){",
            "\t\t\t\t\tT m = (l + r) / 2;",
            "\t\t\t\t\tpred(F{f_low[0] + m * f_high[0], f_low[1] + m * f_high[1]}) ? l = m : r = m;",
            "\t\t\t\t}",
            "\t\t\t\tf_low = {f_low[0] + l * f_high[0], f_low[1] + l * f_high[1]};",
            "\t\t\t}",
            "\t\t\telse{",
            "\t\t\t\twhile(r - l >= 2){",
            "\t\t\t\t\tT m = (l + r) / 2;",
            "\t\t\t\t\tpred(F{m * f_low[0] + f_high[0], m * f_low[1] + f_high[1]}) ? r = m : l = m;",
            "\t\t\t\t}",
            "\t\t\t\tf_high = {l * f_low[0] + f_high[0], l * f_low[1] + f_high[1]};",
            "\t\t\t}",
            "\t\t}",
            "\t\treturn {f_low, f_high};",
            "\t}",
            "\t// O(log(MAXVAL))",
            "\tbool contains(const F &f) const{",
            "\t\treturn 0 <= min(f[0], f[1]) && max(f[0], f[1]) <= th && gcd(f[0], f[1]) == 1;",
            "\t}",
            "\t// Check if f and g are adjacent in the sequence",
            "\tbool is_adjacent(const F &f, const F &g) const{",
            "\t\treturn 0 <= min({f[0], f[1], g[0], g[1]}) && max({f[0], f[1], g[0], g[1]}) <= th && (f[0] + g[0] > th || f[1] + g[1] > th) && g[0] * f[1] - f[0] * g[1] == 1;",
            "\t}",
            "\t// Assumes pf comes before f",
            "\tF next_rational(const F &f, const F &pf) const{",
            "\t\tassert(is_adjacent(pf, f) && f[1] > 0);",
            "\t\treturn {(th + pf[1]) / f[1] * f[0] - pf[0], (th + pf[1]) / f[1] * f[1] - pf[1]};",
            "\t}",
            "\t// Assumes nf comes after f",
            "\tF prev_rational(const F &f, const F &nf) const{",
            "\t\tassert(is_adjacent(f, nf) && nf[1] > 0);",
            "\t\treturn {(th + f[1]) / nf[1] * nf[0] - f[0], (th + f[1]) / nf[1] * nf[1] - f[1]};",
            "\t}",
            "\tT _inv(T a, T n) const{",
            "\t\tT t = 0, newt = 1, r = n, newr = a;",
            "\t\twhile(newr){",
            "\t\t\tT q = r / newr;",
            "\t\t\ttie(t, newt) = pair{newt, t - q * newt};",
            "\t\t\ttie(r, newr) = pair{newr, r - q * newr};",
            "\t\t}",
            "\t\tassert(r == 1);",
            "\t\tif(t < 0) t += n;",
            "\t\treturn t;",
            "\t}",
            "\tF next_rational(const F &f) const{",
            "\t\tassert(0 <= f[0] && 0 < f[1]);",
            "\t\tT inv = _inv(f[0], f[1]);",
            "\t\tT b = (inv + th) / f[1] * f[1] - inv;",
            "\t\treturn {(b * f[0] + 1) / f[1], b};",
            "\t}",
            "\tF prev_rational(const F &f) const{",
            "\t\tassert(0 < f[0] && 0 <= f[1]);",
            "\t\tT inv = _inv(f[1], f[0]);",
            "\t\tT a = (inv + th) / f[0] * f[0] - inv;",
            "\t\treturn {a, (a * f[1] + 1) / f[0]};",
            "\t}",
            "\t// TODO: Finish these with https://csacademy.com/contest/algorithms-2018-07-22-6/task/farey_sequence/solution/",
            "\t// F operator[](Index_t i) const{",
            "\t// \tassert(0 <= i);",
            "",
            "\t// }",
            "\t// Index_t operator[](const F &f) const{",
            "",
            "\t// }",
            "\tvector<F> to_vector() const{",
            "\t\tvector<F> res{{0, 1}, {1, 0}}, res_next;",
            "\t\tfor(auto i = 1; i <= th; ++ i){",
            "\t\t\tres_next = {res[0]};",
            "\t\t\tfor(auto j = 1; j < (int)res.size(); ++ j){",
            "\t\t\t\tif(res[j - 1][0] + res[j][0] <= th && res[j - 1][1] + res[j][1] <= th) res_next.push_back({res[j - 1][0] + res[j][0], res[j - 1][1] + res[j][1]});",
            "\t\t\t\tres.push_back(res[j]);",
            "\t\t\t}",
            "\t\t\tswap(res, res_next);",
            "\t\t}",
            "\t\treturn res;",
            "\t}",
            "};"
        ],
        "description": "tranxuanbach"
    }
}