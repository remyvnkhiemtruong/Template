{
    "tranxuanbach": {
        "prefix": "suffix_automaton",
        "body": [
            "// Each node represents an endpos-equivalent class",
            "// Each class consists of some consecutive suffixes of the longest substring in it",
            "// The suffix corresponding to minlen - 1 can be obtained by following the suffix link and looking at the longest substring in it",
            "// Adjacency_Type: array<int, X> or map<Char_Type, int> where X is the size of the alphabet",
            "template<class Char_Type, class Adjacency_Type>",
            "struct suffix_automaton{",
            "\t// Begin States",
            "\tvector<int> max_len{0}; // Length of the longest string in the class.",
            "\tvector<int> link{-1};",
            "\tvector<int> firstpos{-1}; // Index of the first occurences of the strings in the class.",
            "\tvector<int> is_clone{false};",
            "\tvector<Adjacency_Type> next{{}};",
            "\t// End States",
            "\tint new_state(int l, int sl, int fp, bool c, const Adjacency_Type &adj){",
            "\t\tmax_len.push_back(l);",
            "\t\tlink.push_back(sl);",
            "\t\tfirstpos.push_back(fp);",
            "\t\tis_clone.push_back(c);",
            "\t\tnext.push_back(adj);",
            "\t\treturn (int)max_len.size() - 1;",
            "\t}",
            "\tint last = 0;",
            "\tvoid extend(const vector<Char_Type> &s){",
            "\t\tfor(auto c: s) extend(c);",
            "\t}",
            "\tvoid extend(Char_Type c){",
            "\t\tint cur = new_state(max_len[last] + 1, -1, max_len[last], false, {}), p = last;",
            "\t\twhile(~p && !next[p][c]) next[p][c] = cur, p = link[p];",
            "\t\tif(!~p) link[cur] = 0;",
            "\t\telse{",
            "\t\t\tint q = next[p][c];",
            "\t\t\tif(max_len[p] + 1 == max_len[q]) link[cur] = q;",
            "\t\t\telse{",
            "\t\t\t\tint clone = new_state(max_len[p] + 1, link[q], firstpos[q], true, next[q]);",
            "\t\t\t\twhile(~p && next[p][c] == q) next[p][c] = clone, p = link[p];",
            "\t\t\t\tlink[q] = link[cur] = clone;",
            "\t\t\t}",
            "\t\t}",
            "\t\tlast = cur;",
            "\t\tcount.clear();",
            "\t\tinv_link.clear();",
            "\t}",
            "\tint next_state(int u, int c){",
            "\t\tassert(0 <= u && u < (int)next.size());",
            "\t\twhile(u && !next[u][c]) u = link[u];",
            "\t\tif(next[u][c]) u = next[u][c];",
            "\t\treturn u;",
            "\t}",
            "\tpair<int, int> next_state(int u, int len, int c){",
            "\t\tassert(0 <= u && u < (int)next.size());",
            "\t\twhile(u && !next[u][c]) u = link[u], len = max_len[u];",
            "\t\tif(next[u][c]) u = next[u][c], ++ len;",
            "\t\treturn {u, len};",
            "\t}",
            "\tint size() const{ // # of states",
            "\t\treturn (int)max_len.size();",
            "\t}",
            "\tint min_len(int u) const{ // length of the shortest string in the endpos equivalent class",
            "\t\treturn u ? max_len[link[u]] + 1 : 0;",
            "\t}",
            "\tvector<int> terminals() const{",
            "\t\tvector<int> t;",
            "\t\tfor(auto u = last; ~u; u = link[u]) t.push_back(u);",
            "\t\treturn t;",
            "\t}",
            "\tvector<int> count; // # of occurrences of substring represented by each states in the string. Calling extend invalidates the array.",
            "\tvector<vector<int>> inv_link;",
            "\tvoid precalc_count(){",
            "\t\tint sz = (int)size();",
            "\t\tcount.assign(sz, 0), inv_link.assign(sz, {});",
            "\t\tfor(auto u = 1; u < sz; ++ u) inv_link[link[u]].push_back(u);",
            "\t\tauto dfs = [&](auto self, int u)->void{",
            "\t\t\tcount[u] = !is_clone[u];",
            "\t\t\tfor(auto v: inv_link[u]){",
            "\t\t\t\tself(self, v);",
            "\t\t\t\tcount[u] += count[v];",
            "\t\t\t}",
            "\t\t};",
            "\t\tdfs(dfs, 0);",
            "\t}",
            "\tvector<int> find_all_occurrences(int u){",
            "\t\tassert(!count.empty() && u < size());",
            "\t\tvector<int> res;",
            "\t\tauto dfs = [&](auto self, int u)->void{",
            "\t\t\tif(!is_clone[u]) res.push_back(firstpos[u]);",
            "\t\t\tfor(auto v: inv_link[u]) self(self, v);",
            "\t\t};",
            "\t\tdfs(dfs, u);",
            "\t\treturn res;",
            "\t}",
            "};"
        ],
        "description": "tranxuanbach"
    }
}