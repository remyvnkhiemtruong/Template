{
    "tranxuanbach": {
        "prefix": "li_chao_tree_fixed_query",
        "body": [
            "// Data structure maintaining functions [th_low, th_high]->X such that",
            "// any two functions f and g are either equal, one is strictly above the other, or has a point p \\in [th_low, th_high] satisfying either",
            "// (f(x) < g(x) for all x<p, f(p) = g(p), and f(y) > g(y) for all p<=y) or",
            "// (f(x) > g(x) for all x<p, f(p) = g(p), and f(y) < g(y) for all p<=y).",
            "template<bool COMPRESSED, class T, class X, class F, class Compare>",
            "struct li_chao_tree_fixed_query_base{",
            "\tint n, size;",
            "\tvector<T> frame;",
            "#define GET(x) (COMPRESSED ? frame[x] : x)",
            "\tvector<int> data; // -1 denotes the function at -inf.",
            "\tF evaluate; // evaluate(i, p): value of function i at p",
            "\tCompare cmp;",
            "\tX minf;",
            "\tli_chao_tree_fixed_query_base(T n, F evaluate, X _type_deducer, Compare cmp, X minf): n(n), evaluate(evaluate), cmp(cmp), minf(minf){",
            "\t\tstatic_assert(!COMPRESSED);",
            "\t\tassert(n >= 1);",
            "\t\tsize = 1;",
            "\t\twhile(size < n) size <<= 1;",
            "\t\tdata.assign(size << 1, -1);",
            "\t}",
            "\tli_chao_tree_fixed_query_base(const vector<T> &frame, F evaluate, X _type_deducer, Compare cmp = less<>(), X minf = numeric_limits<X>::min()): n((int)frame.size()), frame(frame), evaluate(evaluate), cmp(cmp), minf(minf){",
            "\t\tstatic_assert(COMPRESSED);",
            "\t\tassert(!frame.empty());",
            "\t\tassert(is_sorted(frame.begin(), frame.end()));",
            "\t\tsize = 1;",
            "\t\twhile(size < n) size <<= 1;",
            "\t\tthis->frame.resize(size, frame.back());",
            "\t\tdata.assign(size << 1, -1);",
            "\t}",
            "\tli_chao_tree_fixed_query_base &operator=(const li_chao_tree_fixed_query_base &lct){",
            "\t\tn = lct.n;",
            "\t\tsize = lct.size;",
            "\t\tif constexpr(COMPRESSED) frame = lct.frame;",
            "\t\tdata = lct.data;",
            "\t}",
            "\t// function i is equal or higher than j on [l, r]",
            "\tbool majorize(int i, int j, T l, T r) const{",
            "\t\treturn !cmp(evaluate(i, l), evaluate(j, l)) && !cmp(evaluate(i, r), evaluate(j, r));",
            "\t}",
            "\t// Insert the function i.",
            "\t// O(log(n))",
            "\tvoid insert(int i){",
            "\t\tassert(i >= 0);",
            "\t\tint u = 1, l = 0, r = size;",
            "\t\twhile(true){",
            "\t\t\tif(!~data[u] || majorize(i, data[u], GET(l), GET(r - 1))) swap(i, data[u]);",
            "\t\t\tif(!~i || majorize(data[u], i, GET(l), GET(r - 1))) break;",
            "\t\t\tif(cmp(evaluate(data[u], GET(l)), evaluate(i, GET(l)))) swap(i, data[u]);",
            "\t\t\tif(r - l == 1) break;",
            "\t\t\tint m = l + r >> 1;",
            "\t\t\tif(cmp(evaluate(data[u], GET(m)), evaluate(i, GET(m)))){",
            "\t\t\t\tswap(i, data[u]);",
            "\t\t\t\tu = u << 1;",
            "\t\t\t\tr = m;",
            "\t\t\t}",
            "\t\t\telse{",
            "\t\t\t\tu = u << 1 | 1;",
            "\t\t\t\tl = m;",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "\t// Return the pair {evaluate(i, p), i} where i achieves the maximum evaluation at p among all functions in the data structure.",
            "\t// O(log(n))",
            "\tpair<X, int> query_max(T x) const{",
            "\t\tint p;",
            "\t\tif constexpr(COMPRESSED){",
            "\t\t\tp = lower_bound(frame.begin(), frame.end(), x) - frame.begin();",
            "\t\t\tassert(0 <= p && p < n && frame[p] == x);",
            "\t\t}",
            "\t\telse{",
            "\t\t\tp = x;",
            "\t\t\tassert(0 <= p && p < n);",
            "\t\t}",
            "\t\tX optv = minf;",
            "\t\tint opti = -1, u = 1, l = 0, r = size;",
            "\t\twhile(~data[u]){",
            "\t\t\tif(X cv = evaluate(data[u], GET(p)); cv > optv){",
            "\t\t\t\toptv = cv;",
            "\t\t\t\topti = data[u];",
            "\t\t\t}",
            "\t\t\tif(r - l == 1) break;",
            "\t\t\tT m = l + r >> 1;",
            "\t\t\tif(p < m){",
            "\t\t\t\tu = u << 1;",
            "\t\t\t\tr = m;",
            "\t\t\t}",
            "\t\t\telse{",
            "\t\t\t\tu = u << 1 | 1;",
            "\t\t\t\tl = m;",
            "\t\t\t}",
            "\t\t}",
            "\t\tassert(~opti);",
            "\t\treturn {optv, opti};",
            "\t}",
            "\tfriend ostream &operator<<(ostream &out, const li_chao_tree_fixed_query_base &lct){",
            "\t\tauto recurse = [&](auto self, int u, T l, T r)->void{",
            "\t\t\tout << \"Node \" << u << \" for range [\" << l << \", \" << r << \"]: \";",
            "\t\t\tout << \"{\";",
            "\t\t\tif(~lct.data[u]) out << lct.data[u] << \", \" << lct.evaluate(lct.data[u], GET(l + r >> 1));",
            "\t\t\tout << \"}\\n\";;",
            "\t\t\tif(~lct.child[u][0]) self(self, lct.child[u][0], l, l + r >> 1);",
            "\t\t\tif(~lct.child[u][1]) self(self, lct.child[u][1], l + r >> 1, r);",
            "\t\t};",
            "\t\trecurse(recurse, 1, 0, COMPRESSED ? (int)lct.frame.size() : lct.n);",
            "\t\treturn out;",
            "\t}",
            "#undef GET",
            "};",
            "",
            "// Query coordinates are 0, ..., n-1",
            "template<class X, class F, class Compare = less<>>",
            "auto make_li_chao_tree_fixed_query(int n, F evaluate, X _type_deducer, Compare cmp = less<>(), X minf = numeric_limits<X>::min()){",
            "\treturn li_chao_tree_fixed_query_base<false, int, X, F, Compare>(n, evaluate, _type_deducer, cmp, minf);",
            "}",
            "// Query coordinates are frame[0], ..., frame[n-1]",
            "template<class T, class X, class F, class Compare = less<>>",
            "auto make_li_chao_tree_fixed_query_compressed(const vector<T> &frame, F evaluate, X _type_deducer, Compare cmp = less<>(), X minf = numeric_limits<X>::min()){",
            "\treturn li_chao_tree_fixed_query_base<true, T, X, F, Compare>(frame, evaluate, _type_deducer, cmp, minf);",
            "}"
        ],
        "description": "tranxuanbach"
    }
}