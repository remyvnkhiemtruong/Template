{
    "tranxuanbach": {
        "prefix": "linear_recurrence_solver",
        "body": [
            "// Store the linear recurrence relation of form \\sum_{t<=i<t+n} coef[i]*init[i] = init[t+n]",
            "// T must be of modular type",
            "// Requires modular",
            "template<class T>",
            "struct linear_recurrence_solver{",
            "\tint n;",
            "\tvector<T> init, coef;",
            "\tlinear_recurrence_solver(const vector<T> &init, const vector<T> &coef): n((int)coef.size()), init(init), coef(coef){",
            "\t\tassert(coef.size() == init.size());",
            "\t}",
            "\t// Berlekamp Massey Algorithm",
            "\t// Find a minimum linear recurrence relation",
            "\t// O(len(s) * (n + log(mod)))",
            "\tlinear_recurrence_solver(const vector<T> &s){",
            "\t\tint sz = (int)s.size();",
            "\t\tvector<T> b = {-1};",
            "\t\tcoef = {-1};",
            "\t\tT y = 1;",
            "\t\tfor(auto t = 1; t <= sz; ++ t){",
            "\t\t\tint l = (int)coef.size(), m = (int)b.size();",
            "\t\t\tT x = 0;",
            "\t\t\tfor(auto i = 0; i < l; ++ i) x += coef[i] * s[t - l + i];",
            "\t\t\tb.push_back(0);",
            "\t\t\t++ m;",
            "\t\t\tif(x == 0) continue;",
            "\t\t\tT freq = x / y;",
            "\t\t\tif(l < m){",
            "\t\t\t\tauto tmp = coef;",
            "\t\t\t\tcoef.insert(coef.begin(), m - l, 0);",
            "\t\t\t\tfor(auto i = 0; i < m; ++ i) coef[m - 1 - i] -= freq * b[m - 1 - i];",
            "\t\t\t\tb = tmp;",
            "\t\t\t\ty = x;",
            "\t\t\t}",
            "\t\t\telse for(auto i = 0; i < m; ++ i) coef[l - 1 - i] -= freq * b[m - 1 - i];",
            "\t\t}",
            "\t\tcoef.pop_back();",
            "\t\tn = (int)coef.size();",
            "\t\tinit = vector<T>(s.begin(), s.begin() + n);",
            "\t}",
            "\t// O(n^2 * log(i))",
            "\ttemplate<class U>",
            "\tvector<T> get_coef(U i) const{",
            "\t\tassert(0 <= i);",
            "\t\tif(n == 0) return vector<T>(n + 1);",
            "\t\tauto merge = [&](const vector<T> &a, const vector<T> &b){",
            "\t\t\tvector<T> res(2 * n + 1);",
            "\t\t\tfor(auto i = 0; i <= n; ++ i) for(auto j = 0; j <= n; ++ j) res[i + j] += a[i] * b[j];",
            "\t\t\tfor(auto i = n << 1; i >= n; -- i) for(auto j = 0; j < n; ++ j) res[i - 1 - j] += res[i] * coef[n - 1 - j];",
            "\t\t\tres.resize(n + 1);",
            "\t\t\tres[n] = 0;",
            "\t\t\treturn res;",
            "\t\t};",
            "\t\tvector<T> power(n + 1), base(n + 1);",
            "\t\tfor(power[0] = base[1] = 1; i; i >>= 1, base = merge(base, base)) if(i & 1) power = merge(power, base);",
            "\t\tT res = 0;",
            "\t\treturn power;",
            "\t}",
            "\t// O(n^2 * log(i))",
            "\ttemplate<class U>",
            "\tT operator[](U i) const{",
            "\t\tassert(0 <= i);",
            "\t\tif(n == 0) return 0;",
            "\t\tauto power = get_coef(i);",
            "\t\tT res = 0;",
            "\t\tfor(auto i = 0; i < n; ++ i) res += power[i] * init[i];",
            "\t\treturn res;",
            "\t}",
            "};"
        ],
        "description": "tranxuanbach"
    }
}