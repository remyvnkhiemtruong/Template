{
    "tranxuanbach": {
        "prefix": "range_choose_sum_tracker",
        "body": [
            "template<class T, bool PRECALC_INVERSE = true>",
            "struct range_choose_sum_tracker{",
            "\tint n, deg, th;",
            "\tT base, inv_base;",
            "\tvector<T> base_power;",
            "\tvector<vector<T>> power;",
            "\t// Every number from 1 to n along with base + 1 must be invertible.",
            "\t// O((n + deg) * deg)",
            "\trange_choose_sum_tracker(int n, T base, int deg): n(n), deg(deg), th(max(n, deg)), base(base), value(deg + 1), base_power(th + 1, 1), power(th + 1, vector<T>(deg + 1, 1)){",
            "\t\tassert(n >= 0 && deg >= 0);",
            "\t\tfact.assign(th + 1, 1);",
            "\t\tfor(auto i = 2; i <= th; ++ i) fact[i] = fact[i - 1] * i;",
            "\t\tif constexpr(PRECALC_INVERSE){",
            "\t\t\tinv_base = 1 / (base + 1);",
            "\t\t\tinvfact.assign(th + 1, 1);",
            "\t\t\tinvfact[th] = 1 / fact[th];",
            "\t\t\tfor(auto i = th - 1; i >= 2; -- i) invfact[i] = invfact[i + 1] * (i + 1);",
            "\t\t}",
            "\t\tfor(auto x = 1; x <= th; ++ x) base_power[x] = base_power[x - 1] * base;",
            "\t\tfor(auto x = 0; x <= th; ++ x) for(auto y = 1; y <= deg; ++ y) power[x][y] = power[x][y - 1] * x;",
            "\t}",
            "\tvector<T> fact, invfact;",
            "\tT choose(int m, int i) const{",
            "\t\tassert(0 <= m && m <= th);",
            "\t\tif(i < 0 || m < i) return T{0};",
            "\t\tif constexpr(PRECALC_INVERSE) return fact[m] * invfact[i] * invfact[m - i];",
            "\t\telse return fact[m] / fact[i] / fact[m - i];",
            "\t}",
            "\tint m = 0, l = 0, r = 0;",
            "\tvector<T> value;",
            "\t// O(deg^2)",
            "\tvoid increase_m(){",
            "\t\tassert(m < n);",
            "\t\tif(l < r){",
            "\t\t\tfor(auto i = deg; i >= 0; -- i){",
            "\t\t\t\tT res = 0;",
            "\t\t\t\tfor(auto j = 0; j <= i; ++ j) res += choose(i, j) * value[j];",
            "\t\t\t\tres = res * base + value[i];",
            "\t\t\t\tif(1 <= l && l <= th) res += power[l][i] * base_power[l] * choose(m, l - 1);",
            "\t\t\t\tif(1 <= r && r <= th) res -= power[r][i] * base_power[r] * choose(m, r - 1);",
            "\t\t\t\tvalue[i] = res;",
            "\t\t\t}",
            "\t\t}",
            "\t\t++ m;",
            "\t}",
            "\t// O(deg^2)",
            "\tvoid decrease_m(){",
            "\t\tassert(m >= 1);",
            "\t\tif(l < r){",
            "\t\t\tfor(auto i = 0; i <= deg; ++ i){",
            "\t\t\t\tT res = 0;",
            "\t\t\t\tfor(auto j = 0; j < i; ++ j) res -= choose(i, j) * value[j];",
            "\t\t\t\tres = res * base + value[i];",
            "\t\t\t\tif(1 <= l && l <= th) res -= power[l][i] * base_power[l] * choose(m - 1, l - 1);",
            "\t\t\t\tif(1 <= r && r <= th) res += power[r][i] * base_power[r] * choose(m - 1, r - 1);",
            "\t\t\t\tif constexpr(PRECALC_INVERSE) value[i] = res * inv_base;",
            "\t\t\t\telse value[i] = res / (base + 1);",
            "\t\t\t}",
            "\t\t}",
            "\t\t-- m;",
            "\t}",
            "\t// O(deg)",
            "\tvoid increase_l(){",
            "\t\tassert(l < r);",
            "\t\tif(0 <= l && l <= th) for(auto i = 0; i <= deg; ++ i) value[i] -= power[l][i] * base_power[l] * choose(m, l);",
            "\t\t++ l;",
            "\t}",
            "\t// O(deg)",
            "\tvoid decrease_l(){",
            "\t\t-- l;",
            "\t\tif(0 <= l && l <= th) for(auto i = 0; i <= deg; ++ i) value[i] += power[l][i] * base_power[l] * choose(m, l);",
            "\t}",
            "\t// O(deg)",
            "\tvoid increase_r(){",
            "\t\tif(0 <= r && r <= th) for(auto i = 0; i <= deg; ++ i) value[i] += power[r][i] * base_power[r] * choose(m, r);",
            "\t\t++ r;",
            "\t}",
            "\t// O(deg)",
            "\tvoid decrease_r(){",
            "\t\tassert(l < r);",
            "\t\t-- r;",
            "\t\tif(0 <= r && r <= th) for(auto i = 0; i <= deg; ++ i) value[i] -= power[r][i] * base_power[r] * choose(m, r);",
            "\t}",
            "\t// Returns \\sum_{i=ql}^qr i^j * base^i * Choose(qm,i) for all integer 0 <= j <= deg.",
            "\t// O(deg^2 * abs(m - qm) + deg * (abs(l - ql) + abs(r - qr)))",
            "\tconst vector<T> &operator()(int qm, int ql, int qr){",
            "\t\tassert(0 <= qm && qm <= n);",
            "\t\tassert(ql <= qr);",
            "\t\twhile(m < qm) increase_m();",
            "\t\twhile(m > qm) decrease_m();",
            "\t\twhile(ql < l) decrease_l();",
            "\t\twhile(r < qr) increase_r();",
            "\t\twhile(l < ql) increase_l();",
            "\t\twhile(qr < r) decrease_r();",
            "\t\treturn value;",
            "\t}",
            "};"
        ],
        "description": "tranxuanbach"
    }
}