{
    "tranxuanbach": {
        "prefix": "data_structure_deletion_enabler_offline",
        "body": [
            "// For a commutative data structure supporting insertion,",
            "// support deletion offline.",
            "struct data_structure_deletion_enabler_offline{",
            "\tint n, qn; // Elements should lie in range [0, n).",
            "\tvector<vector<int>> queue;",
            "\tdata_structure_deletion_enabler_offline(int n, int qn): n(n), qn(qn), queue(qn << 1){",
            "\t\tassert(n >= 0 && qn >= 0);",
            "\t}",
            "\t// Update i exists during interval [ql, qr).",
            "\tvoid insert(int i, int ql, int qr){",
            "\t\tassert(0 <= i && i < n);",
            "\t\tassert(0 <= ql && ql <= qr && qr <= qn);",
            "\t\tauto recurse = [&](auto self, int u, int l, int r)->void{",
            "\t\t\tif(qr <= l || r <= ql) return;",
            "\t\t\tif(ql <= l && r <= qr) queue[u].push_back(i);",
            "\t\t\telse{",
            "\t\t\t\tint m = l + (r - l >> 1), v = u + 1, w = u + (m - l << 1);",
            "\t\t\t\tself(self, v, l, m), self(self, w, m, r);",
            "\t\t\t}",
            "\t\t};",
            "\t\trecurse(recurse, 0, 0, qn);",
            "\t}",
            "\t// insert(i): insert update i.",
            "\t// state(): return the state of the DS as an integer.",
            "\t// reverse_to(s): reverse the state of the DS to s.",
            "\t// answer(qi): return the answer to the time qi.",
            "\t// O(qn * log(qn)) insert() calls and O(qn) answer() calls.",
            "\ttemplate<class I, class S, class R, class A>",
            "\tvoid solve(I insert, S state, R reverse_to, A answer){",
            "\t\tauto recurse = [&](auto self, int u, int l, int r)->void{",
            "\t\t\tint s = state();",
            "\t\t\tfor(auto i: queue[u]) insert(i);",
            "\t\t\tif(r - l == 1) answer(l);",
            "\t\t\telse{",
            "\t\t\t\tint m = l + (r - l >> 1);",
            "\t\t\t\tself(self, u + 1, l, m), self(self, u + (m - l << 1), m, r);",
            "\t\t\t}",
            "\t\t\treverse_to(s);",
            "\t\t};",
            "\t\trecurse(recurse, 0, 0, qn);",
            "\t}",
            "};"
        ],
        "description": "tranxuanbach"
    }
}