{
    "tranxuanbach": {
        "prefix": "matroid_intersection",
        "body": [
            "// Requires matroid",
            "struct matroid_intersection{",
            "\tint n;",
            "\tvector<int> state;",
            "\tmatroid_intersection(int n): n(n), state(n), pv(n), q(n + 1){ }",
            "\tvector<int> pv, q;",
            "\ttemplate<class M1, class M2>",
            "\tbool augment(M1 &m1, M2 &m2){",
            "\t\tfill(pv.begin(), pv.end(), -1);",
            "\t\tint beg = 0, end = 0;",
            "\t\tq[end ++] = n;",
            "\t\tauto forward_edge = [&](int u){",
            "\t\t\tvector<int> res;",
            "\t\t\tm1.clear();",
            "\t\t\tfor(auto v = 0; v < n; ++ v) if(state[v] && v != u) m1.insert(v);",
            "\t\t\tfor(auto v = 0; v < n; ++ v) if(!state[v] && !~pv[v] && m1.check(v)){",
            "\t\t\t\tres.push_back(v);",
            "\t\t\t\tpv[v] = u;",
            "\t\t\t}",
            "\t\t\treturn res;",
            "\t\t};",
            "\t\tauto backward_edge = [&](int u){",
            "\t\t\tm2.clear();",
            "\t\t\tfor(auto rep = 0; rep < 2; ++ rep) for(auto v = 0; v < n; ++ v) if((v == u || state[v]) && !~pv[v] == rep){",
            "\t\t\t\tif(!m2.check(v)){",
            "\t\t\t\t\tif(rep){",
            "\t\t\t\t\t\tq[end ++] = v;",
            "\t\t\t\t\t\tpv[v] = u;",
            "\t\t\t\t\t\treturn v;",
            "\t\t\t\t\t}",
            "\t\t\t\t\telse return -1;",
            "\t\t\t\t}",
            "\t\t\t\tm2.insert(v);",
            "\t\t\t}",
            "\t\t\treturn n;",
            "\t\t};",
            "\t\twhile(beg < end){",
            "\t\t\tint u = q[beg ++], v;",
            "\t\t\tfor(auto w: forward_edge(u)) while((v = backward_edge(w)) >= 0) if(v == n){",
            "\t\t\t\twhile(w != n){",
            "\t\t\t\t\tstate[w] ^= 1;",
            "\t\t\t\t\tw = pv[w];",
            "\t\t\t\t}",
            "\t\t\t\treturn true;",
            "\t\t\t}",
            "\t\t}",
            "\t\treturn false;",
            "\t}",
            "\t/*",
            "\t---------------------------------------------",
            "\t| # of member function calls where          |",
            "\t| r is the size of the answer and           |",
            "\t| n is the size of the ground set           |",
            "\t---------------------------------------------",
            "\t| Member Function | M1         | M2         |",
            "\t---------------------------------------------",
            "\t| insert()        | O(r^3)     | O(r^2 * n) |",
            "\t| check()         | O(r^2 * n) | O(r^2 * n) |",
            "\t| clear()         | O(r^2)     | O(r * n)   |",
            "\t---------------------------------------------",
            "\t*/",
            "\ttemplate<class M1, class M2>",
            "\tvector<int> maximum_common_independent_set(M1 m1, M2 m2){",
            "\t\tfill(state.begin(), state.end(), false);",
            "\t\tm1.clear();",
            "\t\tm2.clear();",
            "\t\tfor(auto u = 0; u < n; ++ u) if(m1.check(u) && m2.check(u)){",
            "\t\t\tstate[u] = true;",
            "\t\t\tm1.insert(u);",
            "\t\t\tm2.insert(u);",
            "\t\t}",
            "\t\twhile(augment<M1, M2>(m1, m2));",
            "\t\tvector<int> res;",
            "\t\tfor(auto u = 0; u < n; ++ u) if(state[u]) res.push_back(u);",
            "\t\treturn res;",
            "\t}",
            "};"
        ],
        "description": "tranxuanbach"
    }
}