{
    "tranxuanbach": {
        "prefix": "find_the_order_of_all_group_elements",
        "body": [
            "// Source: \"Linear time algorithms for Abelian group isomorphism and related problems\" by T. Kavitha",
            "// op: {0, ..., n-1}^2 -> {0, ..., n-1} must define a group",
            "// Less than 2n op() calls",
            "vector<int> find_the_order_of_all_group_elements(int n, auto op){",
            "\tassert(1 <= n);",
            "\tvector<int> d{1}, map_to_d(n + 1), prime, lpf(n + 1), g(n + 1, 1), square(n), order(n), path;",
            "\tfor(auto x = 2; x <= n; ++ x){",
            "\t\tif(n % x == 0){",
            "\t\t\tmap_to_d[x] = (int)d.size();",
            "\t\t\td.push_back(x);",
            "\t\t}",
            "\t\tif(!lpf[x]){",
            "\t\t\tprime.push_back(x);",
            "\t\t\tlpf[x] = x;",
            "\t\t}",
            "\t\tfor(auto i = 0; i < (int)prime.size() && prime[i] <= lpf[x] && prime[i] * x <= n; ++ i) lpf[prime[i] * x] = prime[i];",
            "\t}",
            "\tvector<vector<int>> l((int)d.size(), vector<int>((int)d.size()));",
            "\tfor(auto i = 0; i < (int)d.size(); ++ i) for(auto j = i; j < (int)d.size(); ++ j) l[i][j] = l[j][i] = lcm(d[i], d[j]);",
            "\tfor(auto x = 0; x < n; ++ x) if(x == (square[x] = op(x, x))) order[x] = 1;",
            "\tfor(auto x = 0; x < n; ++ x){",
            "\t\tif(order[x]) continue;",
            "\t\tint p1 = x, p2 = square[x], e = 2;",
            "\t\tpath.clear();",
            "\t\twhile((!order[p1] || !order[p2]) && order[p2] != 1){",
            "\t\t\tpath.push_back(p2);",
            "\t\t\tp1 = p2;",
            "\t\t\tp2 = op(p2, x);",
            "\t\t\t++ e;",
            "\t\t}",
            "\t\tif(order[p1] && order[p2]) order[x] = l[map_to_d[order[p1]]][map_to_d[order[p2]]], -- e;",
            "\t\telse order[x] = e;",
            "\t\tfor(auto y = 2; y < e; ++ y){",
            "\t\t\tauto p = lpf[y];",
            "\t\t\tg[y] = order[x] % (p * g[y / p]) ? g[y / p] : p * g[y / p];",
            "\t\t\torder[path[y - 2]] = order[x] / g[y];",
            "\t\t}",
            "\t}",
            "\treturn order;",
            "}",
            "vector<int> find_the_order_of_all_group_elements(const vector<vector<int>> &g){",
            "\treturn find_the_order_of_all_group_elements((int)g.size(), [&](int x, int y){ return g[x][y]; });",
            "}"
        ],
        "description": "tranxuanbach"
    }
}