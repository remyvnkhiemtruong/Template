{
    "tranxuanbach": {
        "prefix": "Z2_basis_small",
        "body": [
            "template<typename V> // V must be an integral type where its bitmask represents a vector",
            "struct Z2_basis_small{ // Keep track of a set of basis of the subspace spanned by the inserted vectors",
            "\tint rank(){",
            "\t\treturn (int)elements.size();",
            "\t}",
            "\tV reduce(V v){ // O(bit_length)",
            "\t\tfor(int i = 0; i < rank(); ++ i) if((v ^ elements[i]) < v){",
            "\t\t\tv ^= elements[i];",
            "\t\t\tlog.push_back({0, i, count});",
            "\t\t}",
            "\t\treturn v;",
            "\t}",
            "\tbool insert(V v){ // insert a vector while maintaining the lower triangular form",
            "\t\tv = reduce(v);",
            "\t\tif(!v) return ++ count, false;",
            "\t\tint p = __lg(v);",
            "\t\tfor(int i = 0; i < rank(); ++ i) if(elements[i] & (V)1 << p){",
            "\t\t\telements[i] ^= v;",
            "\t\t\tlog.push_back({0, count, i});",
            "\t\t}",
            "\t\tint t = lower_bound(trail.begin(), trail.end(), p) - trail.begin();",
            "\t\ttrail.insert(trail.begin() + t, p);",
            "\t\telements.insert(elements.begin() + t, v);",
            "\t\tlog.push_back({2, count, t});",
            "\t\treturn ++ count, true;",
            "\t}",
            "\ttemplate<bool find_basis = false>",
            "\tpair<bool, vector<V>> solve(vector<bool> b){ // O(dim^2); returns {false, {}} / {true, {one_of_sol, sol_basis}}",
            "\t\tassert(count == (int)b.size());",
            "\t\tfor(auto &m: log){",
            "\t\t\tif(m.type == 0) b[m.to] ^= b[m.from];",
            "\t\t\telse rotate(b.begin() + m.to, b.begin() + m.from, b.begin() + m.from + 1);",
            "\t\t}",
            "\t\tfor(int i = rank(); i < count; ++ i) if(b[i]) return {};",
            "\t\tvector<V> res({0});",
            "\t\tV is_free = -1;",
            "\t\tfor(int i = 0; i < rank(); ++ i) res[0] |= (V)b[i] << trail[i], is_free ^= (V)1 << trail[i];",
            "\t\tif(find_basis) for(int j = 0; j <= __lg(numeric_limits<V>::max()); ++ j) if(is_free & (V)1 << j){",
            "\t\t\tV v = (V)1 << j;",
            "\t\t\tfor(int i = rank() - 1; i >= 0 && trail[i] > j; -- i) v |= elements[i] & (V)1 << trail[i];",
            "\t\t\tres.push_back(v);",
            "\t\t}",
            "\t\treturn {true, res};",
            "\t}",
            "\tint count = 0;",
            "\tvector<V> elements;",
            "\tvector<int> trail; // trailing coordinates of each elements",
            "\tstruct modifier_type{",
            "\t\tint type; // 0: row[to] ^= row[from], 2: insert row[from] into row[to]",
            "\t\tint from, to;",
            "\t};",
            "\tvector<modifier_type> log;",
            "};"
        ],
        "description": "tranxuanbach"
    }
}