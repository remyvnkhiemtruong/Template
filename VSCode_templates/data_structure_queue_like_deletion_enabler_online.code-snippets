{
    "tranxuanbach": {
        "prefix": "data_structure_queue_like_deletion_enabler_online",
        "body": [
            "// For a commutative data structure supporting update, ",
            "// support deletion of the earliest update online.",
            "template<class I, class S, class R>",
            "struct data_structure_queue_like_deletion_enabler_online{",
            "\tint n; // Elements should lie in range [0, n).",
            "\tI insert; // insert(i): insert the i-th update.",
            "\tS state; // state(): return the state of the DS as an integer.",
            "\tR reverse_to; // reverse_to(s): reverse the state of the DS to s.",
            "\tint zero_cnt = 0;",
            "\tvector<pair<bool, int>> stack;",
            "\tvector<int> log;",
            "\tdata_structure_queue_like_deletion_enabler_online(int n, I insert, S state, R reverse_to): n(n), insert(insert), state(state), reverse_to(reverse_to), log({state()}){",
            "\t\tassert(n >= 0);",
            "\t}",
            "\tvoid clear(){",
            "\t\tzero_cnt = 0;",
            "\t\tstack.clear();",
            "\t\tlog.resize(1);",
            "\t\treverse_to(log.back());",
            "\t}",
            "\tarray<vector<pair<bool, int>>, 2> cur;",
            "\t// O(log(qn)) insert() and state() calls, and O(1) reverse_to() calls.",
            "\tint pop(){",
            "\t\tassert(!stack.empty());",
            "\t\tif(!zero_cnt){",
            "\t\t\tzero_cnt = (int)stack.size();",
            "\t\t\treverse(stack.begin(), stack.end());",
            "\t\t\treverse_to(log[0]);",
            "\t\t\tlog.resize(1);",
            "\t\t\tfor(auto &p: stack){",
            "\t\t\t\tp.first = false;",
            "\t\t\t\tinsert(p.second);",
            "\t\t\t\tlog.push_back(state());",
            "\t\t\t}",
            "\t\t}",
            "\t\twhile(stack.back().first){",
            "\t\t\tcur[1].push_back(stack.back());",
            "\t\t\tstack.pop_back();",
            "\t\t}",
            "\t\tfor(auto size = zero_cnt & -zero_cnt, i = 0; i < size; ++ i){",
            "\t\t\tassert(!stack.back().first);",
            "\t\t\tcur[0].push_back(stack.back());",
            "\t\t\tstack.pop_back();",
            "\t\t}",
            "\t\treverse_to(log[stack.size()]);",
            "\t\tlog.resize(stack.size() + 1);",
            "\t\tfor(auto z: {1, 0}) for(; !cur[z].empty(); cur[z].pop_back()){",
            "\t\t\tinsert(cur[z].back().second);",
            "\t\t\tlog.push_back(state());",
            "\t\t\tstack.push_back(cur[z].back());",
            "\t\t}",
            "\t\tassert(!stack.back().first);",
            "\t\tint i = stack.back().second;",
            "\t\tstack.pop_back();",
            "\t\treverse_to(log[stack.size()]);",
            "\t\tlog.resize(stack.size() + 1);",
            "\t\t-- zero_cnt;",
            "\t\treturn i;",
            "\t}",
            "\tvoid push(int i){",
            "\t\tassert(0 <= i && i < n);",
            "\t\tstack.push_back({true, i});",
            "\t\tinsert(i);",
            "\t\tlog.push_back(state());",
            "\t}",
            "\tfriend ostream &operator<<(ostream &out, const data_structure_queue_like_deletion_enabler_online &enabler){",
            "\t\tout << \"{\";",
            "\t\tfor(auto i = 0; i < (int)enabler.stack.size(); ++ i){",
            "\t\t\tout << enabler.stack[i].second;",
            "\t\t\tif(i < (int)enabler.stack.size() - 1) out << \", \";",
            "\t\t}",
            "\t\treturn out << \"}\";",
            "\t}",
            "};"
        ],
        "description": "tranxuanbach"
    }
}