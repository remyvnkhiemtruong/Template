{
    "tranxuanbach": {
        "prefix": "find_circle_point_inclusion_relations",
        "body": [
            "// Given a set of disjoint circles and points, determine the inclusion relation",
            "// n-th circle is an auxiliary circle of infinite radius",
            "// circle_inclusion(i, j): circle i directly contains circle j",
            "// point_inclusion(i, j): circle i directly contains point j",
            "// B must be able to hold up to square of coordinates",
            "// O((n + m) * log(n + m))",
            "template<class B, class C = double>",
            "void find_circle_point_inclusion_relations(const vector<array<B, 3>> &circle, const vector<array<B, 2>> &point, auto circle_inclusion, auto point_inclusion){",
            "\tint n = (int)circle.size(), m = (int)point.size();",
            "\tvector<int> pv(n, -1);",
            "\tvector<tuple<B, int, int>> event(n * 2 + m);",
            "\tfor(auto i = 0; i < n; ++ i){",
            "\t\tauto [x, y, r] = circle[i];",
            "\t\tevent[i << 1] = {x - r, 0, i};",
            "\t\tevent[i << 1 | 1] = {x + r, 1, i};",
            "\t}",
            "\tfor(auto i = 0; i < m; ++ i){",
            "\t\tauto [x, y] = point[i];",
            "\t\tevent[n * 2 + i] = {x, 2, i};",
            "\t}",
            "\tsort(event.begin(), event.end());",
            "\tB X, aux_x, aux_y;",
            "\tusing T = array<int, 2>; // ind, type(lower, upper)",
            "\tauto cmp = [&](const T &a, const T &b)->bool{",
            "\t\tauto [i, ti] = a;",
            "\t\tauto [j, tj] = b;",
            "\t\tif(i == j) return ti < tj;",
            "\t\tauto [ix, iy, ir] = ~i ? circle[i] : array<B, 3>{aux_x, aux_y, 0};",
            "\t\tauto [jx, jy, jr] = ~j ? circle[j] : array<B, 3>{aux_x, aux_y, 0};",
            "\t\treturn iy + (ti ? 1 : -1) * sqrt(max(ir * ir - (X - ix) * (X - ix), B(0))) < jy + (tj ? 1 : -1) * sqrt(max(jr * jr - (X - jx) * (X - jx), B(0)));",
            "\t};",
            "\tset<T, decltype(cmp)> sweepline(cmp);",
            "\tfor(auto [pos, type, i]: event){",
            "\t\tX = pos;",
            "\t\tif(type == 0){",
            "\t\t\taux_x = pos, aux_y = circle[i][1];",
            "\t\t\tauto it = sweepline.lower_bound({-1, -1});",
            "\t\t\tint pi = it == sweepline.end() ? n : (*it)[1] ? (*it)[0] : pv[(*it)[0]];",
            "\t\t\tcircle_inclusion(pv[i] = pi, i);",
            "\t\t\tsweepline.insert({i, 0});",
            "\t\t\tsweepline.insert({i, 1});",
            "\t\t}",
            "\t\telse if(type == 1){",
            "\t\t\tsweepline.erase({i, 0});",
            "\t\t\tsweepline.erase({i, 1});",
            "\t\t}",
            "\t\telse{",
            "\t\t\taux_x = pos, aux_y = point[i][1];",
            "\t\t\tauto it = sweepline.lower_bound({-1, -1});",
            "\t\t\tint pi = it == sweepline.end() ? n : (*it)[1] ? (*it)[0] : pv[(*it)[0]];",
            "\t\t\tpoint_inclusion(pi, i);",
            "\t\t}",
            "\t}",
            "}"
        ],
        "description": "tranxuanbach"
    }
}