{
    "tranxuanbach": {
        "prefix": "integral_map",
        "body": [
            "// Efficient map when only the keys are integers in range [offset, offset + len)",
            "template<class T, class U>",
            "struct integral_map{",
            "\tint _size = 0;",
            "\tT len, offset, maxval;",
            "\tvector<int> freq;",
            "\tvector<int> data_key;",
            "\tvector<U> data_value;",
            "\tintegral_map(int len, T offset = {}): len(len), offset(offset), maxval(offset + len), freq(len), data_key(len), data_value(len){ }",
            "\tintegral_map(const vector<pair<T, U>> &init, int len, T offset = 0): offset(offset), maxval(offset + len), freq(len), data_value(len), _size((int)init.size()){",
            "\t\tfor(auto [x, y]: init){",
            "\t\t\tassert(offset <= x && x < maxval);",
            "\t\t\tdata_value[x - offset] = y;",
            "\t\t\tassert(!freq[x - offset]);",
            "\t\t\t++ freq[x - offset];",
            "\t\t}",
            "\t\tdata_key = freq;",
            "\t\tfor(auto i = 1; i <= len; ++ i) if(i + (i & -i) <= len) data_key[i + (i & -i) - 1] += data_key[i - 1];",
            "\t}",
            "\tintegral_map(const integral_map &otr): _size(otr._size), offset(otr.offset), maxval(otr.maxval), freq(otr.freq), data_key(otr.data_key), data_value(otr.data_value){",
            "\t}",
            "\tvector<pair<T, U>> to_array(){",
            "\t\tvector<pair<T, U>> res;",
            "\t\tfor(auto x = offset; x < maxval; ++ x) if(freq[x - offset]) res.push_back({x, data_value[x - offset]});",
            "\t\treturn res;",
            "\t}",
            "\tfriend ostream &operator<<(ostream &out, const integral_map &ms){",
            "\t\tauto a = ms.to_array();",
            "\t\tout << \"{\";",
            "\t\tfor(auto i = 0; i < (int)a.size(); ++ i){",
            "\t\t\tout << \"{\" << a[i].first << \", \" << a[i].second << \"}\";",
            "\t\t\tif(i + 1 < (int)a.size()) out << \", \";",
            "\t\t}",
            "\t\treturn out << \"}\";",
            "\t}",
            "\t// O(1)",
            "\tint size() const{",
            "\t\treturn _size;",
            "\t}",
            "\t// O(1)",
            "\tbool empty() const{",
            "\t\treturn !_size;",
            "\t}",
            "\t// O(1)",
            "\tbool contains(T x) const{",
            "\t\tassert(offset <= x && x < maxval);",
            "\t\treturn freq[x - offset];",
            "\t}",
            "\t// O(log(len))",
            "\tbool insert(T x, U y){",
            "\t\tassert(offset <= x && x < maxval);",
            "\t\tif(!freq[x - offset]){",
            "\t\t\t++ _size;",
            "\t\t\t++ freq[x - offset];",
            "\t\t\tfor(auto p = x - offset + 1; p <= len; p += p & -p) ++ data_key[p - 1];",
            "\t\t\tdata_value[x - offset] = y;",
            "\t\t\treturn true;",
            "\t\t}",
            "\t\treturn false;",
            "\t}",
            "\t// O(log(len)) if true, O(1) otherwise",
            "\tbool erase(T x){",
            "\t\tassert(offset <= x && x < maxval);",
            "\t\tif(freq[x - offset]){",
            "\t\t\t-- _size;",
            "\t\t\t-- freq[x - offset];",
            "\t\t\tfor(auto p = x - offset + 1; p <= len; p += p & -p) -- data_key[p - 1];",
            "\t\t\treturn true;",
            "\t\t}",
            "\t\treturn false;",
            "\t}",
            "\t// O(log(len))",
            "\tpair<T, U> find_by_order(int k) const{",
            "\t\tif(k < 0) return {offset - 1, {}};",
            "\t\tif(k >= _size) return {maxval, {}};",
            "\t\tint p = 0;",
            "\t\tfor(auto i = __lg(len + 1), sum = 0; i >= 0; -- i) if(p + (1 << i) <= len && sum + data_key[p + (1 << i) - 1] <= k){",
            "\t\t\tsum += data_key[p + (1 << i) - 1];",
            "\t\t\tp += 1 << i;",
            "\t\t}",
            "\t\treturn {p + offset, data_value[p]};",
            "\t}",
            "\t// O(log(len))",
            "\tint order_of_key(T x) const{",
            "\t\tif(x < offset) return 0;",
            "\t\tif(maxval <= x) return _size;",
            "\t\tint sum = 0;",
            "\t\tfor(auto r = x - offset; r > 0; r -= r & -r) sum += data_key[r - 1];",
            "\t\treturn sum;",
            "\t}",
            "\t// O(log(len))",
            "\tT front() const{",
            "\t\tassert(_size);",
            "\t\treturn find_by_order(0) + offset;",
            "\t}",
            "\t// O(log(len))",
            "\tT back() const{",
            "\t\tassert(_size);",
            "\t\treturn find_by_order(_size - 1) + offset;",
            "\t}",
            "\t// Returns {maxval, {}} if no such element",
            "\t// O(log(len))",
            "\tpair<T, U> lower_bound(T x) const{",
            "\t\tint sum = 0;",
            "\t\tfor(auto r = x - offset; r > 0; r -= r & -r) sum += data_key[r - 1];",
            "\t\treturn find_by_order(sum);",
            "\t}",
            "\t// O(log(len)), returns {maxval, {}} if no such element",
            "\tpair<T, U> upper_bound(T x) const{",
            "\t\tint sum = 0;",
            "\t\tfor(auto r = x - offset + 1; r > 0; r -= r & -r) sum += data_key[r - 1];",
            "\t\treturn find_by_order(sum);",
            "\t}",
            "\t// Returns {minval, {}} if no such element",
            "\t// O(log(len))",
            "\tT reverse_lower_bound(T x) const{",
            "\t\tint sum = 0;",
            "\t\tfor(auto r = x - offset + 1; r > 0; r -= r & -r) sum += data_key[r - 1];",
            "\t\treturn find_by_order(sum - 1);",
            "\t}",
            "\t// Returns {minval, {}} if no such element",
            "\t// O(log(len))",
            "\tT reverse_upper_bound(T x) const{",
            "\t\tint sum = 0;",
            "\t\tfor(auto r = x - offset; r > 0; r -= r & -r) sum += data_key[r - 1];",
            "\t\treturn find_by_order(sum - 1);",
            "\t}",
            "};"
        ],
        "description": "tranxuanbach"
    }
}