{
    "tranxuanbach": {
        "prefix": "fenwick_tree_3d_sum",
        "body": [
            "template<class T>",
            "struct fenwick_tree_3d_sum{",
            "\tint n, m, l;",
            "\tvector<vector<vector<T>>> data;",
            "\t// O(n * m * l)",
            "\tfenwick_tree_3d_sum(const vector<vector<vector<T>>> &a): n((int)a.size()), m((int)a[0].size()), l((int)a[0][0].size()), data(a){",
            "\t\tfor(auto i = 1; i <= n; ++ i) if(i + (i & -i) <= n) for(auto j = 1; j <= m; ++ j) for(auto k = 1; k <= l; ++ k) data[i + (i & -i) - 1][j - 1][k - 1] += data[i - 1][j - 1][k - 1];",
            "\t\tfor(auto i = 1; i <= n; ++ i) for(auto j = 1; j <= m; ++ j) if(j + (j & -j) <= m) for(auto k = 1; k <= l; ++ k) data[i - 1][j + (j & -j) - 1][k - 1] += data[i - 1][j - 1][k - 1];",
            "\t\tfor(auto i = 1; i <= n; ++ i) for(auto j = 1; j <= m; ++ j) for(auto k = 1; k <= l; ++ k) if(k + (k & -k) <= l) data[i - 1][j - 1][k + (k & -k) - 1] += data[i - 1][j - 1][k - 1];",
            "\t}",
            "\tfenwick_tree_3d_sum(int n, int m, int l): n(n), m(m), l(l), data(n, vector<vector<T>>(m, vector<T>(l))){ }",
            "\t// a[p][q][r] += x",
            "\t// O(log(n) * log(m) * log(l))",
            "\tvoid update(int p, int q, int r, T x){",
            "\t\t++ p, ++ q, ++ r;",
            "\t\tfor(auto i = p; i <= n; i += i & -i) for(auto j = q; j <= m; j += j & -j) for(auto k = r; k <= l; k += k & -k) data[i - 1][j - 1][k - 1] += x;",
            "\t}",
            "\t// Returns the sum of a[i][j][k] on [0, xr) X [0, yr) X [0, zr)",
            "\t// O(log(n) * log(m) * log(l))",
            "\tT prefix(int xr, int yr, int zr){",
            "\t\tassert(0 <= xr && xr <= n && 0 <= yr && yr <= m && 0 <= zr && zr <= l);",
            "\t\tT res{};",
            "\t\tfor(auto i = xr; i > 0; i -= i & -i) for(auto j = yr; j > 0; j -= j & -j) for(auto k = zr; k > 0; k -= k & -k) res += data[i - 1][j - 1][k - 1];",
            "\t\treturn res;",
            "\t}",
            "\t// Returns the sum of a[i][j][k] on [xl, xr) X [yl, yr) X [zl, zr)",
            "\t// O(log(n) * log(m) * log(l))",
            "\tT query(int xl, int xr, int yl, int yr, int zl, int zr){",
            "\t\tassert(xl <= xr && yl <= yr && zl <= zr);",
            "\t\treturn prefix(xr, yr, zr) - prefix(xl, yr, zr) - prefix(xr, yl, zr) - prefix(xr, yr, zl) + prefix(xl, yl, zr) + prefix(xl, yr, zl) + prefix(xr, yl, zl) - prefix(xl, yl, zl);",
            "\t}",
            "\t// O(log(n) * log(m) * log(l))",
            "\tT query(int x, int y, int z){",
            "\t\treturn prefix(x + 1, y + 1, z + 1) - prefix(x, y + 1, z + 1) - prefix(x + 1, y, z + 1) - prefix(x + 1, y + 1, z) + prefix(x, y, z + 1) + prefix(x, y + 1, z) + prefix(x + 1, y, z) - prefix(x, y, z);",
            "\t}",
            "\ttemplate<class output_stream>",
            "\tfriend output_stream &operator<<(output_stream &out, const fenwick_tree_3d_sum<T> &fw){",
            "\t\tfor(auto i = 0; i < fw.n; ++ i){",
            "\t\t\tout << \"\\n[\";",
            "\t\t\tfor(auto j = 0; j < fw.m; ++ j){",
            "\t\t\t\tfor(auto k = 0; k < fw.l; ++ k){",
            "\t\t\t\t\tout << fw.query(i, j, k);",
            "\t\t\t\t\tif(k != fw.l - 1) out << \", \";",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t\tout << \"]\";",
            "\t\t}",
            "\t\treturn out << \"\\n\";",
            "\t}",
            "};"
        ],
        "description": "tranxuanbach"
    }
}