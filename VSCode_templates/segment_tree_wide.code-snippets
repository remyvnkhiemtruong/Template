{
    "tranxuanbach": {
        "prefix": "segment_tree_wide",
        "body": [
            "// Very fast segtree from https://en.algorithmica.org/hpc/data-structures/segment-trees/",
            "// T must be a group and support vectorization",
            "template<int SIZE, class T, class F, class I>",
            "struct segment_tree_wide_base{",
            "\tstatic_assert(SIZE > 0 && __builtin_popcount(SIZE) == 1);",
            "\tstatic constexpr int cache_size = 64;",
            "\tstatic constexpr int reg_size = 32;",
            "\tstatic constexpr int reg_count = cache_size / reg_size;",
            "\tstatic constexpr int branching = cache_size / sizeof(T);",
            "\tstatic constexpr int branching_bits = __lg(branching);",
            "\tstatic constexpr int round(int k){",
            "\t\treturn k & ~(branching - 1);  // = k / branching * branching",
            "\t}",
            "\tstatic constexpr int ceil(int k){",
            "\t\treturn (k + branching - 1) & ~(branching - 1);",
            "\t}",
            "\ttypedef T __attribute__((vector_size(reg_size))) Twide;",
            "\tstruct Precalc{",
            "\t\talignas(cache_size) T mask[branching][branching];",
            "\t\tconstexpr Precalc(): mask{}{",
            "\t\t\tfor(auto i = 0; i < branching; ++ i) for(auto j = 0; j < branching; ++ j) mask[i][j] = -(i < j);",
            "\t\t}",
            "\t};",
            "\tstatic constexpr Precalc precalc{};",
            "\tstatic constexpr int calc_height(int n){",
            "\t\treturn n <= branching ? 1 : calc_height(n / branching) + 1;",
            "\t}",
            "\tstatic constexpr int calc_offset(int h){",
            "\t\tint s = 0;",
            "\t\tfor(auto n = SIZE; h --; n >>= branching_bits) s += ceil(n);",
            "\t\treturn s;",
            "\t}",
            "\tstatic constexpr int H = calc_height(SIZE);",
            "\ttemplate<size_t ... indices> static constexpr array<int, H + 1> calc_offsets(index_sequence<indices...>){ return {calc_offset(indices)...}; }",
            "\tstatic constexpr auto offset = calc_offsets(make_index_sequence<H + 1>());",
            "\tint n;",
            "\talignas(cache_size) T data[offset[H]]{};",
            "\tF TT; // group operation",
            "\tT T_id; // group identity",
            "\tI T_inv; // group inverse",
            "\tsegment_tree_wide_base(F TT, T T_id, I T_inv): TT(TT), T_id(T_id), T_inv(T_inv){ }",
            "\t[[gnu::target(\"avx2,bmi2,popcnt,lzcnt\")]]",
            "\tvoid _prefetch(int h, int i) const{",
            "\t\t__builtin_prefetch(data + offset[h] + round(i));",
            "\t}",
            "\t[[gnu::target(\"avx2,bmi2,popcnt,lzcnt\")]]",
            "\tvoid build(int n){",
            "\t\tbuild(vector<T>(n, T_id));",
            "\t}",
            "\t[[gnu::target(\"avx2,bmi2,popcnt,lzcnt\")]]",
            "\tvoid build(int n, T x){",
            "\t\tbuild(vector<T>(n, x));",
            "\t}",
            "\t[[gnu::target(\"avx2,bmi2,popcnt,lzcnt\")]]",
            "\ttemplate<class U>",
            "\tvoid build(const vector<U> &a){",
            "\t\tn = (int)a.size();",
            "\t\tassert(round(n) + branching <= SIZE);",
            "\t\tfor(auto i = 0; i < ceil(n); ++ i) data[i] = i < n ? (T)a[i] : T_id;",
            "\t\tfor(auto h = 1; h < H; ++ h) for(auto i = 0; i < ceil(n >> branching_bits * h); ++ i) for(auto j = i << branching_bits, r = min(ceil(n >> branching_bits * (h - 1)), i + 1 << branching_bits); j < r; ++ j) data[offset[h] + i] = TT(data[offset[h] + i], data[offset[h - 1] + j]);",
            "\t\tfor(auto h = 0; h < H; ++ h){",
            "\t\t\tT sum;",
            "\t\t\tfor(auto i = 0; i < ceil(n >> branching_bits * h); ++ i){",
            "\t\t\t\tif(i % branching == 0) sum = T_id;",
            "\t\t\t\tswap(sum, data[offset[h] + i]);",
            "\t\t\t\tsum = TT(data[offset[h] + i], sum);",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "\t[[gnu::target(\"avx2,bmi2,popcnt,lzcnt\")]]",
            "\tT query(int p) const{",
            "\t\tassert(0 <= p && p < n);",
            "\t\treturn TT(T_inv(data[p]), (p + 1) % branching ? data[p + 1] : data[offset[H - 1] + (p + 1 >> branching_bits)]);",
            "\t}",
            "\t[[gnu::target(\"avx2,bmi2,popcnt,lzcnt\")]]",
            "\tT prefix(int r) const{",
            "\t\tassert(0 <= r && r <= n);",
            "\t\tif(!r) return T_id;",
            "\t\tT res = T_id;",
            "\t\tfor(auto h = 0; h < H; ++ h, r >>= branching_bits){",
            "\t\t\tif(h + 1 != H) _prefetch(h + 1, r >> branching_bits);",
            "\t\t\tres = TT(res, data[offset[h] + r]);",
            "\t\t}",
            "\t\treturn res;",
            "\t}",
            "\t[[gnu::target(\"avx2,bmi2,popcnt,lzcnt\")]]",
            "\tT query(int l, int r) const{",
            "\t\tassert(0 <= l && l <= r && r <= n);",
            "\t\tif(l == r) return T_id;",
            "\t\tT res = T_id;",
            "\t\tfor(auto h = 0; h < H; ++ h, l >>= branching_bits, r >>= branching_bits){",
            "\t\t\tif(h + 1 != H){",
            "\t\t\t\t_prefetch(h + 1, l >> branching_bits);",
            "\t\t\t\tif(l >> branching_bits != r >> branching_bits) _prefetch(h + 1, r >> branching_bits);",
            "\t\t\t}",
            "\t\t\tres = TT(res, TT(T_inv(data[offset[h] + l]), data[offset[h] + r]));",
            "\t\t}",
            "\t\treturn res;",
            "\t}",
            "\t[[gnu::target(\"avx2,bmi2,popcnt,lzcnt\")]]",
            "\tvoid update(int p, T _x){",
            "\t\tassert(0 <= p && p < n);",
            "\t\tTwide x = Twide{} + _x;",
            "\t\tfor(auto h = 0; h < H; ++ h, p >>= branching_bits){",
            "\t\t\tif(h + 1 != H) _prefetch(h + 1, p >> branching_bits);",
            "\t\t\tauto a = (Twide *)&data[offset[h] + round(p)];",
            "\t\t\tconst auto suffix_mask = (const Twide *)&precalc.mask[p % branching];",
            "\t\t\tfor(auto i = 0; i < reg_count; ++ i) a[i] = TT(a[i], x & suffix_mask[i]);",
            "\t\t}",
            "\t}",
            "\t[[gnu::target(\"avx2,bmi2,popcnt,lzcnt\")]]",
            "\tvoid set(int p, T x){",
            "\t\tupdate(p, TT(T_inv(query(p)), x));",
            "\t}",
            "\tfriend ostream &operator<<(ostream &out, const segment_tree_wide_base<SIZE, T, F, I> &seg){",
            "\t\tout << \"{\";",
            "\t\tfor(auto i = 0; i < seg.n; ++ i){",
            "\t\t\tout << seg.query(i);",
            "\t\t\tif(i != seg.n - 1) out << \", \";",
            "\t\t}",
            "\t\treturn out << '}';",
            "\t}",
            "};",
            "",
            "// WARNING: DO NOT PASS IN ANYTHING FROM std::functional",
            "template<int SIZE, class T, class F, class I>",
            "auto make_segment_tree_wide(F TT, T T_id, I T_inv){",
            "\treturn segment_tree_wide_base<SIZE, T, F, I>(TT, T_id, T_inv);",
            "}"
        ],
        "description": "tranxuanbach"
    }
}