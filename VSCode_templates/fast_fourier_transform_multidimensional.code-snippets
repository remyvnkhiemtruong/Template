{
    "tranxuanbach": {
        "prefix": "fast_fourier_transform_multidimensional",
        "body": [
            "template<class T, class _transform_1D>",
            "struct fast_fourier_transform_multidimensional_wrapper_base{",
            "\tstatic vector<T> buffer1, buffer2;",
            "\t// Assumes that n is a power of _transform_1D::length",
            "\t// O(n * log(n))",
            "\tstatic void transform(int n, T *p, bool invert = false){",
            "\t\t#ifdef LOCAL",
            "\t\tint power = 1;",
            "\t\twhile(power < n) power *= _transform_1D::length;",
            "\t\tassert(power == n);",
            "\t\t#endif",
            "\t\tif(!invert){",
            "\t\t\tfor(auto len = 1; len < n; len *= _transform_1D::length)",
            "\t\t\t\tfor(auto i = 0; i < n; i += _transform_1D::length * len)",
            "\t\t\t\t\tfor(auto j = 0; j < len; ++ j) _transform_1D::transform(p + i + j, len);",
            "\t\t}",
            "\t\telse{",
            "\t\t\tfor(auto len = 1; len < n; len *= _transform_1D::length)",
            "\t\t\t\tfor(auto i = 0; i < n; i += _transform_1D::length * len)",
            "\t\t\t\t\tfor(auto j = 0; j < len; ++ j) _transform_1D::inverse_transform(p + i + j, len);",
            "\t\t\tT inv = 1 / _transform_1D::coefficient(n);",
            "\t\t\tif(inv != T{1}) for(auto i = 0; i < n; ++ i) p[i] *= inv;",
            "\t\t}",
            "\t}",
            "\t// O(n * log(n))",
            "\tstatic void transform(vector<T> &p, bool invert = false){",
            "\t\ttransform((int)p.size(), p.data(), invert);",
            "\t}",
            "\t// O(n * log(n))",
            "\tstatic vector<T> convolute(const vector<T> &p, const vector<T> &q){",
            "\t\tint n = (int)p.size();",
            "\t\tassert((int)q.size() == n);",
            "\t\tbuffer1.resize(n, 0);",
            "\t\tcopy(p.begin(), p.end(), buffer1.begin());",
            "\t\ttransform(buffer1);",
            "\t\tbuffer2.resize(n, 0);",
            "\t\tcopy(q.begin(), q.end(), buffer2.begin());",
            "\t\ttransform(buffer2);",
            "\t\tfor(auto i = 0; i < n; ++ i) buffer1[i] *= buffer2[i];",
            "\t\ttransform(buffer1, true);",
            "\t\treturn vector<T>(buffer1.begin(), buffer1.begin() + n);",
            "\t}",
            "\t// Destroy p and q",
            "\t// Store the result on p",
            "\t// O(n * log(n))",
            "\tstatic void inplace_convolute(int n, T *p, T *q){",
            "\t\ttransform(n, p), transform(n, q);",
            "\t\tfor(auto i = 0; i < n; ++ i) p[i] *= q[i];",
            "\t\ttransform(n, p, true);",
            "\t}",
            "\t// Destroy p and q",
            "\t// Store the result on p",
            "\t// O(n * log(n))",
            "\tstatic void inplace_square(int n, T *p){",
            "\t\ttransform(n, p);",
            "\t\tfor(auto i = 0; i < n; ++ i) p[i] *= p[i];",
            "\t\ttransform(n, p, true);",
            "\t}",
            "};",
            "template<class T, class U>",
            "vector<T> fast_fourier_transform_multidimensional_wrapper_base<T, U>::buffer1;",
            "template<class T, class U>",
            "vector<T> fast_fourier_transform_multidimensional_wrapper_base<T, U>::buffer2;",
            "",
            "template<class T>",
            "struct _transform_1D_bitwise_xor{",
            "\tstatic constexpr int length = 2;",
            "\tstatic void transform(T *a, int len){",
            "\t\ttie(a[0], a[len]) = tuple{",
            "\t\t\ta[0] + a[len],",
            "\t\t\ta[0] - a[len],",
            "\t\t};",
            "\t}",
            "\tstatic void inverse_transform(T *a, int len){",
            "\t\ttie(a[0], a[len]) = tuple{",
            "\t\t\ta[0] + a[len],",
            "\t\t\ta[0] - a[len],",
            "\t\t};",
            "\t}",
            "\t// inverse_transform(transform(p)) = coefficient(len(p)) * p",
            "\tstatic T coefficient(int n){",
            "\t\treturn n;",
            "\t}",
            "};",
            "template<class T>",
            "struct _transform_1D_bitwise_and{",
            "\tstatic constexpr int length = 2;",
            "\tstatic void transform(T *a, int len){",
            "\t\ta[0] += a[len];",
            "\t}",
            "\tstatic void inverse_transform(T *a, int len){",
            "\t\ta[0] -= a[len];",
            "\t}",
            "\t// inverse_transform(transform(p)) = coefficient(len(p)) * p",
            "\tstatic T coefficient(int n){",
            "\t\treturn 1;",
            "\t}",
            "};",
            "template<class T>",
            "struct _transform_1D_bitwise_or{",
            "\tstatic constexpr int length = 2;",
            "\tstatic void transform(T *a, int len){",
            "\t\ta[len] += a[0];",
            "\t}",
            "\tstatic void inverse_transform(T *a, int len){",
            "\t\ta[len] -= a[0];",
            "\t}",
            "\t// inverse_transform(transform(p)) = coefficient(len(p)) * p",
            "\tstatic T coefficient(int n){",
            "\t\treturn 1;",
            "\t}",
            "};",
            "template<class T>",
            "struct _transform_1D_tritwise_addition_modular{",
            "\tstatic_assert(T::mod() % 3 == 1);",
            "\tstatic constexpr int length = 3;",
            "\tstatic const T root;",
            "\tstatic const T root_sq;",
            "\tstatic void transform(T *a, int len){",
            "\t\ttie(a[0], a[len], a[len << 1]) = tuple{",
            "\t\t\ta[0] + a[len] + a[len << 1],",
            "\t\t\ta[0] + root * a[len] + root_sq * a[len << 1],",
            "\t\t\ta[0] + root_sq * a[len] + root * a[len << 1]",
            "\t\t};",
            "\t}",
            "\tstatic void inverse_transform(T *a, int len){",
            "\t\ttie(a[0], a[len], a[len << 1]) = tuple{",
            "\t\t\ta[0] + a[len] + a[len << 1],",
            "\t\t\ta[0] + root_sq * a[len] + root * a[len << 1],",
            "\t\t\ta[0] + root * a[len] + root_sq * a[len << 1]",
            "\t\t};",
            "\t}",
            "\t// inverse_transform(transform(p)) = coefficient(len(p)) * p",
            "\tstatic T coefficient(int n){",
            "\t\treturn n;",
            "\t}",
            "};",
            "template<class T>",
            "const T _transform_1D_tritwise_addition_modular<T>::root = T::primitive_root().power((T::mod() - 1) / 3);",
            "template<class T>",
            "const T _transform_1D_tritwise_addition_modular<T>::root_sq = root * root;",
            "",
            "template<class T>",
            "using fwht = fast_fourier_transform_multidimensional_wrapper_base<T, _transform_1D_bitwise_xor<T>>;",
            "template<class T>",
            "using bitwise_and_transform = fast_fourier_transform_multidimensional_wrapper_base<T, _transform_1D_bitwise_and<T>>;",
            "template<class T>",
            "using bitwise_or_transform = fast_fourier_transform_multidimensional_wrapper_base<T, _transform_1D_bitwise_or<T>>;",
            "template<class T>",
            "using tritwise_addition_transform = fast_fourier_transform_multidimensional_wrapper_base<T, _transform_1D_tritwise_addition_modular<T>>;"
        ],
        "description": "tranxuanbach"
    }
}