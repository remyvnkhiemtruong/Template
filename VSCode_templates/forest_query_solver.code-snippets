{
    "tranxuanbach": {
        "prefix": "forest_query_solver",
        "body": [
            "// Requires graph",
            "template<bool ENABLE_LCA_SOLVER, bool ENABLE_LEVEL_ANCESTOR_SOLVER>",
            "struct forest_query_solver_base{",
            "\tstatic_assert(ENABLE_LCA_SOLVER || ENABLE_LEVEL_ANCESTOR_SOLVER);",
            "#define ifLCA if constexpr(ENABLE_LCA_SOLVER)",
            "#define ifLA if constexpr(ENABLE_LEVEL_ANCESTOR_SOLVER)",
            "\tint n;",
            "\t// For LCA Solver",
            "\tvector<int> label;",
            "\tvector<int> ascendant;",
            "\tvector<int> head;",
            "\t// For LA Solver",
            "\tstatic constexpr int kappa = 4;",
            "\tstatic constexpr int kappa_prime = (3 * kappa - 1) / (kappa - 2);",
            "\tvector<array<int, 3>> stack;",
            "\tvector<int> valley;",
            "\tvector<int> valley_cnt;",
            "\tvector<int> right;",
            "\tvector<int> jump;",
            "\tvector<vector<int>> ladder;",
            "\t// Common",
            "\tvector<int> order;",
            "\tvector<int> pos;",
            "\tvector<int> end;",
            "\tvector<int> root_of;",
            "\tvector<int> depth;",
            "\tvector<int> was;",
            "\tvoid init(int n){",
            "\t\tassert(n >= 1);",
            "\t\tthis->n = n;",
            "\t\tifLCA{",
            "\t\t\tlabel.assign(n, -1);",
            "\t\t\tascendant.assign(n, -1);",
            "\t\t\thead.assign(n + 1, -1);",
            "\t\t}",
            "\t\tifLA{",
            "\t\t\tstack.assign(2 * n, {});",
            "\t\t\tvalley.assign(2 * n, -1);",
            "\t\t\tvalley_cnt.assign(2 * n - 1, -1);",
            "\t\t\tright.assign(n + 1, -1);",
            "\t\t\tjump.assign(2 * n - 1, -1);",
            "\t\t\tladder.assign(2 * n - 1, {});",
            "\t\t}",
            "\t\torder.clear();",
            "\t\tpos.assign(n, -1);",
            "\t\tend.assign(n, -1);",
            "\t\troot_of.assign(n, -1);",
            "\t\tdepth.assign(n, -1);",
            "\t\twas.assign(n, -2);",
            "\t\tattempt = -1;",
            "\t}",
            "\tint attempt;",
            "\t// O(n)",
            "\ttemplate<class T>",
            "\tvoid build(const graph<T> &g, const vector<int> &src){",
            "\t\tassert(g.n <= n);",
            "\t\t++ attempt;",
            "\t\torder.clear();",
            "\t\tint timer = 1;",
            "\t\tauto dfs = [&](auto self, int u, int pe)->void{",
            "\t\t\tassert(was[u] != attempt);",
            "\t\t\twas[u] = attempt;",
            "\t\t\tpos[u] = (int)order.size();",
            "\t\t\torder.push_back(u);",
            "\t\t\tifLCA label[u] = timer ++;",
            "\t\t\tfor(auto id: g.adj[u]){",
            "\t\t\t\tif(id == pe || g.ignore && g.ignore(id)) continue;",
            "\t\t\t\tint v = g(u, id);",
            "\t\t\t\troot_of[v] = root_of[u];",
            "\t\t\t\tdepth[v] = depth[u] + 1;",
            "\t\t\t\tself(self, v, id);",
            "\t\t\t\tifLCA if(__builtin_ctz(label[u]) < __builtin_ctz(label[v])) label[u] = label[v];",
            "\t\t\t\torder.push_back(u);",
            "\t\t\t}",
            "\t\t\tend[u] = (int)order.size();",
            "\t\t};",
            "\t\tfor(auto r: src){",
            "\t\t\tif(was[r] == attempt) continue;",
            "\t\t\tdepth[r] = 0;",
            "\t\t\troot_of[r] = r;",
            "\t\t\tdfs(dfs, r, -1);",
            "\t\t}",
            "\t\tifLCA for(auto i = 0; i < (int)order.size(); ++ i){",
            "\t\t\tint u = order[i];",
            "\t\t\tif(pos[u] != i) continue;",
            "\t\t\tif(root_of[u] == u) ascendant[u] = label[u];",
            "\t\t\tfor(auto id: g.adj[u]){",
            "\t\t\t\tif(g.ignore && g.ignore(id)) continue;",
            "\t\t\t\tint v = g(u, id);",
            "\t\t\t\tif(pos[v] < pos[u] || end[u] < end[v]) continue;",
            "\t\t\t\tascendant[v] = ascendant[u];",
            "\t\t\t\tif(label[v] != label[u]){",
            "\t\t\t\t\thead[label[v]] = u;",
            "\t\t\t\t\tascendant[v] += label[v] & -label[v];",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t}",
            "\t\tifLA{",
            "\t\t\tint si = 0, ymin = numeric_limits<int>::max(), ymax = numeric_limits<int>::min();",
            "\t\t\tstack[si ++] = {0, numeric_limits<int>::min(), numeric_limits<int>::max()};",
            "\t\t\tfor(auto i = 0; i < (int)order.size(); ++ i){",
            "\t\t\t\tint u = order[i], y = n - 1 - depth[u];",
            "\t\t\t\tvalley_cnt[i] = 0;",
            "\t\t\t\tymin = min(ymin, y);",
            "\t\t\t\tymax = max(ymax, y);",
            "\t\t\t\twhile(stack[si - 1][1] >= y) -- si;",
            "\t\t\t\tif(stack[si - 1][2] >= y){",
            "\t\t\t\t\tvalley[i] = i;",
            "\t\t\t\t\tif(stack[si - 1][2] > y) stack[si ++] = {i, y, y};",
            "\t\t\t\t}",
            "\t\t\t\telse{",
            "\t\t\t\t\twhile(stack[si - 2][2] < y) -- si;",
            "\t\t\t\t\tvalley[i] = stack[si - 1][0];",
            "\t\t\t\t\tif(stack[si - 2][2] > y) stack[si - 1][2] = y;",
            "\t\t\t\t\telse -- si;",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t\tvalley[(int)order.size()] = (int)order.size() - 1;",
            "\t\t\tfor(auto i = 0; i < (int)order.size(); ++ i) ++ valley_cnt[valley[i]];",
            "\t\t\tfor(auto y = ymin; y <= ymax + 1; ++ y) right[y] = (int)order.size();",
            "\t\t\tfor(auto i = (int)order.size() - 1; i >= 0; -- i){",
            "\t\t\t\tint u = order[i], y = n - 1 - depth[u];",
            "\t\t\t\tright[y] = i;",
            "\t\t\t\tint h = ymax - y;",
            "\t\t\t\tif(0 < i && i < (int)order.size() - 2) h = min(h, max(kappa - 1, kappa_prime * (valley_cnt[i] - 1) - 2));",
            "\t\t\t\tladder[i].resize(h);",
            "\t\t\t\tfor(auto yi = 0; yi < h; ++ yi) ladder[i][yi] = right[y + yi + 1];",
            "\t\t\t\tjump[i] = i ? valley[right[min(ymax + 1, y + (kappa - 2 << __builtin_ctz(i)))]] : 0;",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "\ttemplate<class T>",
            "\tvoid build_all(const graph<T> &g){",
            "\t\tvector<int> src(g.n);",
            "\t\tiota(src.begin(), src.end(), 0);",
            "\t\tbuild(g, src);",
            "\t}",
            "\t// Check if u is visited during the last build call",
            "\tbool visited(int u) const{",
            "\t\tassert(0 <= u && u < n);",
            "\t\treturn was[u] == attempt;",
            "\t}",
            "\t// O(1)",
            "\tbool ancestor_of(int u, int v) const{",
            "\t\t#ifdef LOCAL",
            "\t\tassert(visited(u) && visited(v));",
            "\t\t#endif",
            "\t\treturn pos[u] <= pos[v] && end[v] <= end[u];",
            "\t}",
            "\t// Assumes u and v are on the same component",
            "\t// O(1)",
            "\tint lca(int u, int v) const{",
            "\t\tstatic_assert(ENABLE_LCA_SOLVER);",
            "\t\tassert(visited(u) && visited(v) && root_of[u] == root_of[v]);",
            "\t\tauto [x, y] = minmax(label[u], label[v]);",
            "\t\tint k = ascendant[u] & ascendant[v] & -(1 << __lg(x - 1 ^ y));",
            "\t\tif(ascendant[u] != k){",
            "\t\t\tint t = 1 << __lg(ascendant[u] ^ k);",
            "\t\t\tu = head[label[u] & -t | t];",
            "\t\t}",
            "\t\tif(ascendant[v] != k){",
            "\t\t\tint t = 1 << __lg(ascendant[v] ^ k);",
            "\t\t\tv = head[label[v] & -t | t];",
            "\t\t}",
            "\t\treturn depth[u] < depth[v] ? u : v;",
            "\t}",
            "\t// Assumes u and v are on the same component",
            "\t// O(1)",
            "\tint steps(int u, int v, int w = -1) const{",
            "\t\tstatic_assert(ENABLE_LCA_SOLVER);",
            "\t\tassert(visited(u) && visited(v) && root_of[u] == root_of[v]);",
            "\t\treturn -2 * depth[~w ? w : lca(u, v)] + depth[u] + depth[v];",
            "\t}",
            "\t// Check if w lies in u-v path",
            "\t// O(1)",
            "\tbool on_path(int u, int v, int w) const{",
            "\t\tstatic_assert(ENABLE_LCA_SOLVER);",
            "\t\tassert(visited(u) && visited(v) && visited(w) && root_of[u] == root_of[v] && root_of[v] == root_of[w]);",
            "\t\treturn steps(u, v) == steps(u, w) + steps(w, v);",
            "\t}",
            "\t// Check if u-v path and w-x path intersect, and find their interseciton if they intersect",
            "\t// O(1)",
            "\toptional<pair<int, int>> intersect_path(int u, int v, int w, int x) const{",
            "\t\tstatic_assert(ENABLE_LCA_SOLVER);",
            "\t\tassert(visited(u) && visited(v) && visited(w) && visited(x) && root_of[u] == root_of[v] && root_of[v] == root_of[w] && root_of[w] == root_of[x]);",
            "\t\tint optl = -1, optr = -1;",
            "\t\tfor(auto y: {lca(u, w), lca(u, x), lca(v, w), lca(v, x)}){",
            "\t\t\tif(!on_path(u, v, y) || !on_path(w, x, y)) continue;",
            "\t\t\tif(!~optl) optl = optr = y;",
            "\t\t\telse if(depth[optl] < depth[y]) optr = optl, optl = y;",
            "\t\t\telse if(depth[optr] < depth[y]) optr = y;",
            "\t\t}",
            "\t\tif(!~optl) return {};",
            "\t\treturn pair{optl, optr};",
            "\t}",
            "\t// Get the k-th ancestor of u",
            "\t// O(1)",
            "\tint find_ancestor_by_order(int u, int k) const{",
            "\t\tstatic_assert(ENABLE_LEVEL_ANCESTOR_SOLVER);",
            "\t\tassert(visited(u) && 0 <= k && k <= depth[u]);",
            "\t\tif(k == 0) return u;",
            "\t\tif(k < kappa) return order[ladder[pos[u]][k - 1]];",
            "\t\tint p = __lg(k / kappa), x = pos[u] >> p << p;",
            "\t\tif(x > 0 && (x & (1 << p + 1) - 1) == 0) x -= 1 << p;",
            "\t\treturn order[ladder[jump[x]][k + depth[order[jump[x]]] - depth[u] - 1]];",
            "\t}",
            "\t// Get the k-th vertex in the u-v path",
            "\t// Assumes u and v are on the same component",
            "\t// O(1)",
            "\tint find_vertex_by_order(int u, int v, int k) const{",
            "\t\tstatic_assert(ENABLE_LCA_SOLVER && ENABLE_LEVEL_ANCESTOR_SOLVER);",
            "\t\tassert(visited(u) && visited(v) && root_of[u] == root_of[v] && 0 <= k);",
            "\t\tif(k == 0) return u;",
            "\t\tint w = lca(u, v);",
            "\t\tif(k <= depth[u] - depth[w]) return find_ancestor_by_order(u, k);",
            "\t\telse return find_ancestor_by_order(v, depth[u] + depth[v] - 2 * depth[w] - k);",
            "\t}",
            "\t// For an ancestor p of u, pred(p) is T, ..., T, F, ..., F in decreasing order of depth",
            "\t// Returns the furthest p with T",
            "\t// O(log(n))",
            "\tint find_furthest_ancestor(int u, auto pred) const{",
            "\t\tstatic_assert(ENABLE_LEVEL_ANCESTOR_SOLVER);",
            "\t\tassert(visited(u) && pred(u));",
            "\t\tif(root_of[u] == u) return u;",
            "\t\tfor(auto bit = __lg(depth[u]); bit >= 0; -- bit) if(1 << bit <= depth[u]){",
            "\t\t\tint v = find_ancestor_by_order(u, 1 << bit);",
            "\t\t\tif(pred(v)) u = v;",
            "\t\t}",
            "\t\treturn u;",
            "\t}",
            "\t// For a vertex w in u-v path, pred(w) is T, ..., T, F, ..., F in order from u to v",
            "\t// Returns the furthest w with T",
            "\t// O(log(n))",
            "\tint find_furthest_vertex(int u, int v, auto pred) const{",
            "\t\tstatic_assert(ENABLE_LCA_SOLVER && ENABLE_LEVEL_ANCESTOR_SOLVER);",
            "\t\tassert(visited(u) && visited(v) && root_of[u] == root_of[v] && pred(u));",
            "\t\tif(pred(v)) return v;",
            "\t\tint w = lca(u, v);",
            "\t\tif(!pred(w)){",
            "\t\t\tfor(auto bit = __lg(depth[u] - depth[w]); bit >= 0; -- bit) if(1 << bit <= depth[u] - depth[w]){",
            "\t\t\t\tint v = find_ancestor_by_order(u, 1 << bit);",
            "\t\t\t\tif(pred(v)) u = v;",
            "\t\t\t}",
            "\t\t\treturn u;",
            "\t\t}",
            "\t\telse{",
            "\t\t\tfor(auto bit = __lg(depth[v] - depth[w]); bit >= 0; -- bit) if(1 << bit <= depth[v] - depth[w]){",
            "\t\t\t\tint u = find_ancestor_by_order(v, 1 << bit);",
            "\t\t\t\tif(!pred(u)) v = u;",
            "\t\t\t}",
            "\t\t\treturn order[pos[v] - 1];",
            "\t\t}",
            "\t}",
            "#undef ifLCA",
            "#undef ifLA",
            "};",
            "",
            "// Source: https://github.com/programming-team-code/programming_team_code/blob/main/graphs/linear_lca/linear_lca.hpp",
            "auto make_lca_solver(){",
            "\treturn forest_query_solver_base<true, false>();",
            "}",
            "// Source: Still Simpler Static Level Ancestors",
            "auto make_la_solver(){",
            "\treturn forest_query_solver_base<false, true>();",
            "}",
            "auto make_forest_query_solver(){",
            "\treturn forest_query_solver_base<true, true>();",
            "}"
        ],
        "description": "tranxuanbach"
    }
}