{
    "tranxuanbach": {
        "prefix": "small_to_large_on_forest",
        "body": [
            "// Requires graph",
            "struct small_to_large_on_forest{",
            "\tint n;",
            "\tvector<vector<int>> adj;",
            "\tvector<int> size, pv, pe, order, pos, end, root;",
            "\tsmall_to_large_on_forest(int n): n(n), adj(n), size(n), pv(n), pe(n), pos(n), end(n), root(n), was(n){ }",
            "\tint iter = 0;",
            "\tvector<int> was;",
            "\tvoid init(const graph<auto> &g){",
            "\t\tvector<int> roots(g.n);",
            "\t\tiota(roots.begin(), roots.end(), 0);",
            "\t\tinit(g, roots);",
            "\t}",
            "\tvoid init(const graph<auto> &g, const vector<int> &roots){",
            "\t\tassert(n == g.n);",
            "\t\torder.clear();",
            "\t\t++ iter;",
            "\t\tauto dfs_size = [&](auto self, int u)->void{",
            "\t\t\twas[u] = iter;",
            "\t\t\tadj[u].clear();",
            "\t\t\tsize[u] = 1;",
            "\t\t\tfor(auto id: g.adj[u]){",
            "\t\t\t\tif(g.ignore && g.ignore(id)) continue;",
            "\t\t\t\tauto &e = g.edge[id];",
            "\t\t\t\tint v = u ^ e.from ^ e.to;",
            "\t\t\t\tif(was[v] == iter) continue;",
            "\t\t\t\tpv[v] = u;",
            "\t\t\t\tpe[v] = id;",
            "\t\t\t\troot[v] = root[u];",
            "\t\t\t\tself(self, v);",
            "\t\t\t\tsize[u] += size[v];",
            "\t\t\t\tadj[u].push_back(v);",
            "\t\t\t\tif(size[adj[u][0]] < size[v]) swap(adj[u].front(), adj[u].back());",
            "\t\t\t}",
            "\t\t};",
            "\t\tauto dfs = [&](auto self, int u)->void{",
            "\t\t\tpos[u] = (int)order.size();",
            "\t\t\torder.push_back(u);",
            "\t\t\tfor(auto v: adj[u]) self(self, v);",
            "\t\t\tend[u] = (int)order.size();",
            "\t\t};",
            "\t\tfor(auto u: roots) if(was[u] != iter){",
            "\t\t\troot[u] = u;",
            "\t\t\tpv[u] = pe[u] = -1;",
            "\t\t\tdfs_size(dfs_size, u);",
            "\t\t\tdfs(dfs, u);",
            "\t\t}",
            "\t}",
            "\t// insert_subtr(u): insert all vertices in the subtree of u into the state.",
            "\t// insert_root(u): insert vertex u into the state.",
            "\t// answer(u, flag): answer for the subtree of u, flag indicates whether u is included or not.",
            "\t// clear_subtr(u): erase every vertex in the subtree of u from the state.",
            "\t// Sum of subtree sizes of u over all insert_subtr(u) calls is O(n * log(n)).",
            "\t// insert_root(u), answer(u, false), and answer(u, true) are called once for each u.",
            "\t// Sum of subtree size of vertex u for all clear_subtr(u) calls is O(n).",
            "\tvoid run(auto insert_subtr, auto insert_root, auto clear_subtr, auto answer){",
            "\t\tfor(auto r: order) if(root[r] == r) for(auto i = end[r] - 1; i >= pos[r]; -- i){",
            "\t\t\tint u = order[i];",
            "\t\t\tfor(auto j = 1; j < (int)adj[u].size(); ++ j) insert_subtr(adj[u][j]);",
            "\t\t\tanswer(u, false), insert_root(u), answer(u, true);",
            "\t\t\tif(!~pv[u] || adj[pv[u]][0] != u) clear_subtr(u);",
            "\t\t}",
            "\t}",
            "};"
        ],
        "description": "tranxuanbach"
    }
}