{
    "tranxuanbach": {
        "prefix": "colorful_interval_set",
        "body": [
            "// B: coordinate type, C: color type",
            "template<class B, class C>",
            "struct colorful_interval_set{",
            "\tmap<array<B, 2>, C> data;",
            "\tcolorful_interval_set(C initial_color = {}): data({{{numeric_limits<B>::min(), numeric_limits<B>::max()}, initial_color}}){ }",
            "\tcolorful_interval_set(const map<array<B, 2>, C> &data): data(data){ assert(is_valid(data)); }",
            "\t// is_valid(*this) holds after all operations",
            "\tstatic bool is_valid(const map<array<B, 2>, C> &data){",
            "\t\tif(data.empty() || data.begin()->first[0] != numeric_limits<B>::min() || data.rbegin()->first[1] != numeric_limits<B>::max()) return false;",
            "\t\tfor(auto it = data.begin(); next(it) != data.end(); ++ it) if(it->first[1] != next(it)->first[0] || it->second == next(it)->second) return false;",
            "\t\treturn true;",
            "\t}",
            "\tauto belongs(B p){",
            "\t\treturn prev(data.upper_bound({p, numeric_limits<B>::max()}));",
            "\t}",
            "\t// Cover the range [ql, qr) with the color c",
            "\t// process(l, r, pc): color of non-empty range [l, r) is changed from pc to c",
            "\t// The set of intervals [l, r) accessed by process() forms a partition of [ql, qr) in order of increasing l",
            "\t// Amortized O(1) process calls",
            "\toptional<typename map<array<B, 2>, C>::iterator>",
            "\tcover(B ql, B qr, C c, auto process){",
            "\t\tassert(ql <= qr);",
            "\t\tif(ql == qr) return {};",
            "\t\tarray<B, 2> I{ql, ql};",
            "\t\tauto it = data.lower_bound(I);",
            "\t\tif(it != data.begin() && ql < prev(it)->first[1]){",
            "\t\t\tit = prev(it);",
            "\t\t\tauto x = *it;",
            "\t\t\tit = data.erase(it);",
            "\t\t\tdata.insert(it, {{x.first[0], ql}, x.second});",
            "\t\t\tit = data.insert(it, {{ql, x.first[1]}, x.second});",
            "\t\t}",
            "\t\twhile(it != data.end() && it->first[0] < qr){",
            "\t\t\tif(qr < it->first[1]){",
            "\t\t\t\tauto x = *it;",
            "\t\t\t\tit = data.erase(it);",
            "\t\t\t\tit = data.insert(it, {{x.first[0], qr}, x.second});",
            "\t\t\t\tdata.insert(next(it), {{qr, x.first[1]}, x.second});",
            "\t\t\t}",
            "\t\t\tprocess(it->first[0], min(qr, it->first[1]), it->second);",
            "\t\t\tI = {min(I[0], it->first[0]), max(I[1], it->first[1])};",
            "\t\t\tit = data.erase(it);",
            "\t\t}",
            "\t\tif(it != data.begin() && prev(it)->second == c){",
            "\t\t\tI[0] = prev(it)->first[0];",
            "\t\t\tdata.erase(prev(it));",
            "\t\t}",
            "\t\tif(it != data.end() && it->second == c){",
            "\t\t\tI[1] = it->first[1];",
            "\t\t\tit = data.erase(it);",
            "\t\t}",
            "\t\treturn data.insert(it, {I, c});",
            "\t}",
            "\toptional<typename map<array<B, 2>, C>::iterator>",
            "\tcover(B ql, B qr, C c){",
            "\t\treturn cover(ql, qr, c, [&](B, B, C){  });",
            "\t}",
            "\t// new_color(l, r, c): returns the new color for the non-empty range [l, r), previously colored with c",
            "\t// The set of intervals [l, r) accessed by new_color() forms a partition of [ql, qr) in order of increasing l",
            "\t// O(Number of color ranges affected)",
            "\tvoid recolor(B ql, B qr, auto new_color){",
            "\t\tassert(ql <= qr);",
            "\t\tif(ql == qr) return;",
            "\t\tauto it = data.lower_bound({ql, ql});",
            "\t\tif(it != data.begin() && ql < prev(it)->first[1]){",
            "\t\t\tit = prev(it);",
            "\t\t\tauto [inter, c] = *it;",
            "\t\t\tit = data.erase(it);",
            "\t\t\tdata.insert(it, {{inter[0], ql}, c});",
            "\t\t\tit = data.insert(it, {{ql, inter[1]}, c});",
            "\t\t}",
            "\t\twhile(it != data.end() && it->first[0] < qr){",
            "\t\t\tif(qr < it->first[1]){",
            "\t\t\t\tauto x = *it;",
            "\t\t\t\tit = data.erase(it);",
            "\t\t\t\tit = data.insert(it, {{x.first[0], qr}, x.second});",
            "\t\t\t\tdata.insert(next(it), {{qr, x.first[1]}, x.second});",
            "\t\t\t}",
            "\t\t\tit->second = new_color(it->first[0], it->first[1], it->second);",
            "\t\t\tif(it != data.begin() && prev(it)->second == it->second){",
            "\t\t\t\tarray<B, 2> I{prev(it)->first[0], it->first[1]};",
            "\t\t\t\tC c = it->second;",
            "\t\t\t\tdata.erase(prev(it));",
            "\t\t\t\tit = data.erase(it);",
            "\t\t\t\tit = data.insert(it, {I, c});",
            "\t\t\t}",
            "\t\t\t++ it;",
            "\t\t}",
            "\t\tif(it != data.begin() && it != data.end() && prev(it)->second == it->second){",
            "\t\t\tarray<B, 2> I{prev(it)->first[0], it->first[1]};",
            "\t\t\tC c = it->second;",
            "\t\t\tdata.erase(prev(it));",
            "\t\t\tit = data.erase(it);",
            "\t\t\tit = data.insert(it, {I, c});",
            "\t\t}",
            "\t}",
            "\tfriend ostream &operator<<(ostream &out, const colorful_interval_set &cis){",
            "\t\tout << \"{\";",
            "\t\tfor(auto it = cis.data.begin(); it != cis.data.end(); ++ it){",
            "\t\t\tauto [inter, c] = *it;",
            "\t\t\tauto [l, r] = inter;",
            "\t\t\tout << \"[\" << l << \", \" << r << \"){\" << c << \"}\";",
            "\t\t\tif(next(it) != cis.data.end()) out << \", \";",
            "\t\t}",
            "\t\treturn out << \"}\";",
            "\t}",
            "\t// new_color(l, r, c, d): returns the new color for the non-empty range [l, r), where s is colored with c and t is colored with d",
            "\t// The set of intervals [l, r) accessed by new_color() forms a partition of [INT_MIN, INT_MAX] in order of increasing l",
            "\t// O(Number of color ranges affected)",
            "\tfriend colorful_interval_set merge(const colorful_interval_set &s, const colorful_interval_set &t, auto new_color){",
            "\t\tmap<array<B, 2>, C> res;",
            "\t\tfor(auto it_s = s.data.begin(), it_t = t.data.begin(); it_s != s.data.end() && it_t != t.data.end(); ){",
            "\t\t\tB l = max(it_s->first[0], it_t->first[0]), r;",
            "\t\t\tC c;",
            "\t\t\tif(it_s->first[1] <= it_t->first[1]){",
            "\t\t\t\tr = it_s->first[1];",
            "\t\t\t\tif(l == r){",
            "\t\t\t\t\t++ it_s;",
            "\t\t\t\t\tcontinue;",
            "\t\t\t\t}",
            "\t\t\t\tc = new_color(l, r, it_s->second, it_t->second);",
            "\t\t\t\t++ it_s;",
            "\t\t\t}",
            "\t\t\telse{",
            "\t\t\t\tr = it_t->first[1];",
            "\t\t\t\tif(l == r){",
            "\t\t\t\t\t++ it_t;",
            "\t\t\t\t\tcontinue;",
            "\t\t\t\t}",
            "\t\t\t\tc = new_color(l, r, it_s->second, it_t->second);",
            "\t\t\t\t++ it_t;",
            "\t\t\t}",
            "\t\t\tif(!res.empty() && res.rbegin()->second == c){",
            "\t\t\t\tl = res.rbegin()->first[0];",
            "\t\t\t\tres.erase(prev(res.end()));",
            "\t\t\t}",
            "\t\t\tres.insert(res.end(), {{l, r}, c});",
            "\t\t}",
            "\t\treturn res;",
            "\t}",
            "};"
        ],
        "description": "tranxuanbach"
    }
}