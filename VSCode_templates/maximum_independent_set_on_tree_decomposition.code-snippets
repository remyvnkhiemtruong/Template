{
    "tranxuanbach": {
        "prefix": "maximum_independent_set_on_tree_decomposition",
        "body": [
            "// O(n * 2^w * w) where w is the treewidth",
            "// Requires graph",
            "template<class T, class U>",
            "pair<T, vector<int>> maximum_independent_set_on_tree_decomposition(const graph<U> &g, const vector<vector<int>> &Dbag, const vector<array<int, 2>> &Dedge, vector<T> w = {}){",
            "\tif(w.empty()) w.assign(g.n, T(1));",
            "\tfor(auto &b: Dbag){",
            "\t\tassert((int)b.size() <= 30);",
            "\t\tassert(is_sorted(b.begin(), b.end()));",
            "\t}",
            "\tauto adj = g.get_adjacency_list();",
            "\tvector<vector<int>> Dadj((int)Dbag.size());",
            "\tfor(auto &[Du, Dv]: Dedge) Dadj[Du].push_back(Dv), Dadj[Dv].push_back(Du);",
            "\t// mask of nodes not on its decomp parent",
            "\tvector<int> difference_mask((int)Dbag.size());",
            "\tvector<vector<int>> local_adj((int)Dbag.size());",
            "\tvector<vector<int>> mapper((int)Dbag.size());",
            "\tvector<vector<T>> dp((int)Dbag.size());",
            "\tvector<int> Dvis((int)Dbag.size());",
            "\tauto dfs = [&](auto self, int Du)->void{",
            "\t\tDvis[Du] = true;",
            "\t\tint s = (int)Dbag[Du].size();",
            "\t\tdifference_mask[Du] = (1 << s) - 1;",
            "\t\tlocal_adj[Du].resize(s);",
            "\t\tfor(auto i = 0; i < s; ++ i){",
            "\t\t\tint u = Dbag[Du][i];",
            "\t\t\tfor(auto j = i; j < s; ++ j){",
            "\t\t\t\tint v = Dbag[Du][j];",
            "\t\t\t\tif(binary_search(adj[u].begin(), adj[u].end(), v)){",
            "\t\t\t\t\tlocal_adj[Du][i] |= 1 << j;",
            "\t\t\t\t\tlocal_adj[Du][j] |= 1 << i;",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t}",
            "\t\tdp[Du].resize(1 << s);",
            "\t\tT sum = 0;",
            "\t\tfor(auto mask = 1; mask < 1 << s; ++ mask){",
            "\t\t\tfor(auto i = 0; i < s; ++ i){",
            "\t\t\t\tif(mask & 1 << i){",
            "\t\t\t\t\tsum += w[Dbag[Du][i]];",
            "\t\t\t\t\tbreak;",
            "\t\t\t\t}",
            "\t\t\t\tsum -= w[Dbag[Du][i]];",
            "\t\t\t}",
            "\t\t\tdp[Du][mask] = sum;",
            "\t\t}",
            "\t\tfor(auto t = 0; t < (int)Dadj[Du].size(); ++ t){",
            "\t\t\tint Dv = Dadj[Du][t];",
            "\t\t\tDadj[Dv].erase(find(Dadj[Dv].begin(), Dadj[Dv].end(), Du));",
            "\t\t\tself(self, Dv);",
            "\t\t\tmapper[Dv].resize(s, -1);",
            "\t\t\tfor(auto i = 0; i < (int)Dbag[Dv].size(); ++ i){",
            "\t\t\t\tint u = Dbag[Dv][i];",
            "\t\t\t\tif(binary_search(Dbag[Du].begin(), Dbag[Du].end(), u)) difference_mask[Dv] ^= 1 << i;",
            "\t\t\t}",
            "\t\t\tfor(auto i = 0; i < s; ++ i){",
            "\t\t\t\tint u = Dbag[Du][i];",
            "\t\t\t\tauto it = lower_bound(Dbag[Dv].begin(), Dbag[Dv].end(), u);",
            "\t\t\t\tif(it != Dbag[Dv].end() && *it == u) mapper[Dv][i] = it - Dbag[Dv].begin();",
            "\t\t\t}",
            "\t\t\tfor(auto mask = 0; mask < 1 << s; ++ mask){",
            "\t\t\t\tint nmask = difference_mask[Dv];",
            "\t\t\t\tT common = 0;",
            "\t\t\t\tfor(auto i = 0; i < s; ++ i) if(mask & 1 << i && ~mapper[Dv][i]){",
            "\t\t\t\t\tnmask |= 1 << mapper[Dv][i];",
            "\t\t\t\t\tcommon += w[Dbag[Du][i]];",
            "\t\t\t\t}",
            "\t\t\t\tdp[Du][mask] += dp[Dv][nmask] - common;",
            "\t\t\t}",
            "\t\t}",
            "\t\tfor(auto mask = 0; mask < 1 << s; ++ mask){",
            "\t\t\tint adjmask = 0;",
            "\t\t\tfor(auto i = 0; i < s; ++ i) if(mask & 1 << i) adjmask |= local_adj[Du][i];",
            "\t\t\tif(mask & adjmask) dp[Du][mask] = 0;",
            "\t\t\tfor(auto i = 0; i < s; ++ i) if(mask & difference_mask[Du] & 1 << i) dp[Du][mask] = max(dp[Du][mask], dp[Du][mask ^ 1 << i]);",
            "\t\t}",
            "\t};",
            "\tfor(auto Du = 0; Du < (int)Dbag.size(); ++ Du) if(!Dvis[Du]) dfs(dfs, Du);",
            "\tvector<int> iset;",
            "\tauto recover = [&](auto self, int Du, int mask)->void{",
            "\t\tDvis[Du] = true;",
            "\t\tint s = (int)Dbag[Du].size();",
            "\t\tfor(auto i = 0; i < s; ++ i) if(mask & difference_mask[Du] & 1 << i && dp[Du][mask] == dp[Du][mask ^ 1 << i]) mask ^= 1 << i;",
            "\t\tfor(auto i = 0; i < s; ++ i) if(mask & difference_mask[Du] & 1 << i) iset.push_back(Dbag[Du][i]);",
            "\t\tfor(auto Dv: Dadj[Du]){",
            "\t\t\tint nmask = difference_mask[Dv];",
            "\t\t\tfor(auto i = 0; i < s; ++ i) if(mask & 1 << i && ~mapper[Dv][i]) nmask |= 1 << mapper[Dv][i];",
            "\t\t\tself(self, Dv, nmask);",
            "\t\t}",
            "\t};",
            "\tfill(Dvis.begin(), Dvis.end(), false);",
            "\tT res = 0;",
            "\tfor(auto Du = 0; Du < (int)Dbag.size(); ++ Du) if(!Dvis[Du]){",
            "\t\tint mask = max_element(dp[Du].begin(), dp[Du].end()) - dp[Du].begin();",
            "\t\tres += dp[Du][mask];",
            "\t\trecover(recover, Du, mask);",
            "\t}",
            "\treturn {res, iset};",
            "}"
        ],
        "description": "tranxuanbach"
    }
}