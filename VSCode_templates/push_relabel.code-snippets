{
    "tranxuanbach": {
        "prefix": "push_relabel",
        "body": [
            "// Requires flow_network",
            "template<class T>",
            "struct push_relabel{",
            "\tstatic constexpr T eps = (T)1e-9, inf = numeric_limits<T>::max();",
            "\tflow_network<T> &F;",
            "\tvector<T> ec, H;",
            "\tvector<int> cur, co;",
            "\tvector<vector<int>> hs;",
            "\tpush_relabel(flow_network<T> &F): F(F), ec(F.n), cur(F.n), H(F.n), co(F.n << 1), hs(F.n << 1){ }",
            "\t// Find a maximum source-sink flow",
            "\t// O(V^2 * sqrt(E)) with gap heuristic",
            "\tT maximum_flow(int source, int sink){",
            "\t\tassert(0 <= source && source < F.n && 0 <= sink && sink < F.n);",
            "\t\tint n = F.n;",
            "\t\tfill(ec.begin(), ec.end(), 0);",
            "\t\tec[sink] = 1;",
            "\t\tfill(cur.begin(), cur.end(), 0);",
            "\t\tfill(H.begin(), H.end(), 0);",
            "\t\tH[source] = n;",
            "\t\tfill(co.begin(), co.end(), 0);",
            "\t\tco[0] = n - 1;",
            "\t\tfill(hs.begin(), hs.end(), vector<int>{});",
            "\t\tfor(auto id: F.adj[source]){",
            "\t\t\tauto &e = F.edge[id];",
            "\t\t\tif(ec[e.to] <= eps && e.capacity - e.flow > eps) hs[H[e.to]].push_back(e.to);",
            "\t\t\tec[e.from] -= e.capacity - e.flow;",
            "\t\t\tec[e.to] += e.capacity - e.flow;",
            "\t\t\tF.add_flow(id, e.capacity - e.flow);",
            "\t\t}",
            "\t\tif(hs[0].empty()) return -ec[source];",
            "\t\tfor(auto hi = 0; hi >= 0; ){",
            "\t\t\tint u = hs[hi].back();",
            "\t\t\ths[hi].pop_back();",
            "\t\t\twhile(ec[u] > eps){",
            "\t\t\t\tif(cur[u] == (int)F.adj[u].size()){",
            "\t\t\t\t\tH[u] = inf;",
            "\t\t\t\t\tfor(auto i = 0; i < (int)F.adj[u].size(); ++ i){",
            "\t\t\t\t\t\tauto &e = F.edge[F.adj[u][i]];",
            "\t\t\t\t\t\tif(e.capacity - e.flow > eps && H[u] - 1 > H[e.to]){",
            "\t\t\t\t\t\t\tH[u] = H[e.to] + 1;",
            "\t\t\t\t\t\t\tcur[u] = i;",
            "\t\t\t\t\t\t}",
            "\t\t\t\t\t}",
            "\t\t\t\t\tif(++ co[H[u]], !-- co[hi] && hi < n) for(auto i = 0; i < n; ++ i) if(hi < H[i] && H[i] < n){",
            "\t\t\t\t\t\t-- co[H[i]];",
            "\t\t\t\t\t\tH[i] = n + 1;",
            "\t\t\t\t\t}",
            "\t\t\t\t\thi = H[u];",
            "\t\t\t\t}",
            "\t\t\t\telse{",
            "\t\t\t\t\tauto &e = F.edge[F.adj[u][cur[u]]];",
            "\t\t\t\t\tif(e.capacity - e.flow > eps && H[u] == H[e.to] + 1){",
            "\t\t\t\t\t\tauto f = min(ec[u], e.capacity - e.flow);",
            "\t\t\t\t\t\tif(ec[e.to] <= eps && f > eps) hs[H[e.to]].push_back(e.to);",
            "\t\t\t\t\t\tec[e.from] -= f;",
            "\t\t\t\t\t\tec[e.to] += f;",
            "\t\t\t\t\t\tF.add_flow(F.adj[u][cur[u]], f);",
            "\t\t\t\t\t}",
            "\t\t\t\t\telse ++ cur[u];",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t\twhile(hi >= 0 && hs[hi].empty()) -- hi;",
            "\t\t}",
            "\t\treturn -ec[source];",
            "\t}",
            "\tvector<int> vis, q;",
            "\t// Find a minimum source-sink cut",
            "\t// O(V^2 * sqrt(E)) with gap heuristic",
            "\ttuple<T, vector<int>, vector<int>> minimum_cut(int source, int sink){",
            "\t\tT weight = maximum_flow(source, sink);",
            "\t\tvis.assign(F.n, false);",
            "\t\tq.resize(F.n);",
            "\t\tvector<int> left, right;",
            "\t\tq[0] = source;",
            "\t\tvis[source] = true;",
            "\t\tfor(auto beg = 0, end = 1; beg < end; ){",
            "\t\t\tint u = q[beg ++];",
            "\t\t\tfor(auto id: F.adj[u]){",
            "\t\t\t\tauto &e = F.edge[id];",
            "\t\t\t\tif(e.capacity - e.flow > eps && !vis[e.to]){",
            "\t\t\t\t\tvis[e.to] = true;",
            "\t\t\t\t\tq[end ++] = e.to;",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t}",
            "\t\tfor(auto u = 0; u < F.n; ++ u){",
            "\t\t\tif(vis[u]) left.push_back(u);",
            "\t\t\telse right.push_back(u);",
            "\t\t}",
            "\t\treturn {weight, left, right};",
            "\t}",
            "};"
        ],
        "description": "tranxuanbach"
    }
}