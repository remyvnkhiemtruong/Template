{
    "tranxuanbach": {
        "prefix": "sorted_line_container",
        "body": [
            "template<class T, bool GET_MAX = false>",
            "struct sorted_line_container{",
            "\tstruct line_type{",
            "\t\tT k, d; // Constant term, Slope",
            "\t\tmutable T p;",
            "\t\tfriend ostream &operator<<(ostream &out, const line_type &L){",
            "\t\t\treturn out << \"{\" << L.d << \", \" << L.k << \", \" << L.p << \"}\";",
            "\t\t}",
            "\t};",
            "\tdeque<line_type> data; // Constant term, Slope",
            "\tstatic constexpr T inf = numeric_limits<T>::max() / 2;",
            "\tT div(T a, T b){",
            "\t\tif constexpr(is_integral<T>::value) return a / b - ((a ^ b) < 0 && a % b);",
            "\t\telse return a / b;",
            "\t}",
            "\ttemplate<class It>",
            "\tbool isect_front(It x, It y){",
            "\t\tif(y == data.end()){",
            "\t\t\tx->p = inf;",
            "\t\t\treturn false;",
            "\t\t}",
            "\t\telse{",
            "\t\t\tx->p = div(y->k - x->k, x->d - y->d);",
            "\t\t\treturn x->p >= y->p;",
            "\t\t}",
            "\t}",
            "\ttemplate<class Rit>",
            "\tbool isect_back(Rit x, Rit y){",
            "\t\tif(x == data.rend()){",
            "\t\t\treturn false;",
            "\t\t}",
            "\t\telse{",
            "\t\t\tx->p = div(y->k - x->k, x->d - y->d);",
            "\t\t\treturn x->p >= y->p;",
            "\t\t}",
            "\t}",
            "\tint size() const{",
            "\t\treturn (int)data.size();",
            "\t}",
            "\tbool empty() const{",
            "\t\treturn data.empty();",
            "\t}",
            "\t// Slopes must increase monotonously",
            "\t// Amortized O(1)",
            "\ttemplate<bool FIRST_CALL = true>",
            "\tvoid inc_push(const line_type &L){",
            "\t\tif(FIRST_CALL && !GET_MAX){",
            "\t\t\tdec_push<false>({-L.k, -L.d});",
            "\t\t\treturn;",
            "\t\t}",
            "\t\tassert(data.empty() || data.back().d <= L.d);",
            "\t\tif(data.empty() || data.back().d < L.d || data.back().k < L.k){",
            "\t\t\tif(!data.empty() && L.d == data.back().d) data.erase(-- data.end());",
            "\t\t\tL.p = inf;",
            "\t\t\tdata.push_back(L);",
            "\t\t\tisect_back(++ data.rbegin(), data.rbegin());",
            "\t\t\twhile((int)data.size() >= 2 && isect_back(++ ++ data.rbegin(), ++ data.rbegin())){",
            "\t\t\t\tdata.erase(-- -- data.end());",
            "\t\t\t\tisect_back(++ data.rbegin(), data.rbegin());",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "\t// Slopes must decrease monotonously",
            "\t// Amortized O(1)",
            "\ttemplate<bool FIRST_CALL = true>",
            "\tvoid dec_push(const line_type &L){",
            "\t\tif(FIRST_CALL && !GET_MAX){",
            "\t\t\tinc_push<false>({-L.k, -L.d});",
            "\t\t\treturn;",
            "\t\t}",
            "\t\tassert(data.empty() || L.d <= data.front().d);",
            "\t\tif(data.empty() || L.d < data.front().d || data.front().k < L.k){",
            "\t\t\tif(!data.empty() && L.d == data.front().d) data.erase(data.begin());",
            "\t\t\tL.p = 0;",
            "\t\t\tdata.push_front(L);",
            "\t\t\tisect_front(data.begin(), ++ data.begin());",
            "\t\t\twhile((int)data.size() >= 2 && isect_front(data.begin(), ++ data.begin())){",
            "\t\t\t\tdata.erase(++ data.begin());",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "\t// Other queries must not be called and x must be decreasing",
            "\t// Amortized O(1)",
            "\tT dec_query(T x){",
            "\t\tassert(!data.empty());",
            "\t\twhile((int)data.size() >= 2 && data.rbegin()->k + data.rbegin()->d * x <= next(data.rbegin())->k + next(data.rbegin())->d * x) data.pop_back();",
            "\t\tdata.back()[2] = inf;",
            "\t\treturn (data.rbegin()->k + data.rbegin()->d * x) * (GET_MAX ? 1 : -1);",
            "\t}",
            "\t// Other queries must not be called and x must be increasing",
            "\t// Amortized O(1)",
            "\tT inc_query(T x){",
            "\t\tassert(!data.empty());",
            "\t\twhile((int)data.size() >= 2 && data.begin()->k + data.begin()->d * x <= next(data.begin())->k + next(data.begin())->d * x) data.pop_front();",
            "\t\treturn (data.begin()->k + data.begin()->d * x) * (GET_MAX ? 1 : -1);",
            "\t}",
            "\t// Other queries must not be called",
            "\t// O(log(n))",
            "\tT query(T x){",
            "\t\tassert(!data.empty());",
            "\t\tif((int)data.size() == 1) return (data.begin()->k + data.begin()->d * x) * (GET_MAX ? 1 : -1);",
            "\t\tif(data.begin()->k + data.begin()->d * x >= next(data.begin())->k + next(data.begin())->d * x) return (data.begin()->k + data.begin()->d * x) * (GET_MAX ? 1 : -1);",
            "\t\tint low = 0, high = (int)data.size() - 1;",
            "\t\twhile(high - low >= 2){",
            "\t\t\tint mid = low + (high - low >> 1);",
            "\t\t\t((data.begin() + mid)->k + (data.begin() + mid)->d * x < (data.begin() + mid + 1)->k + (data.begin() + mid + 1)->d * x ? low : high) = mid;",
            "\t\t}",
            "\t\treturn ((data.begin() + low + 1)->k + (data.begin() + low + 1)->d * x) * (GET_MAX ? 1 : -1);",
            "\t}",
            "};"
        ],
        "description": "tranxuanbach"
    }
}