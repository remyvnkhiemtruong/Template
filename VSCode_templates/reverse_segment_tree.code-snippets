{
    "tranxuanbach": {
        "prefix": "reverse_segment_tree",
        "body": [
            "template<class L, L (*composite)(L, L), L (*identity_update)(int, int)>",
            "struct reverse_segment_tree{",
            "\treverse_segment_tree(): reverse_segment_tree(0){}",
            "\treverse_segment_tree(int n): n(n){",
            "\t\tvector<L> v(n);",
            "\t\tfor(int i = 0; i < n; ++ i) v[i] = identity_update(i, i + 1);",
            "\t\t*this = reverse_segment_tree(v);",
            "\t}",
            "\treverse_segment_tree(const vector<L> &v): n((int)v.size()){",
            "\t\tlog = __lg(n + 1) + 1, size = 1 << log;",
            "\t\tlazy = vector<L>(size << 1);",
            "\t\tcopy(v.begin(), v.end(), lazy.begin() + size);",
            "\t\tfor(int i = 1; i < size; ++ i){",
            "\t\t\tint h = log - __lg(i);",
            "\t\t\tlazy[i] = identity_update((i << h) - size, (i + 1 << h) - size);",
            "\t\t}",
            "\t}",
            "\tvoid update(int l, int r, L x){",
            "\t\tif(l >= r) return;",
            "\t\tl += size, r += size;",
            "\t\t/* for(int i = log; i >= 1; -- i){ // for non-commutative operations",
            "\t\t\tif(((l >> i) << i) != l) push(l >> i);",
            "\t\t\tif (((r >> i) << i) != r) push(r - 1 >> i);",
            "\t\t}*/",
            "\t\tfor(; l < r; l >>= 1, r >>= 1){",
            "\t\t\tif(l & 1) lazy[l ++] = composite(x, lazy[l]);",
            "\t\t\tif(r & 1) lazy[r] = composite(x, lazy[-- r]);",
            "\t\t}",
            "\t}",
            "\tL query(int p){",
            "\t\tL res = identity_update(p, p + 1);",
            "\t\tfor(p += size; p > 0; p >>= 1) res = composite(lazy[p], res);",
            "\t\treturn res;",
            "\t}",
            "\tvoid push(int i){",
            "\t\tlazy[i << 1] = composite(lazy[i], lazy[i << 1]);",
            "\t\tlazy[i << 1 | 1] = composite(lazy[i], lazy[i << 1 | 1]);",
            "\t\tint h = log - __lg(i);",
            "\t\tlazy[i] = identity_update((i << h) - size, (i + 1 << h) - size);",
            "\t}",
            "\tvoid push_all(){",
            "\t\tfor(int i = 1; i < n; ++ i) push(i);",
            "\t}",
            "\tint n, size, log;",
            "\tvector<L> lazy;",
            "};",
            "using L = long long; // Semigroup (Lazy Type)",
            "L composite(L f, L g){ // composites superset and subset ",
            "\treturn f + g;",
            "}",
            "L identity_update(int l, int r){",
            "\treturn 0;",
            "}",
            "// reverse_segment_tree<L, composite, identity_update> rseg(a);"
        ],
        "description": "tranxuanbach"
    }
}