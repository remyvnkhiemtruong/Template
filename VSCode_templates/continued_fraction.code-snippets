{
    "tranxuanbach": {
        "prefix": "continued_fraction",
        "body": [
            "template<class T>",
            "struct continued_fraction{",
            "\tusing F = array<T, 2>;",
            "\tvector<T> data;",
            "\t// O(1)",
            "\tcontinued_fraction(T x): data({x}){ }",
            "\t// O(log(MAXVAL))",
            "\tcontinued_fraction(T n, T d){",
            "\t\tassert(d > 0);",
            "\t\twhile(d > 0){",
            "\t\t\tauto [q, r] = divrem(n, d);",
            "\t\t\tif(r < 0){",
            "\t\t\t\t-- q;",
            "\t\t\t\tr += d;",
            "\t\t\t}",
            "\t\t\tdata.push_back(q);",
            "\t\t\tn = d, d = r;",
            "\t\t}",
            "\t\tif(n >= 2) for(auto &x: data) x /= n;",
            "\t}",
            "\t// O(log(MAXVAL))",
            "\tcontinued_fraction(const F &f): continued_fraction(f[0], f[1]){ }",
            "\tcontinued_fraction(const vector<T> &a): data(a){",
            "\t\tassert(!data.empty());",
            "\t\tfor(auto i = 1; i < (int)data.size(); ++ i) assert(data[i] >= 1);",
            "\t}",
            "\tbool _frac_cmp(const F &x, const F &y) const{",
            "\t\treturn x[0] * y[1] < x[1] * y[0];",
            "\t}",
            "\t// Assuming data represents a rational number, switch to the alternative representation.",
            "\tcontinued_fraction &alter(){",
            "\t\tif((int)data.size() == 1 || data.back() >= 2){",
            "\t\t\t-- data.back();",
            "\t\t\tdata.push_back(T{1});",
            "\t\t}",
            "\t\telse{",
            "\t\t\tdata.pop_back();",
            "\t\t\t++ data.back();",
            "\t\t}",
            "\t\treturn *this;",
            "\t}",
            "\tvector<F> all_convergents() const{",
            "\t\tvector<F> c((int)data.size() + 2);",
            "\t\tc[0] = {T{0}, T{1}}, c[1] = {T{1}, T{0}};",
            "\t\tfor(auto i = 0; i < (int)data.size(); ++ i){",
            "\t\t\tc[i + 2][0] = data[i] * c[i + 1][0] + c[i][0];",
            "\t\t\tc[i + 2][1] = data[i] * c[i + 1][1] + c[i][1];",
            "\t\t}",
            "\t\treturn c;",
            "\t}",
            "\t// -1(0/1), 0(1/0), 1(data[0]/1), ...",
            "\tF convergent(int i = -2) const{",
            "\t\tassert(-2 <= i && i < (int)data.size());",
            "\t\tif(i == -1) return {0, 1};",
            "\t\tif(i == -2) i = (int)data.size() - 1;",
            "\t\tF res{1, 0};",
            "\t\tfor(auto j = i - 1; j >= 0; -- j) res = {res[1] + res[0] * data[j], res[0]};",
            "\t\treturn res;",
            "\t}",
            "};",
            "// Given two fractions 0 <= low < high,",
            "// Returns the rational number low < p/q < high with the smallest value of p(equiv. q)",
            "// O(log(MAXVAL))",
            "template<class T>",
            "array<T, 2> best_rational_within(const array<T, 2> &low, const array<T, 2> &high){",
            "\tassert(0 <= low[0] && 0 < low[1] && 0 < high[1]);",
            "\tassert(_frac_cmp(low, high));",
            "\tcontinued_fraction cf_low(low), cf_high(high);",
            "\tfor(auto iter = 0; iter < 4; ++ iter){",
            "\t\tarray<T, 2> pf{0, 1}, f{1, 0};",
            "\t\tfor(int i = 0; ; ++ i){",
            "\t\t\tif(i < (int)min(cf_low.size(), cf_high.size()) && cf_low.data[i] == cf_high.data[i]){",
            "\t\t\t\tT x = cf_low.data[i];",
            "\t\t\t\ttie(pf, f) = {f, array{pf[0] + x * f[0], pf[1] + x * f[1]}};",
            "\t\t\t}",
            "\t\t\telse{",
            "\t\t\t\tT x = i >= (int)cf_high.size() || i < (int)cf_low.data.size() && cf_low.data[i] < cf_high.data[i] ? cf_low.data[i] + 1 : cf_high.data[i] + 1;",
            "\t\t\t\ttie(pf, f) = {f, array{pf[0] + x * f[0], pf[1] + x * f[1]}};",
            "\t\t\t\tbreak;",
            "\t\t\t}",
            "\t\t}",
            "\t\tif(frac_cmp(low, f) && frac_cmp(f, high)) return f;",
            "\t\tif(~iter & 1) cf_low.alter();",
            "\t\tif(~iter >> 1 & 1) cf_high.alter();",
            "\t}",
            "\tassert(false);",
            "}"
        ],
        "description": "tranxuanbach"
    }
}