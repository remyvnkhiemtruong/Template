{
    "tranxuanbach": {
        "prefix": "lca_solver",
        "body": [
            "struct lca_solver{",
            "\tint n;",
            "\tvector<int> depth;",
            "\tvector<int> order;",
            "\tvector<int> pos;",
            "\tvector<int> end;",
            "\tvector<int> root_of;",
            "\tvector<vector<int>> rmq;",
            "\tvector<int> was;",
            "\tlca_solver(){ }",
            "\ttemplate<class T>",
            "\tlca_solver(const graph<T> &g){",
            "\t\tvector<int> src(g.n);",
            "\t\tiota(src.begin(), src.end(), 0);",
            "\t\t*this = lca_solver(g, src);",
            "\t}",
            "\ttemplate<class T>",
            "\tlca_solver(const graph<T> &g, const vector<int> &src){",
            "\t\tinit(g.n);",
            "\t\tbuild(g, src);",
            "\t}",
            "\tvoid init(int n){",
            "\t\tthis->n = n;",
            "\t\tdepth.assign(n, -1);",
            "\t\torder.clear();",
            "\t\tpos.assign(n, -1);",
            "\t\tend.assign(n, -1);",
            "\t\troot_of.assign(n, -1);",
            "\t\trmq.clear();",
            "\t\twas.assign(n, -2);",
            "\t\tattempt = -1;",
            "\t}",
            "\tint attempt;",
            "\t// O(n * log(n))",
            "\ttemplate<class T>",
            "\tvoid build(const graph<T> &g, const vector<int> &src){",
            "\t\tassert(g.n <= n);",
            "\t\t++ attempt;",
            "\t\torder.clear();",
            "\t\trmq = {{}};",
            "\t\tauto dfs = [&](auto self, int u, int pe)->void{",
            "\t\t\tassert(was[u] != attempt);",
            "\t\t\twas[u] = attempt;",
            "\t\t\tpos[u] = (int)order.size();",
            "\t\t\torder.push_back(u), rmq[0].push_back(pos[u]);",
            "\t\t\tfor(auto id: g.adj[u]){",
            "\t\t\t\tif(id == pe || g.ignore && g.ignore(id)) continue;",
            "\t\t\t\tint v = g(u, id);",
            "\t\t\t\tdepth[v] = depth[u] + 1;",
            "\t\t\t\troot_of[v] = root_of[u];",
            "\t\t\t\tself(self, v, id);",
            "\t\t\t\torder.push_back(u), rmq[0].push_back(pos[u]);",
            "\t\t\t}",
            "\t\t\tend[u] = (int)order.size();",
            "\t\t};",
            "\t\tfor(auto r: src){",
            "\t\t\tif(was[r] == attempt) continue;",
            "\t\t\tdepth[r] = 0;",
            "\t\t\troot_of[r] = r;",
            "\t\t\tdfs(dfs, r, -1);",
            "\t\t}",
            "\t\tfor(auto p = 1, i = 1; p <= n; p <<= 1, ++ i){",
            "\t\t\trmq.emplace_back((n << 1) - (p << 1) + 1);",
            "\t\t\tfor(auto j = 0; j < (int)rmq[i].size(); ++ j) rmq[i][j] = min(rmq[i - 1][j], rmq[i - 1][j + p]);",
            "\t\t}",
            "\t}",
            "\t// Check if u is visited during the last build call",
            "\tbool visited(int u) const{",
            "\t\tassert(0 <= u && u < n);",
            "\t\treturn was[u] == attempt;",
            "\t}",
            "\t// O(1)",
            "\tbool ancestor_of(int u, int v) const{",
            "\t\tassert(visited(u) && visited(v));",
            "\t\treturn pos[u] <= pos[v] && end[v] <= end[u];",
            "\t}",
            "\t// Assumes u and v are on the same component",
            "\t// O(1)",
            "\tint lca(int u, int v) const{",
            "\t\tassert(visited(u) && visited(v) && root_of[u] == root_of[v]);",
            "\t\tif(u == v) return u;",
            "\t\ttie(u, v) = minmax(pos[u], pos[v]);",
            "\t\tint d = __lg(v - u);",
            "\t\treturn order[min(rmq[d][u], rmq[d][v - (1 << d)])];",
            "\t}",
            "\t// Assumes u and v are on the same component",
            "\t// O(1)",
            "\tint steps(int u, int v, int w = -1) const{",
            "\t\treturn -2 * depth[~w ? w : lca(u, v)] + depth[u] + depth[v];",
            "\t}",
            "};"
        ],
        "description": "tranxuanbach"
    }
}