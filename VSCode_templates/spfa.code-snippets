{
    "tranxuanbach": {
        "prefix": "spfa",
        "body": [
            "// Refer to",
            "// https://konaeakira.github.io/posts/using-the-shortest-path-faster-algorithm-to-find-negative-cycles.html",
            "// for the benchmark",
            "// Requires graph",
            "template<class T>",
            "struct spfa{",
            "\tint n;",
            "\tvector<T> dist;",
            "\tvector<int> pv, pe;",
            "\tspfa(int n){",
            "\t\tinit(n);",
            "\t}",
            "\tvoid init(int n){",
            "\t\tthis->n = n;",
            "\t\tdist.assign(n, numeric_limits<T>::max());",
            "\t\tpv.assign(n, -1);",
            "\t\tpe.assign(n, -1);",
            "\t\twas.assign(n, -1);",
            "\t\tin_queue.assign(n, false);",
            "\t\tstate.assign(n, 0);",
            "\t\tattempt;",
            "\t}",
            "\tvector<int> stack, state;",
            "\ttemplate<class U>",
            "\toptional<pair<int, vector<int>>> detect_negative_cycle(const graph<U> &g){",
            "\t\tstack.clear();",
            "\t\tfill(state.begin(), state.end(), 0);",
            "\t\tfor(auto s = 0; s < n; ++ s){",
            "\t\t\tif(state[s]) continue;",
            "\t\t\tfor(auto u = s; ; ){",
            "\t\t\t\tif(state[u]){",
            "\t\t\t\t\tif(state[u] == 1){",
            "\t\t\t\t\t\tstack.erase(stack.begin(), find(stack.begin(), stack.end(), u));",
            "\t\t\t\t\t\tassert(!stack.empty() && stack[0] == u);",
            "\t\t\t\t\t\tvector<int> cycle;",
            "\t\t\t\t\t\tfor(auto u: stack) cycle.push_back(pe[u]);",
            "\t\t\t\t\t\treverse(cycle.begin(), cycle.end());",
            "\t\t\t\t\t\treturn pair{u, cycle};",
            "\t\t\t\t\t}",
            "\t\t\t\t\tbreak;",
            "\t\t\t\t}",
            "\t\t\t\tstack.push_back(u);",
            "\t\t\t\tstate[u] = 1;",
            "\t\t\t\tif(!~pe[u]) break;",
            "\t\t\t\tu = g.edge[pe[u]].from;",
            "\t\t\t}",
            "\t\t\tfor(auto u: stack) state[u] = 2;",
            "\t\t\tstack.clear();",
            "\t\t}",
            "\t\treturn {};",
            "\t}",
            "\t// Returns the negative cycle (list of edge ids) if there's one.",
            "\t// O(|E| * |V|) where",
            "\t// V is the set of vertices reachable from src and",
            "\t// E is the set of edges reachable from src",
            "\tint attempt;",
            "\tvector<int> in_queue, q, was;",
            "\ttemplate<class U>",
            "\toptional<pair<int, vector<int>>> run(const graph<U> &g, const vector<int> &src, bool negative_cycle_presence = false){",
            "\t\tassert(n == g.n);",
            "\t\t++ attempt;",
            "\t\tq = src;",
            "\t\tfor(auto u: src){",
            "\t\t\twas[u] = attempt;",
            "\t\t\tdist[u] = {};",
            "\t\t\tpv[u] = pe[u] = -1;",
            "\t\t\tin_queue[u] = true;",
            "\t\t}",
            "\t\tint beg = 0, iter = 0;",
            "\t\twhile(beg < (int)q.size()){",
            "\t\t\tint u = q[beg ++];",
            "\t\t\tin_queue[u] = false;",
            "\t\t\tfor(auto id: g.adj[u]){",
            "\t\t\t\tif(g.ignore && g.ignore(id)) continue;",
            "\t\t\t\tauto [u, v, w] = g.edges[id];",
            "\t\t\t\tif(was[v] != attempt || dist[u] + w < dist[v]){",
            "\t\t\t\t\tif(was[v] != attempt){",
            "\t\t\t\t\t\twas[v] = attempt;",
            "\t\t\t\t\t\tin_queue[v] = false;",
            "\t\t\t\t\t}",
            "\t\t\t\t\tdist[v] = dist[u] + w;",
            "\t\t\t\t\tpv[v] = u, pe[v] = id;",
            "\t\t\t\t\tif(negative_cycle_presence && ++ iter == n){",
            "\t\t\t\t\t\tif(auto t = detect_negative_cycle(g)) return t;",
            "\t\t\t\t\t\titer = 0;",
            "\t\t\t\t\t}",
            "\t\t\t\t\tif(!in_queue[v]) q.push_back(v), in_queue[v] = true;",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t}",
            "\t\tif(negative_cycle_presence) if(auto t = detect_negative_cycle(g)) return t;",
            "\t\treturn {};",
            "\t}",
            "};"
        ],
        "description": "tranxuanbach"
    }
}