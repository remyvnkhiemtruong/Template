{
    "scope":"source.c++",
    "completions":
    [
    	{ "trigger": "fori", "contents": "for(auto ${1:i} = ${2:0}; $1 < ${3:n}; ${4:++ $1}){\n\t$0\n}"},
    	{ "trigger": "rofi", "contents": "for(auto ${1:i} = ${2:n - 1}; $1 >= ${3:0}; ${4:-- $1}){\n\t$0\n}"},
        { "trigger": "forg", "contents": "for($1; $2; $3){\n\t$0\n}"},
    	{ "trigger": "ford\t[low, d] represents the maximal interval which n/low = n/d", "contents": "for(auto ${1:low} = ${2:1}, ${3:d} = ${2:1}; $1 <= ${4:n}; $1 = $3 + 1){\n\t$3 = $4 / ($4 / $1);\n\t$0\n}"},
        { "trigger": "forb\tIterate over bitset", "contents": "for(auto ${1:u} = $2._Find_first(); ${1:u} < ${3:n}; ${1:u} = $2._Find_next(${1:u})){\n\t$0\n}"},
        { "trigger": "trav", "contents": "for(auto $1: $2){\n\t$0\n}"},
    	{ "trigger": "while", "contents": "while($1){\n\t$0\n}"},
    	{ "trigger": "if", "contents": "if($1){\n\t$0\n}"},
    	{ "trigger": "else if", "contents": "else if($1){\n\t$0\n}"},
    	{ "trigger": "else", "contents": "else{\n\t$0\n}"},
    	{ "trigger": "struct", "contents": "struct $1{\n\t$0\n};"},
    	{ "trigger": "return", "contents": "return $1;"},
    	{ "trigger": "exit", "contents": "exit(0);"},
        { "trigger": "decltype", "contents": "decltype($1)"},
        { "trigger": "dr4", "contents": "static const vector<pair<int, int>> dr{{1, 0}, {0, 1}, {-1, 0}, {0, -1}};"},
        { "trigger": "dr8", "contents": "static const vector<pair<int, int>> dr{{1, 0}, {1, 1}, {0, 1}, {-1, 1}, {-1, 0}, {-1, -1}, {0, -1}, {1, -1}};"},
        
    	{ "trigger": "sort", "contents": "sort(${1:$2.begin(), $2.end()}$3)"},
    	{ "trigger": "reverse", "contents": "reverse(${1:$2.begin(), $2.end()})"},
        { "trigger": "rotate", "contents": "rotate($1, $2, $3)"},
    	{ "trigger": "reserve", "contents": "reserve(${1:n})"},
        { "trigger": "accumulate", "contents": "accumulate(${1:$2.begin(), $2.end()}, ${3:0LL}$4)"},
        { "trigger": "partial_sum", "contents": "partial_sum(${1:$2.begin(), $2.end()}, $3)"},
        { "trigger": "iota", "contents": "iota(${1:$2.begin(), $2.end()}, ${3:0})"},
        { "trigger": "partition", "contents": "partition(${1:$2.begin(), $2.end()}, $3)"},
        { "trigger": "max_element", "contents": "max_element(${1:$2.begin(), $2.end()}$3)"},
        { "trigger": "min_element", "contents": "min_element(${1:$2.begin(), $2.end()}$3)"},
        { "trigger": "lower_bound", "contents": "lower_bound(${1:$2.begin(), $2.end()}, $3)"},
        { "trigger": "upper_bound", "contents": "upper_bound(${1:$2.begin(), $2.end()}, $3)"},
        { "trigger": "equal_range", "contents": "equal_range(${1:$2.begin(), $2.end()}, $3)"},
        { "trigger": "partition_point", "contents": "partition_point(${1:$2.begin(), $2.end()}, $3)"},
        { "trigger": "fill", "contents": "fill(${1:$2.begin(), $2.end()}, $3)"},
        { "trigger": "find", "contents": "find(${1:$2.begin(), $2.end()}, $3)"},
        { "trigger": "find_if", "contents": "find_if(${1:$2.begin(), $2.end()}, $3)"},
        { "trigger": "find_if_not", "contents": "find_if_not(${1:$2.begin(), $2.end()}, $3)"},
        { "trigger": "search", "contents": "search(${1:$2.begin(), $2.end()}, ${3:$4.begin(), $4.end()})"},
        { "trigger": "all_of", "contents": "all_of(${1:$2.begin(), $2.end()}, $3)"},
        { "trigger": "any_of", "contents": "any_of(${1:$2.begin(), $2.end()}, $3)"},
        { "trigger": "none_of", "contents": "none_of(${1:$2.begin(), $2.end()}, $3)"},
        { "trigger": "for_each", "contents": "for_each(${1:$2.begin(), $2.end()}, $3)"},
        { "trigger": "count", "contents": "count(${1:$2.begin(), $2.end()}, $3)"},
        { "trigger": "count_if", "contents": "count_if(${1:$2.begin(), $2.end()}, $3)"},
        { "trigger": "mismatch", "contents": "mismatch(${1:$2.begin(), $2.end()}, $3)"},
        { "trigger": "shuffle", "contents": "shuffle(${1:$2.begin(), $2.end()}, rng)"},
        { "trigger": "sample", "contents": "sample(${1:$2.begin(), $2.end()}, $3, $4, rng)"},
        { "trigger": "is_sorted", "contents": "is_sorted(${1:$2.begin(), $2.end()}$3)"},
        { "trigger": "next_permutation", "contents": "next_permutation(${1:$2.begin(), $2.end()}$3)"},
        { "trigger": "prev_permutation", "contents": "prev_permutation(${1:$2.begin(), $2.end()}$3)"},
        { "trigger": "set_difference", "contents": "set_difference(${1:$2.begin(), $2.end()}, ${3:$4.begin(), $4.end()}, $5)"},
        { "trigger": "set_intersection", "contents": "set_intersection(${1:$2.begin(), $2.end()}, ${3:$4.begin(), $4.end()}, $5)"},
        { "trigger": "set_union", "contents": "set_union(${1:$2.begin(), $2.end()}, ${3:$4.begin(), $4.end()}, $5)"},
        { "trigger": "set_symmetric_difference", "contents": "set_symmetric_difference(${1:$2.begin(), $2.end()}, ${3:$4.begin(), $4.end()}, $5)"},
        { "trigger": "includes", "contents": "includes(${1:$2.begin(), $2.end()}, ${3:$4.begin(), $4.end()}, $5)"},
        { "trigger": "merge", "contents": "merge(${1:$2.begin(), $2.end()}, ${3:$4.begin(), $4.end()}, $5)"},
        { "trigger": "adjacent_difference", "contents": "adjacent_difference(${1:$2.begin(), $2.end()}, $3)"},
        { "trigger": "adjacent_find", "contents": "adjacent_find(${1:$2.begin(), $2.end()}$3)"},
        { "trigger": "remove", "contents": "$1.erase(remove(${2:$1.begin(), $1.end()}, $3), $1.end());"},
        { "trigger": "remove_if", "contents": "$1.erase(remove_if(${2:$1.begin(), $1.end()}, $3), $1.end());"},
        { "trigger": "copy", "contents": "copy(${1:$2.begin(), $2.end()}, $3)"},
        { "trigger": "copy_if", "contents": "copy_if(${1:$2.begin(), $2.end()}, $3, $4)"},
        { "trigger": "generate", "contents": "generate(${1:$2.begin(), $2.end()}, rng)"},

        { "trigger": "inserter", "contents": "inserter($1, $2)"},
        { "trigger": "back_inserter", "contents": "back_inserter($1)"},
        { "trigger": "front_inserter", "contents": "front_inserter($1)"},
        
        { "trigger": "popcount\tCount the number of 1s", "contents": "__builtin_popcount$1($2)"},
        { "trigger": "parity\tGet the parity", "contents": "__builtin_parity$1($2)"},
        { "trigger": "clz\tCount the number of leading zeros", "contents": "__builtin_clz$1($2)"},
        { "trigger": "ctz\tCount the number of trailing zeros", "contents": "__builtin_ctz$1($2)"},
        { "trigger": "ffs\tReturn the position of the first set bit", "contents": "__builtin_ffs$1($2)"},
        { "trigger": "clrsb\tCount the number of leading redundant sign bits", "contents": "__builtin_clrsb$1($2)"},
        { "trigger": "addoverflow", "contents": "__builtin_add_overflow_p($1, $2, ${3:0})"},
        { "trigger": "muloverflow", "contents": "__builtin_mul_overflow_p($1, $2, ${3:0})"},
        { "trigger": "suboverflow", "contents": "__builtin_sub_overflow_p($1, $2, ${3:0})"},
        
        { "trigger": "plus", "contents": "plus<>()"},
        { "trigger": "minus", "contents": "minus<>()"},
        { "trigger": "multiplies", "contents": "multiplies<>()"},
        { "trigger": "devides", "contents": "devides<>()"},
        { "trigger": "modulus", "contents": "modulus<>()"},
        { "trigger": "negate", "contents": "negate<>()"},
        { "trigger": "equal_to", "contents": "equal_to<>()"},
        { "trigger": "not_equal_to", "contents": "not_equal_to<>()"},
        { "trigger": "greater", "contents": "greater<>()"},
        { "trigger": "less", "contents": "less<>()"},
        { "trigger": "greater_equal", "contents": "greater_equal<>()"},
        { "trigger": "less_equal", "contents": "less_equal<>()"},
        { "trigger": "logical_and", "contents": "logical_and<>()"},
        { "trigger": "logical_or", "contents": "logical_or<>()"},
        { "trigger": "logical_not", "contents": "logical_not<>()"},
        { "trigger": "bit_and", "contents": "bit_and<>()"},
        { "trigger": "bit_or", "contents": "bit_and<>()"},
        { "trigger": "bit_xor", "contents": "bit_xor<>()"},
        { "trigger": "bit_not", "contents": "bit_not<>()"},
        { "trigger": "get", "contents": "get<$1>($2)"},

        { "trigger": "ll", "contents": "long long"},
        { "trigger": "ai", "contents": "array<int, 2>"},
    	{ "trigger": "pii", "contents": "pair<int, int>"},
        { "trigger": "pil", "contents": "pair<int, long long>"},
        { "trigger": "pli", "contents": "pair<long long, int>"},
        { "trigger": "al", "contents": "array<long long, 2>"},
        { "trigger": "pll", "contents": "pair<long long, long long>"},
        { "trigger": "vi", "contents": "vector<int>"},
        { "trigger": "vl", "contents": "vector<long long>"},
        { "trigger": "vz", "contents": "vector<Zp>"},
        { "trigger": "vd", "contents": "vector<double>"},
        { "trigger": "vs", "contents": "vector<string>"},
        { "trigger": "vaii", "contents": "vector<array<int, 2>>"},
        { "trigger": "vpii", "contents": "vector<pair<int, int>>"},
        { "trigger": "vpil", "contents": "vector<pair<int, long long>>"},
        { "trigger": "vpli", "contents": "vector<pair<long long, int>>"},
        { "trigger": "val", "contents": "vector<array<long long, 2>>"},
        { "trigger": "vpll", "contents": "vector<pair<long long, long long>>"},
        { "trigger": "vvi", "contents": "vector<vector<int>>"},
        { "trigger": "vvl", "contents": "vector<vector<long long>>"},
        { "trigger": "vvd", "contents": "vector<vector<double>>"},
        { "trigger": "vvz", "contents": "vector<vector<Zp>>"},
        { "trigger": "vvai", "contents": "vector<vector<array<int, 2>>>"},
        { "trigger": "vvpii", "contents": "vector<vector<pair<int, int>>>"},
        { "trigger": "vvpil", "contents": "vector<vector<pair<int, long long>>>"},
        { "trigger": "vvpli", "contents": "vector<vector<pair<long long, int>>>"},
        { "trigger": "vval", "contents": "vector<vector<array<long long, 2>>>"},
        { "trigger": "vvpll", "contents": "vector<vector<pair<long long, long long>>>"},
        { "trigger": "vvvi", "contents": "vector<vector<vector<int>>>"},
        { "trigger": "vvvl", "contents": "vector<vector<vector<long long>>>"},
        { "trigger": "vvvd", "contents": "vector<vector<vector<double>>>"},
        { "trigger": "vvvz", "contents": "vector<vector<vector<Zp>>>"},
        { "trigger": "vvvai", "contents": "vector<vector<vector<array<int, 2>>>>"},
        { "trigger": "vvvpii", "contents": "vector<vector<vector<pair<int, int>>>>"},
		{ "trigger": "pq", "contents": "priority_queue<$1>"},
    	{ "trigger": "gpq", "contents": "priority_queue<$1, vector<$1>, greater<>>"},
        { "trigger": "recurse", "contents": "function<${1:void}(${2:int, int})> $3 = [&](${4:int u, int pe}){\n\t$0\n};"},
        { "trigger": "function", "contents": "auto $1 = [&]($2){\n\t$0\n};"},
        { "trigger": "lambda", "contents": "[&]($1){ $2 }"},
        { "trigger": "unique", "contents": "sort($1.begin(), $1.end()), $1.erase(unique($1.begin(), $1.end()), $1.end());"},
		
		{ "trigger": "push_back", "contents": "push_back($1)" },
    	{ "trigger": "pop_back", "contents": "pop_back()"},
        { "trigger": "emplace_back", "contents": "emplace_back($1)" },
    	{ "trigger": "front", "contents": "front()"},
    	{ "trigger": "back", "contents": "back()"},
    	{ "trigger": "begin", "contents": "begin()"},
    	{ "trigger": "end", "contents": "end()"},
    	{ "trigger": "rbegin", "contents": "rbegin()"},
    	{ "trigger": "rend", "contents": "rend()"},
    	{ "trigger": "insert", "contents": "insert($1)"},
    	{ "trigger": "erase", "contents": "erase($1)"},
    	{ "trigger": "first", "contents": "first"},
    	{ "trigger": "second", "contents": "second"},
        { "trigger": "find_by_order", "contents": "find_by_order($1)"},
        { "trigger": "order_of_key", "contents": "order_of_key($1)"},
        { "trigger": "_Find_first", "contents": "_Find_first()"},
        { "trigger": "_Find_next", "contents": "_Find_next($1)"},

    	{ "trigger": "precision", "contents": "cout << fixed << setprecision(15);"},
        { "trigger": "high_resolution_clock", "contents": "high_resolution_clock${1:::now()}"},
        { "trigger": "duration", "contents": "duration<${1:double}>(${2:high_resolution_clock::now() - START}).count()"},
        { "trigger": "mod1", "contents": "1e9 + 7"},
        { "trigger": "mod2", "contents": "(119 << 23) + 1"},
        { "trigger": "limit", "contents": "numeric_limits<${1:long long}>::${2:max}()"},
        { "trigger": "all", "contents": "$1.begin(), $1.end()"},
        { "trigger": "sz", "contents": "(int)$1.size()"},
        { "trigger": "pi", "contents": "const double pi = acos(-1);"},
        { "trigger": "kill", "contents": "auto kill = [](){\n\t${1:cout << -1;}\n\texit(0);\n};"},
        { "trigger": "iop", "contents": "istream &operator>>(istream &in, $1 &$2){\n\t${3:return in >> $2;}\n}"},
        { "trigger": "oop", "contents": "ostream &operator<<(ostream &out, const $1 &$2){\n\t${3:return out << $2;}\n}"},
        { "trigger": "cl", "contents": "cout << \"\\n\";"},
        { "trigger": "flush", "contents": "cout << endl;"},
        { "trigger": "pbds", "contents": "#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\ntemplate<class T, class Compare = less<>> using Tree = tree<T, null_type, Compare, rb_tree_tag, tree_order_statistics_node_update>;\n"},
        { "trigger": "changeto", "contents": "template<class T, class U> T &ctmax(T &x, const U &y){ return x = max<T>(x, y); }\ntemplate<class T, class U> T &ctmin(T &x, const U &y){ return x = min<T>(x, y); }\n"},
        { "trigger": "rope", "contents": "#include \"ext/rope\"\nusing namespace __gnu_cxx;\n"},
        { "trigger": "random", "contents": "using namespace chrono;\nmt19937 rng(high_resolution_clock::now().time_since_epoch().count());\nmt19937_64 rngll(high_resolution_clock::now().time_since_epoch().count());\n"},

        { "trigger": "fopen", "contents" : "ifstream cin; ofstream cout;\ncin.open(\"$1.in\"); cout.open(\"$1.out\");"},
        { "trigger": "fclose", "contents": "cin.close(); cout.close();"},
    ]
}